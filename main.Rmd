---
title: "main"
author: "Laura Moria"
date: "`r Sys.Date()`"
output: html_document
---

## Setup

```{r setup, include=FALSE}
#| label: setup
knitr::opts_chunk$set(echo = TRUE)
workspace <- paste0(Sys.getenv("NMI-SITE"), 'O 2000 - O 2001/2083.N.25 Effect ANLB pakketten op waterkwaliteit/04. Data en resultaten/')
nmidata <- Sys.getenv("NMI_DATA")

# load packages
library(data.table)
library(sf)
library(ggplot2)
library(gridExtra)
library(vip)
library(xgboost)
library(pdp)
# Install corrplot if you don't have it
if (!require(corrplot)) install.packages("corrplot")
library(corrplot)

# Later weer inladen
load("anlb_project.RData")

```

-   per collectief een overzicht ha per jaar type pakket
-   sken je sloot aantal locaties per jaar per pakket
-   locaties skenjesloot samenvoegen koppeling aan perceel + afstand dan check een unieke locatie per jaar en op kaart
-   datasets maken met relevante variabelen
-   cookbook runnen
-   grondsoort (OS in toplaag bodemschat),toevoegen percentage open water, PAL, P-belasting (wenr), drooglegging?

## Import data

```{r import geodata}
#| label: import geodata 
# Load base layer with EAGs 
EAG <- st_read(paste0(workspace,'./Beheerregister_EAG_20241218/Beheerregister_EAG_20241218.shp')) %>% st_transform(28992)

# load gewaspercelen
# brp <- st_read(paste0(nmidata,'./landgebruik/brp/products/brpgewaspercelen_2024_concept.gpkg')) %>% st_transform(28992)
# brpagv <- st_crop(brp, st_bbox(EAG))
# st_write(brpagv, 'brpagv.gpkg', append = FALSE)
brpagv <- st_read('output/brpagv.gpkg')

# load bodemschat
# bs6  <- st_read(paste0(nmidata, "bodem/bodemschat/products/BS6/BS6_2021.gpkg")) 
# bs6 <- st_crop(bs6,st_bbox(EAG))
# st_write(bs6, 'bs6agv.gpkg')
bs6 <- st_read('output/bs6agv.gpkg')
pvskp <- fread('input/PvskP.csv')
# pvskp <- readRDS('input/pvskp.rds')
```

```{r load and ppr anlb}
#| label: load anlb

# # anlb------------------------
# ## collectieven: "RVV" "NHZ" "NP" "HV" 
# ## perioden: 2016 tm 2021
# anlb2016 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2016.gpkg'))%>% st_transform(28992)
# setDT(anlb2016);anlb2016[,jaar:= 2016]
# anlb2017 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2017.gpkg'))%>% st_transform(28992)
# setnames(anlb2017, c('PAKKETNAAM','PAKKETCODE','DEELN_NAAM','LENGTH','AREA','COL','geom'),c('pakket','code','boer','len','opp','collectief','geom'))
# setDT(anlb2017);anlb2017[,jaar:= 2017]
# anlb2018 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2018.gpkg'))%>% st_transform(28992)
# setDT(anlb2018);anlb2018[,jaar:= 2018]
# anlb2019 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2019.gpkg'))%>% st_transform(28992)
# setDT(anlb2019);anlb2019[,jaar:= 2019]
# anlb2020 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2020.gpkg'))%>% st_transform(28992)
# setDT(anlb2020);anlb2020[,jaar:= 2020]
# anlb2021 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2021.gpkg'))%>% st_transform(28992)
# setDT(anlb2021);anlb2021[,jaar:= 2021]
# # 2022
# anlb2022 <- copy(anlb2021)
# anlb2022[,jaar:= 2022]
# # 2023 - 2028
# anlb2023_hv <- st_read(paste0(workspace,'./ANLB/Waterpakketten 2022.shp'))%>% st_transform(28992)
# anlb2023_hv$collectief <- "HV"
# anlb2023_hv$opp <- as.numeric(st_area(anlb2023_hv))/10000
# anlb2023_hv<- st_cast(anlb2023_hv,'MULTIPOLYGON')
# setDT(anlb2023_hv)
# setnames(anlb2023_hv, c('PAKKETNAAM','geometry'),c('pakket','geom'))
# anlb2023_uo <- st_read(paste0(workspace,'./ANLB/UO 2023 alle pakketten.gpkg'))%>% st_transform(28992)
# anlb2023_uo$collectief <- "UO"
# anlb2023_rvv <- st_read(paste0(workspace,'./ANLB/beheereenheden_2023-01-01_tot_2023-12-31_26-03-2024_12_47_boerennatuur-rijn-vecht-venen.shp'))%>% st_transform(28992)
# anlb2023_rvv$collectief <- "RVV"
# anlb2023_nhz <- st_read(paste0(workspace,'./ANLB/NHZ 2023 waterpakketten.gpkg'))%>% st_transform(28992)
# anlb2023_nhz$collectief <- "NHZ"
# setDT(anlb2023_uo);setDT(anlb2023_rvv);setDT(anlb2023_nhz)
# setnames(anlb2023_rvv, 'geometry', 'geom')
# anlb2023 <- rbind(anlb2023_uo,anlb2023_rvv,anlb2023_nhz)
# anlb2023 <- anlb2023[,c('PAKKETNAAM','PAKKETCODE','DEELN_ID','LENGTH','AREA','collectief','geom')]
# setnames(anlb2023, c('PAKKETNAAM','PAKKETCODE','DEELN_ID','LENGTH','AREA','geom'),c('pakket','code','boer','len','opp','geom'))
# anlb2023 <- rbind(anlb2023,anlb2023_hv, fill = TRUE)
# anlb2023[,jaar:= 2023]
# # 2024
# anlb2024 <- copy(anlb2023)
# anlb2024[,jaar:= 2024]

# ## alles samenvoegen ----------------
# anlb <- rbindlist(list(anlb2016,anlb2017,anlb2018,anlb2019,anlb2020,anlb2021,anlb2022,anlb2023, anlb2024), fill = TRUE, ignore.attr=TRUE)

# # overzichtstabel 4 pakketindeling --------------
# ## anlbchecktab <- unique(anlb[,c('pakket','pakket1','pakket2','pakket3')])
# ## write.csv2(anlbchecktab, file ='anlbchecktab.csv', fileEncoding = "latin4", quote = TRUE)
# # categorieen
# anlb_cat <- read.csv2(paste0(workspace,'./ANLB/anlbchecktab.csv'), sep =';', fileEncoding = "latin4")
# anlb_cat <- setDT(unique(anlb_cat[,c('pakket','pakket2','pakket3')]))
# anlb_cat <- anlb_cat[!is.na(pakket),]
# anlb <- merge(anlb[,-c('pakket2','pakket3')],anlb_cat, by = 'pakket', all.x = TRUE)
# anlb[pakket == 'hoog waterpeil\r\nverhoging 20 cm, 15 mrt tot 15 juni',pakket2 := 'water']
# anlb[pakket == 'hoog waterpeil\r\nverhoging 20 cm, 15 mrt tot 15 juni',pakket3 := 'water']
# anlb[pakket == 'plas-dras\r\n15 februari tot 15 mei, minstens 5 cm',pakket2 := 'water']
# anlb[pakket == 'plas-dras\r\n15 februari tot 15 mei, minstens 5 cm',pakket3 := 'water']
# anlb[pakket == 'verlenging Plas-dras 15 mei tot 15 juni',pakket2 := 'water']
# anlb[pakket == 'verlenging Plas-dras 15 mei tot 15 juni',pakket3 := 'water']

# ## filter waterpakketten -----------------------
# check <- as.data.table(unique(anlb$pakket[is.na(anlb$pakket2)]))
# anlb <- anlb[pakket2 == 'water',]
# #create sf object
# anlb <- anlb[,-c('fid')]
# anlb <- st_as_sf(anlb)
# unique(st_geometry_type(anlb))
# anlb <- st_cast(anlb,'MULTIPOLYGON')
# anlb <- st_make_valid(anlb)

# ## add collectief ---------------------------
# anlb_col <- st_read(paste0(workspace,'./ANLB/begrenzing_collectieven_manual.shp'))%>% st_transform(28992)
# anlb <- st_join(anlb, anlb_col, left = TRUE, largest = TRUE)
# setDT(anlb)
# anlb[is.na(Naam), Naam := 'HollandseVenen']
# anlb[,collectief := Naam]
# anlb <- st_as_sf(anlb)

# # merge with brp
# # anlb <- st_join(anlb, brpagv, left = TRUE, largest = TRUE)
# # setDT(anlb)
# # anlb[, jaar:= jaar.x];anlb[,jaar.x:=NULL];anlb[,jaar.y:=NULL]
# # anlb <- st_as_sf(anlb)

# st_write(anlb,'anlb_merged.gpkg', append = FALSE)

```

```{r load anlb}
#| label:  load merged object
anlb <- st_read('anlb_merged.gpkg')
#merge with EAG
anlb <- st_join(anlb, EAG[,c('EAGIDENT','geom','')], left = TRUE, largest = TRUE)

```

```{r import hybi}
#| label: import data hybi
hybi <- readRDS('../WaterEcoInzicht/data/hybi.rds') %>% as.data.table()
ptn_monsters <- unique(hybi$monsterident[hybi$analyse == 'PTN'])
hybi <- hybi[monsterident %in% ptn_monsters,]
hybiloc <- st_as_sf(unique(hybi[,c("locatie","EAGIDENT","XCOORD","YCOORD")]),coords = c("XCOORD","YCOORD"),crs = 28992)
```

```{r import bodchem}
#| label: import bodemchemie
bodchem <- readRDS('input/bodchem.rds')
# calc nalevering bodchemie
calc_watbod <- function(bodchem){
  
  # dcast slootbodem
  selb <- dcast.data.table(bodchem, EAGIDENT+locatie+datum+jaar ~ parameterid+compartiment, value.var = "meetwaarde", fun.aggregate = mean, fill= "")
  
  # calculate relevant ratios
  selb[,FeSP_DW := (Fe_mg_kg_dg_SB/55.845 - Stot_mgS_kg_dg_SB/32.065)/(Ptot_gP_kg_dg_SB*1000/30.974)]# deze zit in baggernut
  selb[,FeP_DW := (Fe_mg_kg_dg_SB/55.845)/(Ptot_gP_kg_dg_SB*1000/30.974)]
  selb[,FeS_DW := (Fe_mg_kg_dg_SB/55.845)/(Stot_mgS_kg_dg_SB/32.065)] # deze is meest relevant
  selb[,FeSP_FW := (Fe_mg_l_ng_SB/55.845 - Stot_mgS_l_ng_SB/32.065)/(Ptot_mgP_l_ng_SB/30.974)]# deze zit in baggernut
  selb[,FeP_FW := (Fe_mg_l_ng_SB/55.845)/(Ptot_mgP_l_ng_SB/30.974)]
  selb[,FeS_FW := (Fe_mg_l_ng_SB/55.845)/(Stot_mgS_l_ng_SB/32.065)]
  selb[,FeP_PW := (Fe_mg_l_nf_PW/55.845)/(Ptot_mgP_l_nf_PW/30.974)]# deze zit in baggernut & is meest relevant
  # selb[,FeS_PW := (Fe_mg_l_nf_PW/55.845)/(SO4_mg_l_nf_PW/96.06)]
  selb[,FeS_PW := (Fe_mg_l_nf_PW/55.845)/(Stot_mgS_l_nf_PW/96.06)]
  
  # calculate nalevering
  selb[,nlvr_FW := 0.0247 * Ptot_mgP_l_ng_SB - 1.6035]
  selb[,nlvr_PW := 0.8095 * Ptot_mgP_l_nf_PW - 0.2905]
  # selb[,nlvr_olson_FW := 5.8 * (Ptot_mgPOlsen_l_ng_BS/30.974) - 1.1361]
  
  #FW
  selb[,classFeSP_FW := cut(FeSP_FW, breaks = c((min(FeSP_FW, na.rm = TRUE)-1), 1.4, 4, max(FeSP_FW, na.rm = TRUE)), labels = c('geen ijzerval', 'beperkte ijzerval', 'functionele ijzerval'))]
  selb[FeSP_FW >= 4, nlvr_FW := 0.1 * nlvr_FW] # BaggerNut Tool zegt 0-1
  selb[FeSP_FW < 4 & FeSP_FW > 1.4, nlvr_FW := 0.5 * nlvr_FW] # BaggerNut zegt < nlvr_FW & > 0-1
  selb[FeSP_FW <= 1.4, nlvr_FW := nlvr_FW]
  selb[nlvr_FW < 0,nlvr_FW := 0]
  #PW
  selb[FeP_PW > 10 & FeS_PW > 1, c('nlvr_PW','classFESPPWratio') := list(0.1*nlvr_PW,'functionele ijzerval') ]  # BaggerNut zegt lage nalevering
  selb[FeP_PW > 1 & FeS_PW > 1, c('nlvr_PW','classFESPPWratio') := list(0.1*nlvr_PW,'functionele ijzerval') ]  # BaggerNut zegt lage nalevering
  selb[FeP_PW > 1 & FeS_PW <= 1, c('nlvr_PW','classFESPPWratio') := list(0.5*nlvr_PW,'beperkte ijzerval')] # BaggerNut zegt < nlvrPW 
  selb[FeP_PW <= 1, c('nlvr_PW','classFESPPWratio') := list(nlvr_PW,'geen ijzerval')]
  selb[nlvr_PW < 0,nlvr_PW := 0]
  
  return(selb)  
  
}

baggernut <- calc_watbod(bodchem)

```

```{r import skenjesloot}
#| label: import skenjesloot
skenjesloot <- list.files(path= paste0(workspace,'./skenjesloot/'), pattern=".csv", full.names =  T)
classes <- sapply(fread(skenjesloot[8L], sep=','), class)
skenjesloot <- lapply(skenjesloot, fread, sep=',', colClasses = unlist(classes))
skenjesloot <- rbindlist(skenjesloot, fill =T, use.names = T)
# unique(skenjesloot$datum)
# skenjesloot[,datum := as.Date(datum, format = "%Y-%m-%d")]
skenjesloot[,datum := as.Date(datum, format = "%d-%m-%Y")]
skenjesloot[,jaar := year(datum)]
skenjesloot[,maand := month(datum)]
skenjesloot[,c('xcoormonster','ycoormonster')  := list(as.integer(xcoormonster),as.integer(ycoormonster))]

ov_sjs <- dcast(skenjesloot, parameterid+parameter+parameterfractie+eenheid+eenheidreferentie~jaar)

# correct parcodes -----------
# skenjesloot[parameterid == 'PTN_BEDKG', parameterid := 'PTN_AANWZHD']
# skenjesloot[parameterid == 'PTN_AANWZHD', parameter := 'PTN_BEDKG']
# skenjesloot[parameterid == 'PERODSLSSNG_mnd', eenheid := 'mnd']
skenjesloot[parameterid == 'RIVIERKREEFTENLAND', parameter := 'Astacoidea_AANWZHD'] 
skenjesloot[meetwaarde == 99, meetwaarde := NA]

# enumeratievelden toevoegen ------------------
## baggeren5jaar
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == 'Nooit', meetwaarde := 0]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == '1 keer', meetwaarde := 1]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == '2 keer', meetwaarde := 2]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == '3 keer', meetwaarde := 3]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == '4 keer', meetwaarde := 4]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == 'vaker', meetwaarde := 5]
## schonen5jaar
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == 'Nooit', meetwaarde := 0]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == '1 keer', meetwaarde := 1]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == '2 keer', meetwaarde := 2]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == '3 keer', meetwaarde := 3]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == '4 keer', meetwaarde := 4]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == 'vaker', meetwaarde := 5]
## ander beheerpakket
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == 'Sloot_schonen', meetwaarde := 1]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == 'Sloot_maaien', meetwaarde := 2]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == 'Sloot_baggeren', meetwaarde := 3]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == 'Geen_maatregelen', meetwaarde := 4]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == "Sloot_schonen,Sloot_baggeren", meetwaarde := 5]             
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == "Sloot_schonen,Sloot_baggeren,Sloot_maaien", meetwaarde := 6]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == "Sloot_schonen,Sloot_maaien", meetwaarde := 7]               
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == "Sloot_maaien,Sloot_schonen", meetwaarde := 7]
## type/ machine schonen
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'maaikorf', meetwaarde := 1]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'hemos', meetwaarde := 2]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'ecoreiniger', meetwaarde := 3]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'spijlen', meetwaarde := 4]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'gaatjes', meetwaarde := 5]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'anders', meetwaarde := 6]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'nvt', meetwaarde := 7]
# fotodb separate
sjs_foto <- skenjesloot[parameterid %in% c('FOTONR','FOTO_n'),]
skenjesloot <- skenjesloot[!(parameterid %in% c('FOTONR','FOTO_n')),]
# replace puntkomma
# skenjesloot[,meetwaarde := gsub(',','.',meetwaarde)]
skenjesloot[,meetwaarde := as.numeric(meetwaarde)]
# correct diepte, doorzicht in 2023 en 2024
skenjesloot[parameterid %in% c("WATDTE_m", "SLIBDTE_m","ZICHT_m") & jaar %in% c(2020,2021,2022,2023,2024), meetwaarde := meetwaarde/100]
skenjesloot[parameterid %in% c("WATDTE_m", "SLIBDTE_m","ZICHT_m") & meetwaarde > 3, meetwaarde := meetwaarde/100]

# add par info -------------------
parameter <- data.table::fread(paste0(workspace,'./parameterid.csv'), fill = TRUE)
skenjesloot <- merge(skenjesloot, parameter[,c("code","naam",'pakket_agg','vraag sken je sloot', 'grootheid',"categorie","H_min", "H_max")], by.x = 'parameterid', by.y = 'code', suffixes = c('','_parameter'), all.x = TRUE)
skenjesloot <- skenjesloot[!parameterid == '',]

# check <- merge(parameter, unique(skenjesloot[,c('parameterid','parameter','parameterfractie','eenheid')]), by.x = 'code', by.y = 'parameterid', all.x = TRUE)

```

## data verwerking

### Anlb hybi

```{r merge hybi anlb} 
#| label: merge hybi anlb
# spatial merge met buffer van 1 meter rond pakketten
sf_use_s2(FALSE)
anlbhybi<- st_intersection(hybiloc, st_buffer(anlb, dist = 8), left = TRUE)
# percentage meetlocaties grenzend aan pakketten als jaren niet worden meegenomen 13.5 %
uniqueN(anlbhybi$locatie)/uniqueN(hybiloc$locatie)
# cast naar breed formaat, zodat locatie uniek is
setDT(anlbhybi)
anlbhybi[,jaar := as.numeric(jaar)]
anlbhybi <- dcast(anlbhybi, locatie+jaar~pakket3, fun.aggregate = uniqueN, value.var = 'pakket', drop = TRUE)
# add aantal jaar anlb
anlbhybi[,maxjaaranlb := max(jaar), by = locatie]
anlbhybi[,minjaaranlb := min(jaar), by = locatie]
# merge met hybi data
anlbhybi <- merge(hybi, anlbhybi, by = c('locatie','jaar'), all.x = T, suffixes = c('hybi','anlb'))
# add aantal paketten
anlbhybi[,pakket_n_anlb := rowSums(.SD, na.rm = TRUE), .SDcols = c('baggeren','bufferzone','nat.vriend.oever','slootschonen','water')]
# add 1 type beheer combi
anlbhybi[baggeren == 1 & nat.vriend.oever==1 & slootschonen == 1,beheer := 'baggeren_schonen_nvo', by = monsterident]
anlbhybi[baggeren == 1 & nat.vriend.oever==1 & slootschonen != 1,beheer := 'baggeren__nvo', by = monsterident]
anlbhybi[baggeren == 1 & nat.vriend.oever!=1 & slootschonen == 1,beheer := 'baggeren_schonen', by = monsterident]
anlbhybi[baggeren != 1 & nat.vriend.oever==1 & slootschonen == 1,beheer := 'schonen_nvo', by = monsterident]
anlbhybi[baggeren == 1 & nat.vriend.oever!=1 & slootschonen != 1,beheer := 'baggeren', by = monsterident]
anlbhybi[baggeren != 1 & nat.vriend.oever==1 & slootschonen != 1,beheer := 'nat.vriend.oever', by = monsterident]
anlbhybi[baggeren != 1 & nat.vriend.oever!=1 & slootschonen == 1,beheer := 'slootschonen', by = monsterident]
anlbhybi[is.na(beheer)|beheer =='NA' & is.na(bufferzone) & is.na(water), beheer:= 'regulier']
anlbhybi[is.na(beheer)|beheer =='NA', beheer:= 'overig']

setorder(anlbhybi,locatie,jaar)
# add anlb labels
anlbhybi[pakket_n_anlb == 0, anlb := 'nee']
anlbhybi[pakket_n_anlb >= 1, anlb := 'ja']
anlbhybi[,njaaranlb := jaar-minjaaranlb+1]
# year hybi 3 jaar > pakket
anlbhybi[pakket_n_anlb == 0 & jaar-3 >= minjaaranlb, anlb := 'historisch']
anlbhybi[pakket_n_anlb == 0 & jaar-2 >= minjaaranlb, anlb := 'historisch']
anlbhybi[pakket_n_anlb == 0 & jaar-1 >= minjaaranlb, anlb := 'historisch']
check <- anlbhybi[anlb == 'historisch',]

# alternatief 1: merge with gebiedstype agrarisch
# anlbhybi <- merge(anlbhybi, EAG, by.x = 'EAGIDENT',by.y = 'Code', all.x = T)
# sel only agrarisch (421380)
# anlbhybi <- anlbhybi[gebiedstype == 'agrarisch',]

# alternatief 2: filter alleen EAGs met anlb 313006 over van 850953
anlbeag <- unique(anlbhybi[anlbhybi$anlb == 'ja', c('EAGIDENT', 'jaar')])
anlbeag[,eagjaar:= paste0(EAGIDENT,jaar)]
anlbhybi <- anlbhybi[paste0(EAGIDENT,jaar) %in% anlbeag$eagjaar,]
# filter by water type
anlbhybi <- anlbhybi[!watertype %in% c('M20','M27'),]

# for spatial check
anlbhybi <- st_as_sf(anlbhybi, coords = c("XCOORD","YCOORD"), crs = 28992)
geoanlbhybi <- anlbhybi[anlbhybi$parameter == "SUBMSPTN",
              c('locatie','jaar','anlb','njaaranlb','beheer','geometry')]
geoanlbhybi <- st_as_sf(geoanlbhybi)
st_write(geoanlbhybi, 'geoanlbhybi.gpkg', append=FALSE)

```

```{r data enrichment anlbhybi}
#| label: data enrich anlbhybi
setDT(anlbhybi)
n_soort_sub <- anlbhybi[, uniqueN(biotaxonnaam[submers == 1]), by = c('monsterident','locatie','jaar','compartiment')]
setnames(n_soort_sub, "V1", "n_soort_sub")
n_soort_sub[,n_soort_sub := n_soort_sub - 1]
n_soort_ems <- anlbhybi[, uniqueN(biotaxonnaam[emers == 1]),by = c('monsterident','locatie','jaar','compartiment')]
setnames(n_soort_ems, "V1", "n_soort_ems")
n_soort_ems[,n_soort_ems := n_soort_ems - 1]
n_soort_oever <- anlbhybi[compartiment == 'OR' & parameterid == 'PTN_BEDKG_%' & parameter == "", uniqueN(biotaxonnaam),by = c('monsterident','locatie','jaar','compartiment')]
setnames(n_soort_oever, "V1", "n_soort_oever")

# cast naar breed formaat, zodat locatie uniek is
anlbhybi_cast <- dcast(anlbhybi, EAGIDENT+locatie+monsterident+compartiment+watertype+jaar+anlb+njaaranlb+pakket_n_anlb+beheer+baggeren+bufferzone+nat.vriend.oever+slootschonen+water~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde', drop = TRUE)
# merge aantal soorten
anlbhybi_cast <- merge(anlbhybi_cast, n_soort_sub, by = c('monsterident','locatie','jaar','compartiment'), all.x = TRUE)
anlbhybi_cast <- merge(anlbhybi_cast, n_soort_ems, by = c('monsterident','locatie','jaar','compartiment'), all.x = TRUE)
anlbhybi_cast <- merge(anlbhybi_cast, n_soort_oever, by = c('monsterident','locatie','jaar','compartiment'), all.x = TRUE)
# add diepte doorzicht
anlbhybi_cast[,zichtdte := ZICHT_m_ZICHT_/ WATDTE_m_WATDTE_]
# correct submers met flab
anlbhybi_cast[`PTN_BEDKG_%_SUBMSPTN_` > `PTN_BEDKG_%_FLAB_SUBMS`, `PTN_BEDKG_%_SUBMSPTN_`:= `PTN_BEDKG_%_SUBMSPTN_`-`PTN_BEDKG_%_FLAB_SUBMS`]
# remove columns with only NA
anlbhybi_cast <- anlbhybi_cast[, which(unlist(lapply(anlbhybi_cast, function(x) !all(is.na(x))))), with = FALSE]
colnames(anlbhybi_cast)
# remove certain cols
anlbhybi_cast <- anlbhybi_cast[,-c("FOTO_n_FOTO_","PTN_BEDKG_%__DRIJVD","PTN_BEDKG_%__EMS","PTN_BEDKG_%__SUBMS","SLIBDTE_m_LINKSMDPTJT_SLIBDTE_","SLIBDTE_m_RECHTSMDPTJT_SLIBDTE_")]
# add values
anlbhybi_cast[is.na(njaaranlb), njaaranlb := 0]
anlbhybi_cast[is.na(pakket_n_anlb), pakket_n_anlb := 0]
anlbhybi_cast[is.na(baggeren), baggeren := 0]
anlbhybi_cast[is.na(bufferzone), bufferzone := 0]
anlbhybi_cast[is.na(nat.vriend.oever), nat.vriend.oever := 0]
anlbhybi_cast[is.na(slootschonen), slootschonen := 0]
anlbhybi_cast[is.na(water), water := 0]


```

```{r eag hybi enrichment}
#| label: EAGdata toevoegen
anlbhybi_cast <- merge(anlbhybi_cast, EAG, by.x = 'EAGIDENT',by.y = 'Code', all.x = T)
anlbhybi_cast[, rel_water := Water_m2/EAG_m2*100]
```

```{r add bodemdata anlbhybi}
#| label: add bodemdata anlbhybi
# bodemdata toevoegen
# bodemschat
hybiloc_bs <- st_join(hybiloc, st_buffer(bs6, dist = 5), left = TRUE, largest = TRUE)

# bodemchemie
loc_bod <- unique(bodchem[!is.na(XCOORD) & !is.na(YCOORD), c("locatie","EAGIDENT","XCOORD","YCOORD")])
loc_bod <- st_as_sf(loc_bod, coords = c("XCOORD","YCOORD"), crs = 28992)

# Process each hybiloc point to find the nearest loc_bod in the same EAGIDENT

# Function to find nearest point within same EAGIDENT
find_nearest_in_same_eag <- function(point_sf, candidates_sf) {
  # Get the EAGIDENT of the current point
  current_eag <- point_sf$EAGIDENT[1]
  
  # Filter candidates to only those in the same EAGIDENT
  same_eag <- candidates_sf[candidates_sf$EAGIDENT == current_eag, ]
  
  # If no points in the same EAGIDENT, return NA
  if (nrow(same_eag) == 0) {
    return(NA)
  }
  
  # Calculate distances
  dists <- st_distance(point_sf, same_eag)
  
  # Find index of minimum distance
  min_idx <- which.min(dists[1,])
  
  # Return the nearest point
  return(same_eag[min_idx, ])
}

# Create new data frame to store results
matches <- data.frame(
  hybi_locatie = character(),
  hybi_eagident = character(),
  loc_bod_locatie = character(),
  distance = numeric(),
  stringsAsFactors = FALSE
)

# Process each hybi point
for (i in 1:nrow(hybiloc_bs)) {
  cat("Processing", i, "of", nrow(hybiloc_bs), "\r")
  
  # Get current point
  current_point <- hybiloc_bs[i, ]
  
  # Find nearest loc_bod in same EAGIDENT
  nearest_bod <- find_nearest_in_same_eag(current_point, loc_bod)
  
  # If match found, store it
  if (!is.na(nearest_bod)[1]) {
    dist <- st_distance(current_point, nearest_bod)
    matches <- rbind(matches, data.frame(
      hybi_locatie = current_point$locatie,
      hybi_eagident = current_point$EAGIDENT,
      loc_bod_locatie = nearest_bod$locatie,
      distance = as.numeric(dist),
      stringsAsFactors = FALSE
    ))
  }
}

# Convert to data.table for efficiency
matches <- as.data.table(matches)

# Join the matched data back to the hybi dataset
hybiloc_with_bod <- merge(
  as.data.table(st_drop_geometry(hybiloc_bs)),
  matches,
  by.x = c("locatie", "EAGIDENT"),
  by.y = c("hybi_locatie", "hybi_eagident"),
  all.x = TRUE
)

# Now you can join this with your anlbhybi_cast data
anlbhybi_bod <- merge(
  anlbhybi_cast,
  hybiloc_with_bod,
  by.x = c("locatie"),
  by.y = c("locatie"),
  all.x = TRUE,
  suffixes = c("", "_bodchem_loc")
)

# Check how many matches we got
cat("Found matches for", uniqueN(matches$loc_bod_locatie), "out of", nrow(loc_bod), "soil chemistry locations\n")
cat("These matches correspond to", uniqueN(matches$hybi_locatie), "hydrological locations\n")

# Now merge the soil chemistry data (let op dubbele jaren per locatie)
anlbhybi_bod <- merge(
  anlbhybi_bod,
  baggernut,
  by.x = c("loc_bod_locatie"),
  by.y = c("locatie"),
  all.x = TRUE,
  suffixes = c("", "_bodchem")
)

# correct locations with more than one year bodchem
anlbhybi_bod[,n_jaar_bodchem := uniqueN(jaar_bodchem), by = locatie]
check <- anlbhybi_bod[n_jaar_bodchem > 1, .(locatie, jaar, jaar_bodchem, n_jaar_bodchem)]
anlbhybi_bod <- anlbhybi_bod[!(n_jaar_bodchem > 1 & jaar_bodchem == 2013),]


```

```{r add pvskp}
#| label: add pvskp

anlbhybi_bod[,GAFIDENT := sapply(strsplit(EAGIDENT, '-'), `[`, 1)]
anlbhybi_bod[,GAFIDENT := as.numeric(GAFIDENT)]
pvskp[,GAFIDENT := as.numeric(GAFident)]
pvskp <- pvskp[!is.na(GAFIDENT) & !grepl('EAG', GAF),]
anlbhybi_bod <- merge(anlbhybi_bod, pvskp, by.x = 'GAFIDENT', by.y = 'GAFIDENT', all.x = TRUE)

```

### Skenjesloot

```{r sjs data npakket}
#| label:  dat ppr skenjesloot
# add aantal paketten
npakket <- skenjesloot[,sum(meetwaarde[grepl('^BEHPK', parameterid) | parameterid == 'BEHRPKNVO_SOORT'], na.rm = TRUE), by = c('monsterident','externereferentie','jaar')]
npakket[,parameterid := 'BEHP_AANWZG']
npakket[,parameter := 'pktaanwez']
npakket[,naam := 'aantal beheerpakketten']
npakket[,meetwaarde := V1]
skenjesloot <- rbindlist(list(skenjesloot,npakket), fill = TRUE)
```

```{r sjsloc aggregeren}

#| label: locaties aggregeren binnen een afstand van 150 meter op zelfde 1.5 meter gebufferde perceel 
skenjeslootloc <- unique(skenjesloot[,c("externereferentie","jaar","xcoormonster","ycoormonster")])
skenjeslootloc[,ident:= paste0(xcoormonster,"_",ycoormonster)]
skenjeslootloc <-skenjeslootloc[!is.na(xcoormonster),]
skenjeslootloc <- st_as_sf(skenjeslootloc,coords = c("xcoormonster","ycoormonster"),crs = 28992) #2182
skenjeslootloc <- st_join(skenjeslootloc, st_buffer(brpagv[!(brpagv$category == 'Landschapselement'),!names(brpagv) %in% "jaar"], dist = 5), left = TRUE, largest = TRUE)
setDT(skenjeslootloc)
check<- unique(skenjeslootloc[is.na(skenjeslootloc$ref_id),c("externereferentie",'ident','jaar','ref_id')])
skenjeslootloc[,brp_nr := rep(seq_len(.N), each = 1, length.out = .N), by = 'ref_id']
skenjeslootloc[,dist := st_distance(geometry[brp_nr == 1], geometry), by ='ref_id']
skenjeslootloc[,dist := as.numeric(dist)]
sslocmatch <- skenjeslootloc[brp_nr == 1,]
skenjeslootloc <- merge(skenjeslootloc, sslocmatch[,c('externereferentie','ref_id', 'jaar')], by = 'ref_id', suffixes = c('','_match'), all.x = TRUE, all.y = FALSE)
# combine locs within 100 meter on same brp gewasperceel in verschillende jaren (soms zijn het wel andere sloten)
skenjeslootloc[, id := externereferentie]
skenjeslootloc[dist < 150 & !(jaar == jaar_match), id := externereferentie_match]

```

```{r sjs loc join eag}
#| label:  join with EAG
skenjeslootloc <- st_as_sf(skenjeslootloc)
skenjeslootloc <- st_join(skenjeslootloc, EAG, left = TRUE, largest = TRUE)
skenjeslootloc <- merge(skenjeslootloc, npakket[,c('externereferentie','jaar','meetwaarde')], by = c('externereferentie','jaar'), suffixes = c('','_loc'), all.x = TRUE)
# export
skenjeslootloc <- st_as_sf(skenjeslootloc)
st_write(skenjeslootloc, 'output/skenjeslootloc.gpkg', append = FALSE)
# check in GIS door te kleuren op nieuwe locatiecode
# check als tabel/plot
setDT(skenjeslootloc)
skenjeslootloc[, nmeetjaar := uniqueN(jaar), by = 'id']
# merge new id with data
skenjesloot <- merge(skenjesloot,skenjeslootloc, by = c('externereferentie','jaar'), suffixes = c('','_loc'), all.x = TRUE)
```

```{r sjs beheer toevoegen}
#| label: create table with beheer
sjs_beheer <- unique(skenjesloot[(grepl('^BEHPK', parameterid) | parameterid == 'BEHRPKNVO_SOORT') & meetwaarde == 1 , c('externereferentie','jaar','pakket_agg')])
# afrastering
sjs_beheer_2 <- unique(skenjesloot[parameterid=='OEVBSIG_SOORT'& meetwaarde %in% c(53,59,56,57),c('externereferentie','jaar','pakket_agg')])
sjs_beheer_2[,pakket_agg:='afrastering']
#samenvoegen
sjs_beheer <-rbind(sjs_beheer,sjs_beheer_2)
# format
sjs_beheer <- dcast(sjs_beheer, externereferentie+jaar~pakket_agg)
# PERODSLSSNG_mnd en 	PERODSLSBGODHD_a
sjs_beheer_3 <- dcast(skenjesloot[parameterid%in%c('PERODSLSSNG_mnd','PERODSLSBGODHD_a'),],externereferentie+jaar~parameterid, value.var = 'meetwaarde', fun.aggregate = mean)
sjs_beheer <- merge(sjs_beheer,sjs_beheer_3, by = c('externereferentie','jaar'))
# add 1 type beheer combi
sjs_beheer[,beheer := paste0(afrastering,'_',baggeren,'_',schonen,'_',nvo), by = externereferentie]
sjs_beheer[,beheer:= gsub('_NA','',beheer)]
sjs_beheer[,beheer:= gsub('NA_','',beheer)]
sjs_beheer[is.na(beheer)|beheer =='NA'& is.na(rand) & is.na(water), beheer:= 'regulier']
sjs_beheer[is.na(beheer)|beheer =='NA', beheer:= 'randen']
# merge with data
ss_beheer <- merge(skenjesloot, sjs_beheer, by =c('externereferentie','jaar'), suffixes = c('','_beheer'), all.x = TRUE)
ss_beheer[is.na(beheer)|beheer =='NA',beheer:= 'regulier']
# add label wel/niet beheer
ss_beheer[,welnietbeheer:= 'ja']
ss_beheer[beheer%in% c('regulier','overig'),welnietbeheer:= 'nee']
# check beheer
checknobs <- dcast(ss_beheer, value.var = 'externereferentie', fun.aggregate = uniqueN,jaar~beheer)
checknobs <- ss_beheer[,uniqueN(externereferentie),by =c('jaar','beheer' )]
fwrite(checknobs, file= paste0('skenjesloot_npakket.csv'), sep = ';', dec ='.', )

# Select only samples with matching grouping variables (same EAG, same year)
# This ensures we only compare locations within the same EAG where both treatment and control exist
match_samples <- ss_beheer[, .(has_both = uniqueN(welnietbeheer) == 2), by = .(Code, jaar)]
match_samples <- match_samples[has_both == TRUE]
ss_beheer <- ss_beheer[paste0(Code, jaar) %in% paste0(match_samples$Code, match_samples$jaar)]
ss_beheer <- ss_beheer[!is.na(Code) ,]

```

```{r merge sjs anlb}
#| label: merge anlb sjs
# spatial merge met buffer van 1 meter rond pakketten
# check if all sken je sloot are present and multiple anlb possible
skenjeslootloc <- st_as_sf(skenjeslootloc)
anlbsjs <- st_join(skenjeslootloc, st_buffer(anlb[,!names(anlb)%in% c('id')], dist = 8), left = TRUE)
# Extract coordinates as a matrix
coords <- st_coordinates(anlbsjs)
setDT(anlbsjs)
anlbsjs <- cbind(anlbsjs, coords)
anlbsjs[,jaar_sjs := jaar.x];anlbsjs[,jaar_anlb := jaar.y];anlbsjs[,jaar.x:=NULL];anlbsjs[,jaar.y:=NULL]
anlbsjs[!(jaar_sjs == jaar_anlb), c('pakket','pakket2','pakket3') := list(NA,NA,NA)]
anlbsjs_cast <- dcast(anlbsjs, externereferentie+X+Y+id+jaar_sjs+ref_id+dist+Code+WtypeBR~pakket3, fun.aggregate = uniqueN, value.var = 'pakket')
anlbsjs_cast[,pakket_n_anlb := rowSums(.SD, na.rm = TRUE), .SDcols = c('baggeren','bufferzone','nat.vriend.oever','slootschonen','water')]
# merge met beheer info sken je sloot
anlbsjs_cast <- merge(anlbsjs_cast, sjs_beheer, by.x = c('externereferentie', 'jaar_sjs'), by.y = c('externereferentie', 'jaar'), all.x = T, suffixes = c('anlb','sjs'))

# for spatial check
# check wel niet beheer 'ja' en anlb = nee
geoanlbsjs <- unique(anlbsjs_cast[, c('externereferentie','jaar_sjs','beheer','afrastering','baggerensjs','nvo','rand','schonen','pakket_n_anlb', 'baggerenanlb','bufferzone','nat.vriend.oever','slootschonen','wateranlb',"X","Y")])
geoanlbsjs <- st_as_sf(geoanlbsjs[!is.na(X),], coords = c("X","Y"), crs = 28992)
st_write(geoanlbsjs, 'output/geoanlbsjs.gpkg', append=FALSE)
```

### Conclusie data

Omdat er nog steeds data ontbreekt in de skenjesloot data, de hoeveelheid monsters die geschikt is voor analyse beperkt is en ik twijfels heb over de kwaliteit van de gegevens, denk ik dat het beter is om de diepgaande XGBoost (machine learning) analyse alleen uit te voeren met de geografische bestanden van ANLB en data van Waterproef. De sken je sloot data wordt wel gerapporteerd in figuren, waarmee het onderstaande wordt onderbouwd.

In de skenjesloot data zijn maar weinig monsters verzameld op locaties waar alléén afrastering is (45 in 8 jaar) geplaatst of aléén is geschoond (165 in 8 jaar) en de baggerfrenquentie is niet bepaald op locaties waar geen pakketten zijn afgesloten. De hoeveelheid geschikte monsters wordt verder beperkt door de beschikbaarheid van monsters binnen eenzelfde watersysteem en meetjaar waar het beheer zowel wel als niet is aangepast. 

We zien ook weinig effect van beheer op de gemeten vegetatie in de data van skenjesloot. We zien een klein positief effect van afrastering en schonen op de emerse- en submerse vegetatiebedekking en een negatief effect van baggeren en combinaties van baggeren met andere pakketten. Wat wel te zien is, is dat de waterdiepte groter is op de meeste locaties met beheerpakketten en dat doorzicht/ waterdiepte (lichtklimaat) hoger is op locaties met beheerpakketten. 

Dilemma: ook in data van Waterproef zie ik weinig effect en blijven er uiteindelijk weinig monsterlocaties over als ik alleen kijk naar wel/ geen beheer in dezelfde EAG's. In deze data hebben we geen info over afrastering en het aantal jaren gelden dat er voor het laatst gebaggerd is (omdat dit niet uit pakketten is af te leiden). Daarnaast is de vraag hoe betrouwbaar de informatie is over de aanwezigheid van beheerpakketten en hoe onderscheidend dit is voor het werkelijk uitgevoerde beheer. 

Missende data:
- biotaxonnaam is NA, behalve in 2017 en 2021 (dit was niet zo in eerdere geleverde datasets)
- deelnemers (namen/ id) staan niet in de data geleverd
- het aantal unieke waarnemingen van de meeste parameters (beheerpakketten, vegetatiebedekking) is gelijk in 2020, 2021 en 2022. Deze aantallen komen niet overeen met het aantal bemonsterde sloten in de app/ data viewer en eerder geleverde data. Het lijkt erop alsof er data mist of juist dubbel is gerapporteerd
- data uit 2017 ontbreekt

Vragen over de data:
- geen biotaxa in de data van 2023 en 2024, zijn er in deze jaren geen biotaxa bepaald?
- klopt het dat laatste jaar gebaggerd en geschoond niet is ingevuld als er geen anlb pakket is aangevinkt?
- hoe is omgegeaan met het gerapporteerde getal bij "het aantal jaren geleden dat er voor het laatst is gebaggerd of geschoond". Gaat het om het aantal jaren voorafgaand aan de bemonstering of het aantal jaren voorafgaand aan een jaar dat baggeren op de planning staat of er een pakket is afgesloten (ook als de monitoring voorafgaand aan het uitvoeren van baggeren plaatsvindt)?

Fouten in geleverde data:
- meetwaarden waterdiepte, slibdikte (alles met eenheid m) is een factor 100 te groot in data van 2023 en 2024
-	het datumformaat in bestanden 2018 t/m 2022 is niet uniform (soms eerst jaar-maand-dag dan weer dag-maand-jaar), zelfs niet binnen één bestand van één meetjaar
-	datum ontbreekt bij veel records in 2019
- meetwaarden zijn niet altijd nummeriek; wenselijker is om ennumeraties of waardenbereiken te gebruiken (bijvoorbeeld bij laatste keer gebaggerd of geschoond, ander beheerpakket en type/machine schonen). Er zijn eerder afspraken gemaakt over te hanteren enumeraties
- er worden soms punten en soms komma's gebruikt als decimaalteken in meetwaarden

Twijfels kwaliteit data sken je sloot:
- het valt op dat er geen relatie is tussen de gemeten waterdiepte en de vegetatiebedekking. Dit roept vragen op over de kwaliteit van de data, omdat deze relatie wel wordt verwacht en wel zichtbaar is in de data die door Waterproef is verzameld
- ik heb er twijfels over of antwoorden/ meetwaarden altijd op dezlfde manieren geïnterpreteerd zijn, nu staat er bij sommige monsters met beheerpakket baggeren dat er 0, 1, 2 of 5 jaar geleden voor het laatst is gebaggerd; wat betekent het als er een getal 0 of 5 staat? In welk geval is er gebaggerd voorafgaand en wanneer in hetzelfde jaar, maar pas na het uitvoeren van skjesloot, als de monitoring?

Toekennen van beheer aan monsterlocaties:
Het valt op dat de gerapporteerde beheerpakketten in skenjesloot in veel gevallen niet overeen komen met de door de collectieven aangeleverde geografische informatie over de ligging van afgesloten beheerpakketten
  - er staan regematig natuur vriendelijke oevers in sken je sloot die niet in de anlb pakketten voorkomen. Komt dit omdat er geen vergoeding is voor het beheer van natuurvriendelijke oevers?
  - er staan regematig verschillende beheerpakketten in sken je sloot, terwijl er geen enkel anlb pakketten is afgesloten. Welke data is het meest representatief voor het werkelijke beheer?
  - er staan regelmatig verschillende beheerpakketen in sken je sloot en anlb. Bijvoorbeeld 2510-EAG-1, 2630-EAG-1, 6430-EAG-1, 2501-EAG-2, 2400-EAG-. Vooral beheerpakket baggeren komt niet overeen. Voor een analyse is het essentieel dat de toekenning van beheer aan meetlocaties correct is en beide bronnen geven een andere toekenning (de één schonen en de ander baggeren). Is het een idee om een aantal voorbeelden met collectieven te bespreken om te achterhalen welke data het meest representatief is voor het werkelijke beheer?

## visualisatie

### Anlb

```{r anlb}
#| label: anlb n pakket by brp
# overzichttabel obv csv bestanden
brp_anlb <- st_join( brpagv, anlb, left = TRUE, largest = TRUE)
setDT(brp_anlb)
ov_anlb <- dcast(brp_anlb, pakket2+pakket3+collectief~jaar.y, fun.aggregate = uniqueN, value.var = 'ref_id.x')
fwrite(ov_anlb, file= paste0('ov_anlb.csv'), sep = ';', dec ='.', )

npakket <- dcast(anlb, ref_id+jaar~., fun.aggregate = uniqueN, value.var = 'pakket')

ggplot(data = npakket)+
  geom_bar(aes(x = jaar, fill = as.factor(`.`)), 
           position = 'stack') +
  scale_fill_discrete(labels = c('1 pakket','2 pakketten','3 pakketten','4 pakketten','5 pakketten','6 pakketten','7 pakketten','8 pakketten'))+
  guides(fill=guide_legend(title=''))+
  scale_x_continuous(n.breaks = 8, labels = scales::number_format(accuracy = 1, big.mark = ''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Anlb beheerpakketten per brp eenheid") +
    labs(x="",y="aantal percelen")


```

```{r anlb hybi}
ov_anlb <- dcast(anlbhybi, locatie~jaar, fun.aggregate = uniqueN, value.var = 'pakket2')
fwrite(ov_anlb, file= paste0('ov_anlb.csv'), sep = ';', dec ='.', )
```

### Hybi - parameters

```{r overview hybi}
#| label: overview hybi
# overzichttabel obv csv bestanden
ov_hybi <- dcast(anlbhybi, parameterid+parameter+compartiment+watertype~jaar, fun.aggregate = uniqueN, value.var = 'locatie')
colnames(anlbhybi)
fwrite(ov_hybi, file= paste0('hybi_pars.csv'), sep = ';', dec ='.', )
```

#### Emers

```{r emers versus beheer}
#| label: emers versus beheer 
getPalette = palette.colors(palette = "Okabe-Ito")[-c(1, 10)]
ss_emers <- anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter == 'EMSPTN' & compartiment == 'EZ' & watertype %in% c('M10','M1a','M8'),]
ss_emers[,n_obs:=uniqueN(externereferentie),by =c('parameter','jaar','beheer')]

ggplot(data = ss_emers[n_obs > 9,])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = beheer),) +
  geom_text(aes(x = beheer, y=110, label = n_obs), size = 4)+
  guides(fill=guide_legend(title='Beheer'))+
  scale_fill_manual(values = getPalette)+
  facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking emers") +
    labs(x="",y="%")

```

```{r emers bedekking by eag}
#| label: submerse bedekking by eag
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], EAGIDENT+jaar~anlb, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee, y = ja)) +
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14,
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren en/of schonen (%)")
```

```{r submers bedekking by eag bageren}
#| label: submerse bedekking by eag baggeren

anlbhybi[is.na(baggeren),baggeren:= 0]
anlbhybi[baggeren == 2, baggeren := 1]
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], EAGIDENT+jaar~baggeren, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = `0`, y = `1`)) +
  facet_wrap(jaar~.)+
  geom_abline(slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren en/of schonen (%)")
```

```{r data emers soorten vs beheer}
#| label: emers verus beheer soorten (geen combipakketten)
anlbhybi[watertype %in%c('M10','M1a','M8'),n_obs:=uniqueN(monsterident),by =c('parameterid','parameter','compartiment','beheer')]
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%"  
                               & compartiment == "EZ" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = n_soort_ems)) +
  geom_text(aes(x = beheer, y=max(anlbhybi$n_soort_ems, na.rm = T), label = n_obs))+
  facet_wrap(watertype~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Aantal unieke emerse soorten") +
    labs(x="",y="n")
  # ylim(0,15)
```

```{r data sluiting emers}
#| label: emers verus beheer sluiting (geen combipakketten)	
ggplot(data = anlbhybi[parameterid == "PTN_LENGTFTE_%"  
                               & parameter == "EMSPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=100, label = n_obs))+
  facet_wrap(watertype~.)+
    theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Sluitingspercentage emers") +
    labs(x="",y="%")
  # ylim(0,15)
```

```{r data breedte emers}	
#| label: emers verus beheer breedte (geen combipakketten)
ggplot(data = anlbhybi[parameterid == "PTN_BREEDTE_m"  
                               & parameter == "EMSPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=max(anlbhybi[parameterid == "PTN_BREEDTE_m"  
                               & parameter == "EMSPTN" 
                               & watertype %in%
                          c('M10','M1a','M8'),'meetwaarde']+0.1), label = n_obs))+
  facet_wrap(watertype~.)+
    theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Breedte emers") +
    labs(x="",y="m")
```

#### Oever
```{r data oeverplanten vs beheer}
#| label: oeverplanten verus beheer (geen combipakketten)	
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%"  
                               & parameter == "OEVPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=100, label = n_obs))+
  facet_wrap(watertype~.)+
   theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking oeverplanten boven de waterlijn") +
    labs(x="",y="%")
  # ylim(0,15)
```

```{r data oever soorten vs beheer}
#| label: oever verus beheer soorten (geen combipakketten)
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%" & parameter == ""
                               & compartiment == "OR" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = n_soort_oever)) +
  geom_text(aes(x = beheer, y=max(anlbhybi$n_soort_oever, na.rm = TRUE), label = n_obs))+
  facet_wrap(watertype~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Aantal unieke oeversoorten") +
    labs(x="",y="n")
```

```{r data sluiting oeverplanten}	
ggplot(data = anlbhybi[parameterid == "PTN_LENGTFTE_%"  
                               & parameter == "OEVPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=100, label = n_obs))+
  facet_wrap(watertype~.)+
   theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Sluitingspercentage oeverplanten") +
    labs(x="",y="%")
  # ylim(0,15)
```

#### Submers
```{r submers vs beheer}
#| label: submers
ss_submers <- anlbhybi[parameter == 'SUBMSPTN' & compartiment == 'EZ' & watertype %in% c('M10','M1a','M8'),]
ss_submers[,n_obs:=uniqueN(externereferentie),by =c('parameter','jaar','beheer')]

ggplot(data = ss_submers[n_obs > 9,])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = beheer)) +
  geom_text(aes(x = beheer, y=110, label = n_obs), size = 4)+
  guides(fill=guide_legend(title='Beheer'))+
  scale_fill_manual(values = getPalette)+
  facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers") +
    labs(x="",y="%")
```

```{r submers bedekking by eag}
#| label: submerse bedekking by eag
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], EAGIDENT+jaar~anlb, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee, y = ja)) +
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren en/of schonen (%)")
```

```{r submers bedekking by eag bageren}
#| label: submerse bedekking by eag baggeren

anlbhybi[is.na(baggeren),baggeren:= 0]
anlbhybi[baggeren == 2, baggeren := 1]
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], EAGIDENT+jaar~baggeren, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = `0`, y = `1`)) +
  facet_wrap(jaar~.)+
  geom_abline(slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren (%)")
```

```{r submers bedekking by eag schonen}
#| label: submerse bedekking by eag schonen

anlbhybi[is.na(slootschonen),slootschonen:= 0]
anlbhybi[slootschonen == 2, slootschonen := 1]
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], EAGIDENT+jaar~slootschonen, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = `0`, y = `1`)) +
  # facet_wrap(jaar~.)+
  geom_abline(slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket schonen (%)")
```

```{r data submers vs beheer per watertype}	
#| label: submers verus beheer (geen combipakketten)
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%"  
                               & parameter == "SUBMSPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=100, label = n_obs))+
  # facet_wrap(watertype~.)+
   theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submerse planten") +
    labs(x="",y="%")
  # ylim(0,15)
```

```{r data submers soorten vs beheer}
#| label: submers verus beheer soorten (geen combipakketten)
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%"  
                               & compartiment == "EZ" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = n_soort_sub)) +
  geom_text(aes(x = beheer, y=max(anlbhybi$n_soort_sub, na.rm = TRUE), label = n_obs))+
  facet_wrap(watertype~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Aantal unieke submerse soorten") +
    labs(x="",y="n")
```

```{r submers vs doorzicht}
#| label: submers vs doorzicht

palette <- palette.colors(palette = "Okabe-Ito", n = unique(anlbhybi_cast$jaar))
ggplot(data = anlbhybi_cast)+
  geom_point(aes(x = zichtdte , y = `PTN_BEDKG_%_SUBMSPTN_`, color = as.factor(jaar))) +
  geom_smooth(aes(x = zichtdte , y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'lm', color = 'black')+
  xlim(0,1)+
  # facet_wrap(anlb~.)+
  scale_color_manual(values = palette, name = 'Jaar')+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Doorzicht vs bedekking submers") +
    labs(x="doorzicht/waterdiepte",y="bedekking submers (%)")

```

```{r submers vs waterdiepte}
#| label: submers vs waterdiepte

palette<- palette.colors(palette = "Okabe-Ito", n = unique(anlbhybi_cast$jaar))

ggplot(data = anlbhybi_cast)+
  geom_point(aes(x = WATDTE_m_WATDTE_ , y = `PTN_BEDKG_%_SUBMSPTN_`, color = as.factor(jaar))) +
  geom_smooth(aes(x = WATDTE_m_WATDTE_ , y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'loess', color = 'black')+
  xlim(0,1)+
  # facet_wrap(anlb~.)+
  scale_color_manual(values = palette, name = 'Jaar')+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Waterdiepte vs bedekking submers") +
    labs(x="waterdiepte",y="bedekking submers (%)")

```

#### fysische parameters

```{r data waterdiepte vs beheer}	
#| label: waterdiepte verus beheer (geen combipakketten)
ggplot()+
  geom_boxplot(data = anlbhybi[ parameterid == "TALBVWTR_graad"  ], aes(x = beheer, y = meetwaarde))#+ ylim(0,15)

ggplot()+
  geom_boxplot(data = anlbhybi[parameterid == "WATDTE_m" &
                              watertype %in% c('M10','M1a','M8')], aes(x = beheer, y = meetwaarde))+ ylim(0,1)
```

### Skenjesloot - Anlb
```{r pakketten vergelijking}
#| label: aantal gemeten jaren per locatie
anlbsjs_cast[,jaar_char := as.character(jaar_sjs)]
anlbsjs_cast[,baggerensjs := ifelse(baggerensjs == 'baggeren', 1, 0)]
anlbsjs_cast[is.na(baggerensjs),baggerensjs := 0]
anlbsjs_cast[baggerenanlb == 2,baggerenanlb := 1]
anlbsjs_cast[,schonen := ifelse(schonen == 'schonen', 1, 0)]
anlbsjs_cast[is.na(schonen),schonen := 0]
anlbsjs_cast[slootschonen == 2,slootschonen := 1]
anlbsjs_cast[,nvo := ifelse(nvo == 'nvo', 1, 0)]
anlbsjs_cast[is.na(nvo),nvo := 0]
anlbsjs_cast[nat.vriend.oever == 2,nat.vriend.oever := 1]

# Maak een nieuwe variabele voor overeenkomst tussen SJS en ANLB
# Voor baggeren vergelijking
anlbsjs_cast[, baggeren_match := fifelse(
  baggerensjs == baggerenanlb, "Overeenkomst", 
  fifelse(baggerensjs != baggerenanlb, "Verschil", "Onbekend")
)]

# Voor schonen vergelijking
anlbsjs_cast[, schonen_match := fifelse(
  schonen == slootschonen, "Overeenkomst", 
  fifelse(schonen != slootschonen, "Verschil", "Onbekend")
)]

# Voor NVO vergelijking
anlbsjs_cast[, nvo_match := fifelse(
  nvo == nat.vriend.oever, "Overeenkomst", 
  fifelse(nvo != nat.vriend.oever, "Verschil", "Onbekend")
)]

# Voor meer subtiele groene kleuren uit het Okabe-Ito pallet
okabe_colors <- palette.colors(palette = "Okabe-Ito")

# Gebruik specifieke kleuren uit het Okabe-Ito pallet
p1 <- ggplot(data = anlbsjs_cast) +
  geom_bar(aes(x = as.factor(baggerensjs), fill = baggeren_match), 
           position = 'stack', stat = 'count') +
  facet_grid(. ~ jaar_char) +
  scale_x_discrete(labels = c('Geen', 'Wel')) +
  scale_fill_manual(values = c("Overeenkomst" = okabe_colors[4],    # Groene tint
                              "Verschil" = okabe_colors[7],         # Oranje/rode tint  
                              "Onbekend" = "gray50"),
                   labels = c("SJS = ANLB", "SJS ≠ ANLB", "Onbekend")) +
  guides(fill = guide_legend(title = 'SJS vs ANLB')) +
  labs(title = "Baggeren",
       x = "Wel of geen baggerpakket Sken je sloot", 
       y = "Aantal locaties") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold")
  )

# Voor p2 en p3 gebruik je dezelfde kleuren:
p2 <- ggplot(data = anlbsjs_cast) +
  geom_bar(aes(x = as.factor(schonen), fill = schonen_match), 
           position = 'stack', stat = 'count') +
  facet_grid(. ~ jaar_char) +
  scale_x_discrete(labels = c('Geen', 'Wel')) +
  scale_fill_manual(values = c("Overeenkomst" = okabe_colors[4],    
                              "Verschil" = okabe_colors[7],         
                              "Onbekend" = "gray50"),
                   labels = c("SJS = ANLB", "SJS ≠ ANLB", "Onbekend")) +
  guides(fill = guide_legend(title = 'SJS vs ANLB')) +
  labs(title = "Schonen",
       x = "Wel of geen pakket ecologisch schonen Sken je sloot", 
       y = "Aantal locaties") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold")
  )

p3 <- ggplot(data = anlbsjs_cast) +
  geom_bar(aes(x = as.factor(nvo), fill = nvo_match), 
           position = 'stack', stat = 'count') +
  facet_grid(. ~ jaar_char) +
  scale_x_discrete(labels = c('Geen', 'Wel')) +
  scale_fill_manual(values = c("Overeenkomst" = okabe_colors[4],    
                              "Verschil" = okabe_colors[7],         
                              "Onbekend" = "gray50"),
                   labels = c("SJS = ANLB", "SJS ≠ ANLB", "Onbekend")) +
  guides(fill = guide_legend(title = 'SJS vs ANLB NVO')) +
  labs(title = "Natuurvriendelijke oever",
       x = "Wel of geen natuurvriendelijke oever Sken je sloot", 
       y = "Aantal locaties") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold")
  )

# Print plots
print(p1)
print(p2) 
print(p3)

grid.arrange(p1, p2, p3, ncol = 1)

# Als je de kleuren wilt zien:
print(okabe_colors)

# Create overlap analysis
overlap_analysis <- anlbsjs_cast[, .(
  beide_baggeren = sum(baggerensjs == 1 & baggerenanlb == 1, na.rm = TRUE),
  alleen_sjs_baggeren = sum(baggerensjs == 1 & baggerenanlb == 0, na.rm = TRUE),
  alleen_anlb_baggeren = sum(baggerensjs == 0 & baggerenanlb == 1, na.rm = TRUE),
  beide_geen_baggeren = sum(baggerensjs == 0 & baggerenanlb == 0, na.rm = TRUE)
)]

print("Overlap analyse baggeren:")
print(overlap_analysis)
```

### Skenjesloot - locaties
```{r n jaren per loc}
#| label: aantal gemeten jaren per locatie
ggplot(data = skenjeslootloc)+
  geom_histogram(aes(x = nmeetjaar, fill = as.factor(jaar)), binwidth = 1) +
  guides(fill=guide_legend(title=''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Aantal gemeten jaren per locatie in (s)Ken je sloot") +
    labs(x="",y="aantal unieke monsters (metingen)")

```

### Skenjesloot - parameters

```{r overview skenjesloot}
#| label: overview sjs
# overzichttabel obv csv bestanden
ov_sjs <- dcast(skenjesloot, parameterid+naam+`vraag sken je sloot`+parameter+parameterfractie+eenheid~jaar)
fwrite(ov_sjs, file= paste0('skenjesloot_pars.csv'), sep = ';', dec ='.', )

# figuur metingen per pakket per jaar (csv) --------------

ggplot(data = skenjesloot[grepl('^BEHPK', parameterid),])+
  geom_bar(aes(x = naam, fill = as.factor(meetwaarde)), 
           position = 'stack') +
  coord_flip()+
  facet_wrap(~jaar)+
  scale_fill_discrete(labels = c('afwezig','aanwezig','onbekend'))+
  guides(fill=guide_legend(title=''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Beheerpakketten in (s)Ken je sloot") +
    labs(x="",y="aantal opnamen")

# figuur n pakket per jaar (csv) --------------
# & Code %in% c('2501-EAG-1','2501-EAG-2','2505-EAG-1','2502-EAG-1','2510-EAG-1'
colourCount = uniqueN(npakket[, 'V1'])
# getPalette = colorRampPalette(brewer.pal(8, "Set2"))
getPalette = colorRampPalette(palette.colors(palette = "Okabe-Ito"))
ggplot(data = npakket)+
  geom_bar(aes(x = jaar, fill = as.factor(V1)), 
           position = 'stack') +
  # coord_flip()+
  scale_fill_discrete(palette = getPalette(colourCount), labels = c('geen anlb','1 pakket','2 pakketten','3 pakketten','4 pakketten','5 pakketten','6 pakketten','7 pakketten'))+
  guides(fill=guide_legend(title=''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Beheerpakketten in (s)Ken je sloot") +
    labs(x="",y="aantal opnamen")

# figuur welke pakket per jaar (csv) --------------
ggplot(data = checknobs)+
  geom_col(aes(x = jaar, y = V1, fill = as.factor(beheer)), 
           position = 'dodge') +                            guides(fill=guide_legend(title='Type beheer'))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Beheerpakketten in (s)Ken je sloot") +
    labs(x="",y="aantal opnamen")
```

#### Emers 
```{r bedekking vs beheer}
#| label: bedekking emers by beheer
getPalette = palette.colors(palette = "Okabe-Ito")[-c(1, 9)]

ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameterid','parameter','jaar','beheer')]
ggplot(data = ss_beheer[parameterid == 'PTN_BEDKG_%'&
                          parameter =='EMSPTN' & n_obs > 9,])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = welnietbeheer), outliers = FALSE) +
  geom_text(aes(x = beheer, y=83, label = n_obs), size = 4)+
  scale_fill_discrete(palette = getPalette)+
  guides(fill=guide_legend(title='Aangepast beheer?'))+
  facet_wrap(jaar~., ncol = 2)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 90, hjust = 1, vjust = 0),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking emers") +
    labs(x="",y="%")+
  ylim(0,90)

ggsave(plot = last_plot(), filename = 'sjs_bedekking_emers_beheer.png', width = 50, height = 25, units = 'cm', dpi = 600)
```

Emerse bedekking is lager in sloten met een beheerpakket baggeren. In sloten met afrastering en natuurvriendelijke oevers is de bedekking emers juist hoger. Dit kan komen doordat afrastering begrazing beperkt, wat gunstig is voor de ontwikkeling van oever- en moerasvegetatie. In sloten met een beheerpakket schonen is de bedekking emers vergelijkbaar met sloten zonder beheerpakket.

```{r bedekking emers wel niet bagger per EAG}
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], Code+jaar~baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietbaggeren := `NA`]
ss_beheer_cast_2 <- dcast(ss_beheer[parameterid == 'WATERBTE_m' ,], Code+jaar~schonen, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast_2[, watbte_dif := schonen - `NA`]
ss_beheer_cast_2[watbte_dif < 0, watbte_dif := -1*watbte_dif]
ss_beheer_cast <- ss_beheer_cast[, nietschonen := `NA`]
ss_beheer_cast <- merge(ss_beheer_cast, ss_beheer_cast_2[, .(Code, jaar, watbte_dif)], by = c('Code', 'jaar'))


ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietbaggeren , y = baggeren)) +
  # scale_color_binned(type = 'viridis', name = 'Verschil waterbreedte (m)')+
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking emers - beheerpakket baggeren") +
    labs(x="bedekking op locaties zonder beheerpakket (%)",y="bedekking op locaties met beheerpakket baggeren (%)")
```

De bedekking emers is gemiddeld hoger in sloten zonder beheerpakket baggeren. Dit kan komen doordat baggeren de vegetatie (tijdelijk) verstoort. Zeker waarneer dit jaarlijks of meerdere keren per jaar gebeurt. In sloten met een beheerpakket baggeren is de bedekking emers in 2018 tot en met 2022 gemiddeld lager dan in 2023 en 2024. Mogelijk komt dit doordat in deze laatste jaren minder vaak is gebaggerd, of omdat er meer tijd is geweest voor herstel van de vegetatie na het baggeren.

```{r bedekking emers wel niet schonen per EAG}
#| label: bedekking analysis by EAG - emers by schonen

ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], Code+jaar~schonen+baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast_2 <- dcast(ss_beheer[parameterid == 'WATERBTE_m' ,], Code+jaar~schonen, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast_2[, watbte_dif := schonen_NA - `NA`]
ss_beheer_cast_2[watbte_dif < 0, watbte_dif := -1*watbte_dif]
ss_beheer_cast <- ss_beheer_cast[, nietschonen := `NA_NA`]
ss_beheer_cast <- ss_beheer_cast[, schonen := `schonen_NA`]
ss_beheer_cast <- merge(ss_beheer_cast, ss_beheer_cast_2[, .(Code, jaar, watbte_dif)], by = c('Code', 'jaar'))

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietschonen , y = schonen)) +
  # scale_color_binned(type = 'viridis', name = 'Verschil waterbreedte (m)')+
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking emers - beheerpakket schonen") +
    labs(x="bedekking op locaties zonder beheerpakket (%)",y="bedekking op locaties met beheerpakket (%)")

```

Er is geen duidelijk verschil in bedekking emers tussen sloten met en zonder beheerpakket schonen. Mogelijk komt dit doordat er in sloten met een beheerpakket soms vaker is geschoond dan in sloten zonder beheerpakket. Schoonmaken kan de vegetatie (tijdelijk) verstoren, ook als dit op ecologische wijze gebeurt. 

```{r bedekking emers wel niet afrastering per EAG}
#| label: bedekking analysis by EAG - emers by afrastering

ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], Code+jaar~afrastering, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietafrasteren := `NA`]
ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietafrasteren , y = afrastering)) +
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers - beheerpakket afrasteren") +
    labs(x="bedekking op locaties zonder beheerpakket (%)",y="bedekking op locaties met beheerpakket (%)")
```

Alleen in 2023 is duidelijk een hogere bedekking emers in sloten met een beheerpakket afrastering. Mogelijk komt dit doordat afrastering begrazing beperkt, wat gunstig is voor de ontwikkeling van oever- en moerasvegetatie. In andere jaren is dit effect niet duidelijk zichtbaar, mogelijk doordat er in deze jaren ook andere pakketten (met een tijdelijk negatief effect) zijn afgesloten op locaties waar afrastering stond.

```{r emers vs waterbreedt}
#| label: emers vs waterbreedte
ss_cast <- dcast(ss_beheer, externereferentie+id+jaar+welnietbeheer~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde')

# plot emers vs waterbreedte
ggplot(data = ss_cast[!is.na(`PTN_BEDKG_%_EMSPTN_`),])+
  geom_jitter(aes(x = WATERBTE_m_WATERBTE_, y = `PTN_BEDKG_%_EMSPTN_`, color = as.factor(jaar))) +
  geom_smooth(aes(x = WATERBTE_m_WATERBTE_, y = `PTN_BEDKG_%_EMSPTN_`), method = 'loess', color = 'black')+
  xlim(0,20)+
  # facet_wrap(welnietbeheer~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers vs waterbreedte") +
    labs(x="waterbreedte",y="bedekking emers (%)")


```

#### Submers

```{r submers bedekking by beheer}
#| label: submers bedekking by beheer

getPalette = palette.colors(palette = "Okabe-Ito")[-c(1, 9)]

ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameterid','parameter','jaar','beheer')]
ggplot(data = ss_beheer[parameterid == 'PTN_BEDKG_%'&
                          parameter =='SUBMSPTN' & n_obs > 9,])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = welnietbeheer), outliers = FALSE) +
  geom_text(aes(x = beheer, y=83, label = n_obs), size = 4)+
  scale_fill_discrete(palette = getPalette)+
  guides(fill=guide_legend(title='Aangepast beheer?'))+
  facet_wrap(jaar~., ncol = 2)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 90, hjust = 1, vjust = 0),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers") +
    labs(x="",y="%")+
  ylim(0,90)

ggsave(plot = last_plot(), filename = 'sjs_bedekking_emers_beheer.png', width = 50, height = 25, units = 'cm', dpi = 600)

```

```{r submers vs baggeren}
#| label:  plot submers vs aantal jaar baggeren
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameter','baggeren','PERODSLSBGODHD_a' )]
ggplot(data = ss_beheer[parameter == 'SUBMSPTN' ,])+
  geom_boxplot(aes(x = as.factor(PERODSLSBGODHD_a),
                   y = as.numeric(meetwaarde))) +
  geom_text(aes(x = as.factor(PERODSLSBGODHD_a),
                y=110, label = n_obs), size = 4)+
  guides(fill=guide_legend(title='Aangepast beheer?'))+
  facet_wrap(.~baggeren)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submers") +
    labs(x="",y="%")
```

```{r submers bedekking by eag schonen}
#| label: submerse bedekking by eag schonen

ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], Code+jaar~schonen+baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast_2 <- dcast(ss_beheer[parameterid == 'WATERBTE_m' ,], Code+jaar~schonen+baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast_2[, watbte_dif := schonen_NA - `NA_NA`]
ss_beheer_cast_2[watbte_dif < 0, watbte_dif := -1*watbte_dif]
ss_beheer_cast <- ss_beheer_cast[, nietschonen := `NA_NA`]
ss_beheer_cast <- ss_beheer_cast[, schonen := `schonen_NA`]
ss_beheer_cast <- merge(ss_beheer_cast, ss_beheer_cast_2[, .(Code, jaar, watbte_dif)], by = c('Code', 'jaar'))

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietschonen , y = schonen)) +
  # scale_color_binned(type = 'viridis', name = 'Verschil waterbreedte (m)')+
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers - beheerpakket ecologisch slootschonen") +
    labs(x="geen beheerpakket (%)",y="beheerpakket schonen (%)")
```

```{r}
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], Code+jaar~baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietbaggeren := `NA`]
ss_beheer_cast_2 <- dcast(ss_beheer[parameterid == 'WATERBTE_m' ,], Code+jaar~schonen, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast_2[, watbte_dif := schonen - `NA`]
ss_beheer_cast_2[watbte_dif < 0, watbte_dif := -1*watbte_dif]
ss_beheer_cast <- ss_beheer_cast[, nietschonen := `NA`]
ss_beheer_cast <- merge(ss_beheer_cast, ss_beheer_cast_2[, .(Code, jaar, watbte_dif)], by = c('Code', 'jaar'))


ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietbaggeren , y = baggeren)) +
  # scale_color_binned(type = 'viridis', name = 'Verschil waterbreedte (m)')+
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers - beheerpakket baggeren") +
    labs(x="bedekking op locaties zonder beheerpakket (%)",y="bedekking op locaties met beheerpakket baggeren (%)")
```

```{r submers vs doorzicht}
#| label: submers vs doorzicht
ss_cast <- dcast(ss_beheer, externereferentie+id+jaar+welnietbeheer~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde')
ss_cast[`PTN_BEDKG_%_SUBMSPTN_` > `PTN_BEDKG_%_DRAADALG_SUBMS`, `PTN_BEDKG_%_SUBMSPTN_`:= `PTN_BEDKG_%_SUBMSPTN_`-`PTN_BEDKG_%_DRAADALG_SUBMS`]
ss_cast[,zichtdte := ZICHT_m_ZICHT_/ WATDTE_m_WATDTE_]

palette <- palette.colors(palette = "Okabe-Ito", n = unique(ss_cast$jaar))
# plot submers vs doorzicht
ggplot(data = ss_cast[!is.na(`PTN_BEDKG_%_SUBMSPTN_`) & !is.na(ZICHT_m_ZICHT_) & WATDTE_m_WATDTE_ ,])+
  geom_jitter(aes(x = zichtdte, y = `PTN_BEDKG_%_SUBMSPTN_`, color = as.factor(jaar))) +
  geom_smooth(aes(x = zichtdte, y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'lm', color = 'black')+
  scale_color_manual(values = palette, name = 'Jaar')+
  # facet_wrap(welnietbeheer~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers vs doorzicht") +
    labs(x="doorzicht/waterdiepte",y="bedekking submers (%)")


```

Submerse vegetatie bedekking heeft geen duidelijke relatie met de frequentie van baggeren. Er worden lagere bedekkingen gemeten op locaties waar lange tijd (> 3 jaar) niet is gebaggerd. Wel is er een negatieve relatie met doorzicht (zie figuur hierboven). Dit betekent dat bij helder water de bedekking lager is. Dit is niet in lijn met de verwachting dat bij helder water de groeiomstandigheden beter zijn (meer lichtinval).

```{r submers vs waterdiepte}
#| label: submers vs waterdiepte
ss_cast <- dcast(ss_beheer, externereferentie+id+jaar+welnietbeheer~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde')
ss_cast[`PTN_BEDKG_%_SUBMSPTN_` > `PTN_BEDKG_%_DRAADALG_SUBMS`, `PTN_BEDKG_%_SUBMSPTN_`:= `PTN_BEDKG_%_SUBMSPTN_`-`PTN_BEDKG_%_DRAADALG_SUBMS`]
ss_cast[,zichtdte := ZICHT_m_ZICHT_/ WATDTE_m_WATDTE_]

palette <- palette.colors(palette = "Okabe-Ito", n = unique(ss_cast$jaar))
# plot submers vs doorzicht
ggplot(data = ss_cast[!is.na(`PTN_BEDKG_%_SUBMSPTN_`) & !is.na(ZICHT_m_ZICHT_) & WATDTE_m_WATDTE_ ,])+
  geom_jitter(aes(x = WATDTE_m_WATDTE_, y = `PTN_BEDKG_%_SUBMSPTN_`, color = as.factor(jaar))) +
  geom_smooth(aes(x = WATDTE_m_WATDTE_, y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'loess', color = 'black')+
  scale_color_manual(values = palette, name = 'Jaar')+
  xlim(0,1.5)+
  # facet_wrap(welnietbeheer~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers vs waterdiepte") +
    labs(x="waterdiepte",y="bedekking submers (%)")


```



#### Kroos

```{r kroos vis}
#| label: kroos by beheer
## per pakket 
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameterid','parameter','jaar','beheer' )]
ggplot(data = ss_beheer[parameter == 'KROOS',])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde),
                   fill = welnietbeheer)) +
  geom_text(aes(x = beheer, y=110, label = n_obs), 
            size = 2)+
  guides(fill=guide_legend(title='Aangepast beheer?'))+
  # facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 90, 
                                 hjust = 1, vjust = 0),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking kroos") +
    labs(x="",y="%")
  # ylim(0,15)
```

```{r kroos by eag}
  # kroos bedekking by eag---------------
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='KROOS',], Code+jaar~welnietbeheer, value.var = 'meetwaarde', fun.aggregate = mean)
ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee, y = ja)) +
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking kroos") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren en/of schonen (%)")
```

#### Frequentie baggeren

```{r}
#| label:  baggerfrequentie 
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameter','baggeren','PERODSLSBGODHD_a' )]
ggplot(data = ss_beheer[parameterid == 'BAGGEREN5JAAR' ,])+
  geom_boxplot(aes(x = as.factor(PERODSLSBGODHD_a), y = as.numeric(meetwaarde))) +
  geom_text(aes(x = as.factor(PERODSLSBGODHD_a), y=0, label = n_obs))+
  facet_wrap(.~baggeren)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Frequentie baggeren") +
    labs(x="",y="%")
# ylim(0,15)

```

#### Doorzicht en waterdiepte

```{r watdte vs doorzicht}
#| label: submers vs doorzicht
ss_cast <- dcast(ss_beheer, externereferentie+id+jaar+welnietbeheer~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde')
ss_cast[`PTN_BEDKG_%_SUBMSPTN_` > `PTN_BEDKG_%_FLAB_SUBMS`, `PTN_BEDKG_%_SUBMSPTN_`:= `PTN_BEDKG_%_SUBMSPTN_`-`PTN_BEDKG_%_FLAB_SUBMS`]
ss_cast[,zichtdte := ZICHT_m_ZICHT_/ WATDTE_m_WATDTE_]

# plot submers vs doorzicht
ggplot(data = ss_cast[!is.na(zichtdte),])+
  geom_jitter(aes(x = WATDTE_m_WATDTE_, y = ZICHT_m_ZICHT_, color = as.factor(jaar))) +
  geom_smooth(aes(x = WATDTE_m_WATDTE_, y = ZICHT_m_ZICHT_), method = 'lm', color = 'black')+
  facet_wrap(welnietbeheer~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Waterdiepte vs doorzicht") +
    labs(x="waterdiepte",y="doorzicht (m)")


```

De doorzicht/waterdiepte ratio is hoger in sloten met beheerpakket. 

```{r}
#| label: boxplots all parameters by beheer
ggplot()+
  geom_boxplot(data = ss_beheer[parameterid == "TALBVWTR_SOORT"  ], aes(x = beheer, y = meetwaarde))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Taludhoek") +
    labs(x="",y="taludhoek")

ggplot()+
  geom_boxplot(data = ss_beheer[parameterid == "WATDTE_m" ,], aes(x = beheer, y = meetwaarde))+ ylim(0,1)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Waterdiepte") +
    labs(x="",y="waterdiepte (m)")

ggplot()+
  geom_boxplot(data = ss_beheer[parameterid == "ZICHT_m" ,], aes(x = beheer, y = meetwaarde))+ ylim(0,1)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Doorzicht") +
    labs(x="",y="doorzicht (m)")


```

## XG-boost analyse

```{r xgboost setup }
#| label: xgboost

anlbhybi_cast <- anlbhybi_bod
anlbhybi_cast[,pvskp := P_tot/Pkrit1] #3417 rows

# Prepare data for xgboost using data.table syntax
model_data_xgb <- anlbhybi_cast[
  # Filter out rows with missing target variable
  !is.na(`PTN_BEDKG_%_SUBMSPTN_`) 
][
  # Select relevant columns
  , .(
    # Target variable
    submers_bedekking = `PTN_BEDKG_%_SUBMSPTN_`,
    emers_bedekking = `PTN_BEDKG_%_EMSPTN_`,
    submers_soorten = n_soort_sub,
    emers_soorten = n_soort_ems,
    
    # Management features
    anlb,
    njaaranlb,
    # beheer,
    baggeren,
    slootschonen,
    water,
    bufferzone,
    pakket_n_anlb,
    
    # Environmental features
    # watertype,
    WATDTE_m_WATDTE_,
    WATERBTE_m_WATERBTE_,
    SLIBDTE_m_SLIBDTE_,
    zichtdte,
    TALBVWTR_graad_TALBVWTR_,
    # rel_water,
    A_P_AL,
    A_SOM_LOI,
    # Ptot_mgP_l_nf_PW,
    # NH4_mgN_l_nf_PW,
    P_tot,
    `mm/d`,
    pvskp,

    # Other coverage variables
    `PTN_BEDKG_%_FLAB_`,
    `PTN_BEDKG_%_KROOS_`,
    
    # Location identifier
    EAGIDENT,
    locatie,
    compartiment,
    jaar
  )
] # 2938 rows

# Remove rows with any missing values in a separate step
# model_data_xgb[complete.cases(model_data_xgb), complete := 1]
# setDT(hybiloc)
# model_data_loc_check <- merge(model_data_xgb, hybiloc, by = "locatie", all.x = TRUE)
# model_data_loc_check_hybi <- st_as_sf(model_data_loc_check)
# st_write(model_data_loc_check, "model_data_loc_check.gpkg", delete_dsn = TRUE)
model_data_xgb <- model_data_xgb[complete.cases(model_data_xgb),] 
# 2900 = alles, 2774 = met watbal, 2499 = met bodemschat, 2382 = met bodemschat en watbal, 1435 inclusief waterbodem, belasting en bodschat

# Convert factors to numeric for xgboost
factor_cols <- names(model_data_xgb)[sapply(model_data_xgb, is.character)]
model_data_xgb[, (factor_cols) := lapply(.SD, as.factor), .SDcols = factor_cols]
model_data_xgb[, (factor_cols) := lapply(.SD, as.numeric), .SDcols = factor_cols]

```


```{r correlatie check}
#| label: xgboost parameters check

# Check correlation between features
feature_cols <- setdiff(names(model_data_xgb), c("submers_bedekking", "emers_bedekking", "compartiment","submers_soorten", "emers_soorten",
                                                  "PTN_BEDKG_%_FLAB_", "locatie", "EAGIDENT", "anlb"))
cor_matrix <- model_data_xgb[, ..feature_cols]
# Remove rows with NA values
cor_matrix <- na.omit(cor_matrix)
# Calculate correlation matrix
cor_matrix <- cor(cor_matrix, use = "pairwise.complete.obs")

# Create correlation plot
corrplot(cor_matrix, 
         method = "color",       # Color squares
         type = "upper",         # Only show upper triangle
         order = "hclust",       # Order by hierarchical clustering
         tl.col = "black",       # Label color
         tl.srt = 45,            # Label rotation
         tl.cex = 0.7,           # Label size
         addCoef.col = "black",  # Add correlation coefficients
         number.cex = 0.6,       # Coefficient text size
         col = colorRampPalette(c("#6D9EC1", "white", "#E46726"))(200)) # Blue-white-orange color scheme

# Or alternatively, use ggcorrplot for a ggplot-based solution
if (!require(ggcorrplot)) install.packages("ggcorrplot") 
library(ggcorrplot)

ggcorrplot(cor_matrix, 
           hc.order = TRUE,      # Hierarchical clustering
           type = "upper",       # Show only upper triangle
           lab = TRUE,           # Add correlation coefficients
           lab_size = 3,         # Size of text labels
           tl.cex = 8,           # Text label size
           title = "Correlation Plot of Environmental and Vegetation Variables",
           ggtheme = ggplot2::theme_minimal())


```


```{r xgboost target loop}

# Optie 1: Train afzonderlijke modellen voor elke doelvariabele
target_variables <- c("submers_bedekking", "emers_bedekking", "submers_soorten", "emers_soorten")

models <- list()
predictions_all <- list()
rsme_all <- list()

for(target_var in target_variables) {
  cat("Training model for:", target_var, "\n")
  
  # Selecteer target
  target <- model_data_xgb[[target_var]]
  
  # Verwijder alle target variabelen uit features
  features <- model_data_xgb[, !c("submers_bedekking", "emers_bedekking", 
                                  "emers_soorten", "submers_soorten",
                                  "PTN_BEDKG_%_FLAB_", "locatie", "EAGIDENT", "anlb")]
  
  # Train/test split (gebruik dezelfde split voor vergelijkbaarheid)
  set.seed(123)
  train_idx <- sample(nrow(features), 0.8 * nrow(features))
  
  train_x <- as.matrix(features[train_idx])
  train_y <- target[train_idx]
  test_x <- as.matrix(features[-train_idx])
  test_y <- target[-train_idx]
  
  # Train model
  dtrain <- xgb.DMatrix(data = train_x, label = train_y)
  dtest <- xgb.DMatrix(data = test_x, label = test_y)
  
  xgb_model <- xgb.train(
    params = params,
    data = dtrain,
    nrounds = 1000,
    watchlist = list(train = dtrain, test = dtest),
    early_stopping_rounds = 50,
    verbose = 0
  )
  
  # Bewaar model en predictions
  models[[target_var]] <- xgb_model
  predictions <- predict(xgb_model, dtest)
  predictions_all[[target_var]] <- predictions
  
  # Calculate RMSE
  rmse <- sqrt(mean((test_y - predictions)^2))
  rsme_all[[target_var]] <- rmse
  cat("RMSE voor", target_var, ":", round(rmse, 3), "\n\n")
  
  # Variable importance
  print(paste("Variable importance voor", target_var))
  print(vip(xgb_model, num_features = 10))
}

```


```{r vip plots}
#| label: Complete VIP Plot Creation for All Target Variables

# Bereken de variatie/schaal van elke target variabele om RMSE als percentage uit te drukken
calculate_rmse_percentage <- function(models, target_variables, data) {
  rmse_percentages <- list()
  
  for (target_var in target_variables) {
    # Haal de target waarden op
    target_values <- data[[target_var]]
    
    # Bereken statistieken
    target_range <- max(target_values, na.rm = TRUE) - min(target_values, na.rm = TRUE)
    target_mean <- mean(target_values, na.rm = TRUE)
    target_sd <- sd(target_values, na.rm = TRUE)
    
    # RMSE
    rmse <- rsme_all[[target_var]]
    
    # Bereken percentages
    rmse_pct_range <- (rmse / target_range) * 100  # Percentage van bereik
    rmse_pct_mean <- (rmse / target_mean) * 100    # Percentage van gemiddelde
    rmse_pct_sd <- (rmse / target_sd) * 100        # Percentage van standaarddeviatie
    
    # Sla resultaten op
    rmse_percentages[[target_var]] <- list(
      rmse = rmse,
      range = target_range,
      mean = target_mean,
      sd = target_sd,
      rmse_pct_range = rmse_pct_range,
      rmse_pct_mean = rmse_pct_mean,
      rmse_pct_sd = rmse_pct_sd
    )
    
    # Print samenvatting
    cat("Target:", target_var, "\n")
    cat("  Range:", round(target_range, 2), "\n")
    cat("  Mean:", round(target_mean, 2), "\n")
    cat("  RMSE:", round(rmse, 3), "\n")
    cat("  RMSE as % of range:", round(rmse_pct_range, 1), "%\n")
    cat("  RMSE as % of mean:", round(rmse_pct_mean, 1), "%\n\n")
  }
  
  return(rmse_percentages)
}

# Bereken RMSE percentages
rmse_stats <- calculate_rmse_percentage(models, target_variables, model_data_xgb)

# Aangepaste VIP functie met RMSE percentage
create_multiple_vip_grids_with_pct <- function(models, target_variables, rmse_stats, num_features = 10) {
  
  # Target variable mapping for readable names
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Variable mapping for readable names
  var_mapping <- list(
    "njaaranlb" = "Aantal jaren ANLB",
    "beheer" = "Beheertype",
    "baggeren" = "Baggeren",
    "slootschonen" = "Slootschonen", 
    "water" = "Water pakket",
    "bufferzone" = "Bufferzone",
    "pakket_n_anlb" = "Aantal ANLB pakketten",
    "watertype" = "Watertype",
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)",
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "rel_water" = "Fractie open water (%)",
    "A_P_AL" = "P-AL (mg/kg)",
    "A_SOM_LOI" = "Organische stof (%)",
    "Ptot_mgP_l_nf_PW" = "P-totaal poriewater (mg/l)",
    "NH4_mgN_l_nf_PW" = "NH4 poriewater (mg/l)",
    "P_tot" = "P-belasting (mg/m2/dag)",
    "mm/d" = "Verblijftijd (mm/dag)",
    "PTN_BEDKG_%_FLAB_" = "Flabbedekking (%)",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "compartiment" = "Compartiment",
    "jaar" = "Jaar"
  )
  
  # Store all VIP plots
  vip_plots <- list()
  
  # Create VIP plot for each target variable
  for (target_var in target_variables) {
    cat("Creating VIP plot for target:", target_var, "\n")
    
    model <- models[[target_var]]
    stats <- rmse_stats[[target_var]]
    
    # Get variable importance DATA
    importance_data <- vip::vi(model)
    
    # Map variable names to readable names
    importance_data$Variable_readable <- sapply(importance_data$Variable, function(x) {
      if (x %in% names(var_mapping)) {
        return(var_mapping[[x]])
      } else {
        return(x)
      }
    })
    
    # Create subtitle with RMSE and percentage
    subtitle_text <- paste0(
      "RMSE: ", round(stats$rmse, 3),
      " (", round(stats$rmse_pct_range, 1), "% van bereik, ",
      round(stats$rmse_pct_mean, 1), "% van gemiddelde)"
    )
    
    # Create VIP plot with enhanced RMSE information
    p <- ggplot(importance_data, aes(x = reorder(Variable_readable, Importance), 
                                   y = Importance)) +
      geom_col(fill = "steelblue", alpha = 0.8) +
      coord_flip() +
      labs(
        title = paste("Variable Importance:", target_mapping[[target_var]]),
        subtitle = subtitle_text,
        x = "Variabelen",
        y = "Importance (Gain)"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 10, color = "darkred"),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        axis.text.y = element_text(size = 9),
        panel.grid.minor = element_blank()
      )
    
    vip_plots[[target_var]] <- p
    print(p)
  }
  
  # Create combined grid plot
  if (length(vip_plots) > 0) {
    cat("Creating combined VIP grid...\n")
    
    combined_vip_grid <- gridExtra::grid.arrange(
      grobs = vip_plots,
      ncol = 2,
      top = "Variable Importance Comparison - All Target Variables (RMSE with Context)"
    )
    
    print(combined_vip_grid)
  }
  
  return(vip_plots)
}

# Main execution
# ==============
vip_results_with_pct <- create_multiple_vip_grids_with_pct(
  models = models,
  target_variables = target_variables,
  rmse_stats = rmse_stats,
  num_features = 12
)


# Print summary
cat("\n=== VIP ANALYSIS SAMENVATTING ===\n")
cat("Aantal VIP plots gemaakt:", length(vip_results), "\n")
cat("Target variabelen geanalyseerd:", paste(names(vip_results), collapse = ", "), "\n")
cat("Grid layouts gemaakt: Overall, Bedekking, Soorten\n")


```


De waterbreedte is de belangrijkste voorspeller voor emerse bedekking. Daarnaast zijn de variabelen die het water beïnvloeden (doorzicht, waterdiepte, taludhoek) ook belangrijk. Beheer gerelateerde variabelen zoals aantal jaren anlb en baggeren zijn minder belangrijk.
Ook bij sumberse vegetatie is de waterbreedte een belangrijke voorspeller. Daarnaast zijn de variabelen die het water beïnvloeden (doorzicht, waterdiepte, taludhoek) ook belangrijk. Beheer gerelateerde variabelen zoals aantal jaren anlb en baggeren zijn minder belangrijk.

Waterdiepte en zichtdiepte zijn belangrijker bij het voorspellen van sumberse dan emerse bedekking.

```{r ale plots}
#| label: Complete ALE Plot Creation for All Target Variables
# ===================================================

# Define function to create ALE plots manually
create_ale_plot <- function(model, data, feature, num_intervals = 40) {
  # Sort the data by the feature
  data_sorted <- data[order(data[, feature]), ]
  x_sorted <- data_sorted[, feature]
  
  # Create intervals
  n <- length(x_sorted)
  interval_size <- max(1, floor(n / num_intervals))
  intervals <- seq(1, n, by = interval_size)
  if (intervals[length(intervals)] < n) intervals <- c(intervals, n)
  
  # Initialize results
  ale_values <- numeric(length(intervals) - 1)
  x_values <- numeric(length(intervals) - 1)
  
  # Calculate ALE for each interval
  for (i in 1:(length(intervals) - 1)) {
    start_idx <- intervals[i]
    end_idx <- intervals[i+1]
    
    # Get data in this interval
    x_interval <- x_sorted[start_idx:end_idx]
    data_interval <- data_sorted[start_idx:end_idx, , drop = FALSE]
    
    # Calculate mean feature value for this interval
    x_values[i] <- mean(x_interval)
    
    # Create two datasets: one with min value and one with max value
    data_min <- data_interval
    data_max <- data_interval
    data_min[, feature] <- min(x_interval)
    data_max[, feature] <- max(x_interval)
    
    # Predict with both datasets
    pred_min <- predict(model, as.matrix(data_min))
    pred_max <- predict(model, as.matrix(data_max))
    
    # Calculate average difference
    ale_values[i] <- mean(pred_max - pred_min)
  }
  
  # Cumulative sum to get ALE
  ale_cumsum <- cumsum(ale_values)
  
  # Center ALE to have mean of 0
  ale_cumsum <- ale_cumsum - mean(ale_cumsum)
  
  # Return results
  return(data.frame(x = x_values, ale = ale_cumsum))
}

# Function to create ALE plots for all target variables
create_ale_plots_all_targets <- function(models, train_data, target_variables) {
  
  # Define continuous variables for ALE plots
  continuous_vars <- c(
    "WATDTE_m_WATDTE_", "WATERBTE_m_WATERBTE_", "SLIBDTE_m_SLIBDTE_",
    "zichtdte","A_P_AL","A_SOM_LOI","NH4_mgN_l_nf_PW","Ptot_mgP_l_nf_PW","P_tot","mm/d","TALBVWTR_graad_TALBVWTR_", "PTN_BEDKG_%_KROOS_", "jaar","pvskp" 
  )
  
  # Variable mapping for readable names
  var_mapping <- list(
    "njaaranlb" = "Aantal jaren ANLB",
    "beheer" = "Beheertype",
    "baggeren" = "Baggeren",
    "slootschonen" = "Slootschonen", 
    "water" = "Water pakket",
    "bufferzone" = "Bufferzone",
    "pakket_n_anlb" = "Aantal ANLB pakketten",
    "watertype" = "Watertype",
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)",
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "rel_water" = "Fractie open water (%)",
    "A_P_AL" = "P-AL (mg/kg)",
    "A_SOM_LOI" = "Organische stof (%)",
    "Ptot_mgP_l_nf_PW" = "P-totaal poriewater (mg/l)",
    "NH4_mgN_l_nf_PW" = "NH4 poriewater (mg/l)",
    "P_tot" = "P-belasting (mg/m2/dag)",
    "mm/d" = "Verblijftijd (mm/dag)",
    "PTN_BEDKG_%_FLAB_" = "Flabbedekking (%)",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "compartiment" = "Compartiment",
    "jaar" = "Jaar",
    "pvskp" = "P belasting / Kritische P belasting"
  )
  
  # Target variable mapping for readable names
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Verify which variables exist in training data
  valid_vars <- intersect(continuous_vars, colnames(train_data))
  
  # Store all ALE plots
  all_ale_plots <- list()
  
  # Loop through each target variable
  for (target_var in target_variables) {
    cat("Creating ALE plots for target:", target_var, "\n")
    
    model <- models[[target_var]]
    target_plots <- list()
    
    # Create ALE plots for each continuous variable
    for (var in valid_vars) {
      cat("  Creating ALE plot for:", var, "\n")
      
      # Calculate ALE values
      ale_data <- create_ale_plot(model, train_data, var)
      
      # Add annotations for effect values
      max_effect <- max(abs(ale_data$ale))
      effect_points <- seq(1, nrow(ale_data), length.out = 5)
      effect_points <- round(effect_points)
      effect_points <- unique(effect_points)
      
      # Create plot with target-specific labeling
      p <- ggplot(ale_data, aes(x = x, y = ale)) +
        geom_line(linewidth = 1.2, color = "steelblue") +
        geom_rug(sides = "b", alpha = 0.2) +
        geom_point(data = ale_data[effect_points,], aes(x = x, y = ale), 
                   color = "red", size = 2) +
        geom_text(data = ale_data[effect_points,], 
                  aes(x = x, y = ale, 
                      label = sprintf("%.1f", ale)),
                  vjust = -1.5, size = 3) +
        labs(
          title = paste("Effect van", var_mapping[[var]], "op", target_mapping[[target_var]]),
          x = var_mapping[[var]],
          y = paste("Effect op", target_mapping[[target_var]])
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, face = "bold"),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.minor = element_blank()
        )
      
      target_plots[[var]] <- p
      print(p)
    }
    
    # Store plots for this target
    all_ale_plots[[target_var]] <- target_plots
    
    # Create combined plot grid for this target
    if (length(target_plots) > 0) {
      if (requireNamespace("gridExtra", quietly = TRUE)) {
        grid_plot <- gridExtra::grid.arrange(
          grobs = target_plots, 
          ncol = 2,
          top = paste("ALE Plots voor", target_mapping[[target_var]])
        )
        print(grid_plot)
      }
    }
    
    cat("\n")
  }
  
  return(all_ale_plots)
}

# Function to create comparison plots across targets
create_comparison_ale_plots <- function(all_ale_plots, var_to_compare) {
  comparison_plots <- list()
  
  for (target in names(all_ale_plots)) {
    if (var_to_compare %in% names(all_ale_plots[[target]])) {
      plot <- all_ale_plots[[target]][[var_to_compare]] +
        labs(title = paste(target, "-", var_to_compare)) +
        theme(plot.title = element_text(size = 12))
      
      comparison_plots[[target]] <- plot
    }
  }
  
  if (length(comparison_plots) > 0) {
    grid_plot <- gridExtra::grid.arrange(
      grobs = comparison_plots,
      ncol = 2,
      top = paste("Vergelijking ALE plots voor", var_to_compare)
    )
    print(grid_plot)
  }
  
  return(comparison_plots)
}

# Function to summarize ALE effects
summarize_ale_effects <- function(all_ale_plots) {
  cat("=== ALE PLOT SAMENVATTING ===\n\n")
  
  for (target in names(all_ale_plots)) {
    cat("Target variabele:", target, "\n")
    cat("Aantal ALE plots gemaakt:", length(all_ale_plots[[target]]), "\n")
    cat("Variabelen geanalyseerd:", paste(names(all_ale_plots[[target]]), collapse = ", "), "\n")
    cat("\n")
  }
}

# Main execution
# ==============

# Define target variables
target_variables <- c("submers_bedekking", "emers_bedekking", "submers_soorten", "emers_soorten")

# Create ALE plots for all targets (assuming models and train_x are already available)
all_ale_plots <- create_ale_plots_all_targets(
  models = models,
  train_data = as.data.frame(train_x),
  target_variables = target_variables
)

# Create comparison plots for specific variables across all targets
cat("Creating comparison plots...\n")

# Example: Compare waterbreedte effects across all targets
waterbreedte_comparison <- create_comparison_ale_plots(all_ale_plots, "WATERBTE_m_WATERBTE_")
# Example: Compare waterdiepte effects across all targets  
waterdiepte_comparison <- create_comparison_ale_plots(all_ale_plots, "WATDTE_m_WATDTE_")
# Example: Compare kroos effects across all targets
kroos_comparison <- create_comparison_ale_plots(all_ale_plots, "PTN_BEDKG_%_KROOS_")
# Example: Compare P-AL effects across all targets
p_al_comparison <- create_comparison_ale_plots(all_ale_plots, "A_P_AL")
# Example: Compare P-totaal effects across all targets
ptotaal_comparison <- create_comparison_ale_plots(all_ale_plots, "P_tot")
# Example: Compare Taludhelling effects across all targets
talud_comparison <- create_comparison_ale_plots(all_ale_plots, "TALBVWTR_graad_TALBVWTR_")
# Example: Compare zichtdte effects across all targets
zichtdte_comparison <- create_comparison_ale_plots(all_ale_plots, "zichtdte")
# Example: Compare mm/d effects across all targets
mm_d_comparison <- create_comparison_ale_plots(all_ale_plots, "mm/d")
# Example: Compare NH4 effects across all targets
nh4_comparison <- create_comparison_ale_plots(all_ale_plots, "NH4_mgN_l_nf_PW")
#Example: Compare P-totaal poriewater effects across all targets
ptotaal_pw_comparison <- create_comparison_ale_plots(all_ale_plots, "Ptot_mgP_l_nf_PW")
# Example: Compare fractie water effects across all targets
rel_water_comparison <- create_comparison_ale_plots(all_ale_plots, "rel_water")
# Example: Compare organisch stof effects across all targets
org_stof_comparison <- create_comparison_ale_plots(all_ale_plots, "A_SOM_LOI")
# Example: Compare pvskp effects across all targets
pvskp_comparison <- create_comparison_ale_plots(all_ale_plots, "pvskp")

# Show summary of all ALE plots created
summarize_ale_effects(all_ale_plots)

cat("ALE plots creation completed for all target variables!\n")
```

```{r ale plots versie 2}

create_ale_plots_top10_variables <- function(models, train_data, target_variables) {
  
  # Functie om top 10 variabelen te bepalen voor elk model
  get_top10_variables <- function(model) {
    # Bereken variabele-belangrijkheid
    importance <- xgboost::xgb.importance(model = model)
    
    # Sorteer op belangrijkheid en neem top 10
    top10 <- head(importance$Feature, 10)
    return(top10)
  }
  
  # Variabele mapping voor leesbare namen
  var_mapping <- list(
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)", 
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "jaar" = "Jaar",
    "pvskp" = "P belasting / Kritische P belasting",
    "A_P_AL" = "P-AL bodem",
    "P_tot" = "P-belasting (mg/m2/dag)",
    "mm/d" = "Hydraulisch debiet (mm/dag)",	
    "rel_water" = "Percentage open water",
    "P_PO4" = "Fosfaat (PO4)",
    "Ntot" = "Totaal stikstof",
    "NH4" = "Ammonium",
    "A_SOM_LOI" = "Organische stof (%)",
    "njaaranlb" = "Aantal jaren ANLb",
    "baggeren" = "Baggeren",
    "slootschonen" = "Slootschonen",
    "water" = "Water beheer",
    "bufferzone" = "Bufferzone",
    "pakket_n_anlb" = "Aantal ANLb pakketten"
  )
  
  # Target variabele mapping voor leesbare namen
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Sla alle ALE plots op
  all_ale_plots <- list()
  
  # Loop door elke doelvariabele
  for (target_var in target_variables) {
    cat("ALE plots maken voor:", target_var, "\n")
    
    model <- models[[target_var]]
    target_plots <- list()
    
    # Bepaal top 10 belangrijkste variabelen voor dit model
    top10_vars <- get_top10_variables(model)
    cat("Top 10 belangrijkste variabelen voor", target_var, ":", paste(top10_vars, collapse=", "), "\n")
    
    # Maak ALE plots voor elke top-10 variabele
    for (var in top10_vars) {
      cat("  ALE plot maken voor:", var, "\n")
      
      # Controleer of de variabele bestaat in de trainingsdata
      if(!(var %in% colnames(train_data))) {
        cat("  Waarschuwing: variabele", var, "niet gevonden in trainingsdata, wordt overgeslagen\n")
        next
      }
      
      # Bereken ALE waarden
      ale_data <- create_ale_plot(model, train_data, var)
      
      # Selecteer punten voor labels (gelijkmatig verdeeld)
      num_points <- min(5, nrow(ale_data))  # Maximum 5 punten voor labels
      point_indices <- round(seq(1, nrow(ale_data), length.out = num_points))
      label_data <- ale_data[point_indices, ]
      
      # Bepaal de leesbare naam voor de variabele
      var_label <- if(var %in% names(var_mapping)) var_mapping[[var]] else var
      
      # Maak plot met doelvariabele-specifieke labels
      p <- ggplot(ale_data, aes(x = x, y = ale)) +
        # Voeg een lijn toe
        geom_line(linewidth = 1.2, color = "steelblue", alpha = 0.8) +
        # Voeg de rug (rode datapunten) onderaan toe
        geom_rug(sides = "b", alpha = 0.7, color = "red", size = 1) +
        # Voeg effect-waarde stippen toe
        geom_point(data = label_data, aes(x = x, y = ale), 
                  color = "red", size = 3) +
        # Voeg labels toe voor de effect-waarden
        geom_text(data = label_data, 
                 aes(x = x, y = ale, label = sprintf("%.1f", ale)),
                 vjust = -0.8, hjust = 0.5, size = 3.5) +
        labs(
          title = paste("Effect van", var_label),
          x = var_label,
          y = NULL
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 12, face = "bold"),
          axis.title.x = element_text(size = 10),
          axis.title.y = element_blank(),
          axis.text = element_text(size = 9),
          panel.grid.minor = element_blank()
        )
      
      target_plots[[var]] <- p
    }
    
    # Sla plots op voor deze doelvariabele
    all_ale_plots[[target_var]] <- target_plots
    
    # Maak een gecombineerde plot grid voor deze doelvariabele
    if (length(target_plots) > 0) {
      # Voeg één gemeenschappelijke titel toe voor de hele groep plots
      grid_title <- paste("ALE Plots voor", target_mapping[[target_var]])
      
      # Voeg een gemeenschappelijke y-as label toe (één keer voor alle plots)
      grid_plot <- gridExtra::grid.arrange(
        gridExtra::arrangeGrob(
          grobs = target_plots,
          ncol = 2,
          left = grid::textGrob("Effect op afhankelijke variabele", rot = 90, gp = grid::gpar(fontsize = 12))
        ),
        top = grid::textGrob(grid_title, gp = grid::gpar(fontsize = 14, fontface = "bold"))
      )
      print(grid_plot)
    }
  }
  
  return(all_ale_plots)
}

# Gebruik de nieuwe functie om ALE plots te maken voor de top 10 variabelen
top10_ale_plots <- create_ale_plots_top10_variables(
  models = models,
  train_data = as.data.frame(train_x),
  target_variables = target_variables
)
```


```{r pdp plots}
#| label: Complete PDP Plot Creation for All Target Variables
# Function to create PDP plots for all target variables with variable mapping
create_pdp_plots_all_targets <- function(models, train_data, target_variables) {
  
  # Define continuous variables for plots
  continuous_vars <- c(
    "WATDTE_m_WATDTE_", "WATERBTE_m_WATERBTE_", "SLIBDTE_m_SLIBDTE_",
    "zichtdte", "TALBVWTR_graad_TALBVWTR_", "PTN_BEDKG_%_KROOS_", "jaar"
  )
  
  # Variable mapping for readable names
  var_mapping <- list(
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)", 
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "jaar" = "Jaar"
  )
  
  # Target variable mapping for readable names
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Verify which variables exist in training data
  valid_vars <- intersect(continuous_vars, colnames(train_data))
  
  # Store all PDP plots
  all_pdp_plots <- list()
  
  # Loop through each target variable
  for (target_var in target_variables) {
    cat("Creating PDP plots for target:", target_var, "\n")
    
    model <- models[[target_var]]
    target_plots <- list()
    
    # Create PDP plots for each continuous variable
    for (var in valid_vars) {
      cat("  Creating PDP plot for:", var, "\n")
      
      # Create partial dependence plot
      pd <- partial(model, pred.var = var, train = as.data.frame(train_data))
      
      # Create plot with target-specific labeling
      p <- autoplot(pd) +
        labs(
          title = paste("Effect van", var_mapping[[var]], "op", target_mapping[[target_var]]),
          subtitle = "Partial Dependence Plot",
          x = var_mapping[[var]],
          y = paste("Effect op", target_mapping[[target_var]])
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, face = "bold"),
          plot.subtitle = element_text(size = 12, color = "darkred"),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.minor = element_blank()
        )
      
      target_plots[[var]] <- p
      print(p)
    }
    
    # Store plots for this target
    all_pdp_plots[[target_var]] <- target_plots
    
    # Create combined plot grid for this target
    if (length(target_plots) > 0) {
      if (requireNamespace("gridExtra", quietly = TRUE)) {
        grid_plot <- gridExtra::grid.arrange(
          grobs = target_plots, 
          ncol = 2,
          top = paste("PDP Plots voor", target_mapping[[target_var]])
        )
        print(grid_plot)
      }
    }
    
    cat("\n")
  }
  
  return(all_pdp_plots)
}

# Function to create comparison plots of PDPs across targets
create_comparison_pdp_plots <- function(all_pdp_plots, var_to_compare) {
  comparison_plots <- list()
  
  for (target in names(all_pdp_plots)) {
    if (var_to_compare %in% names(all_pdp_plots[[target]])) {
      plot <- all_pdp_plots[[target]][[var_to_compare]] +
        labs(title = paste(target, "-", var_to_compare)) +
        theme(plot.title = element_text(size = 12))
      
      comparison_plots[[target]] <- plot
    }
  }
  
  if (length(comparison_plots) > 0) {
    grid_plot <- gridExtra::grid.arrange(
      grobs = comparison_plots,
      ncol = 2,
      top = paste("Vergelijking PDP plots voor", var_to_compare)
    )
    print(grid_plot)
  }
  
  return(comparison_plots)
}

# Function to create side-by-side comparison of ALE vs PDP plots
create_ale_pdp_comparison <- function(all_ale_plots, all_pdp_plots, target_var, var_to_compare) {
  if (!target_var %in% names(all_ale_plots) || !target_var %in% names(all_pdp_plots)) {
    cat("Target variable not found in plots\n")
    return(NULL)
  }
  
  if (!var_to_compare %in% names(all_ale_plots[[target_var]]) || 
      !var_to_compare %in% names(all_pdp_plots[[target_var]])) {
    cat("Variable not found in plots\n")
    return(NULL)
  }
  
  # Get plots
  ale_plot <- all_ale_plots[[target_var]][[var_to_compare]]
  pdp_plot <- all_pdp_plots[[target_var]][[var_to_compare]]
  
  # Modify titles for comparison
  ale_plot <- ale_plot + 
    labs(subtitle = "ALE Plot") +
    theme(plot.title = element_text(size = 14))
  
  pdp_plot <- pdp_plot + 
    labs(subtitle = "PDP Plot") +
    theme(plot.title = element_text(size = 14))
  
  # Arrange side by side
  comparison <- gridExtra::grid.arrange(
    ale_plot, pdp_plot, 
    ncol = 2,
    top = paste("ALE vs PDP:", var_to_compare, "voor", target_var)
  )
  
  return(comparison)
}

# Main execution
# Create PDP plots for all targets
all_pdp_plots <- create_pdp_plots_all_targets(
  models = models,
  train_data = as.data.frame(train_x),
  target_variables = target_variables
)

# Create comparison plots for specific variables across all targets
cat("Creating PDP comparison plots...\n")

# Example: Compare waterbreedte effects across all targets
waterbreedte_pdp_comparison <- create_comparison_pdp_plots(all_pdp_plots, "WATERBTE_m_WATERBTE_")

# Example: Compare waterdiepte effects across all targets  
waterdiepte_pdp_comparison <- create_comparison_pdp_plots(all_pdp_plots, "WATDTE_m_WATDTE_")

# Example: Compare kroos effects across all targets
kroos_pdp_comparison <- create_comparison_pdp_plots(all_pdp_plots, "PTN_BEDKG_%_KROOS_")

# Create direct ALE vs PDP comparisons for important variables
cat("Creating ALE vs PDP comparison plots...\n")

# Compare ALE vs PDP for waterdiepte effect on submerse vegetation
create_ale_pdp_comparison(all_ale_plots, all_pdp_plots, "submers_bedekking", "WATDTE_m_WATDTE_")

# Compare ALE vs PDP for zichtdiepte effect on submerse vegetation
create_ale_pdp_comparison(all_ale_plots, all_pdp_plots, "submers_bedekking", "zichtdte")

# Compare ALE vs PDP for waterbreedte effect on emerse vegetation
create_ale_pdp_comparison(all_ale_plots, all_pdp_plots, "emers_bedekking", "WATERBTE_m_WATERBTE_")

# Compare ALE vs PDP for kroosbedekking effect on submerse vegetation
create_ale_pdp_comparison(all_ale_plots, all_pdp_plots, "submers_bedekking", "PTN_BEDKG_%_KROOS_")

cat("PDP plots creation completed for all target variables!\n")
```

# Alle variabelen in de huidige sessie opslaan

```{r}
# save.image("anlb_project.RData")
```





# NOT USED (old/ backup)

```{r aleplot oud}
#| label: ale plots

# Create ALE plots for all target variables
create_ale_plots_all_targets <- function(models, train_data, target_variables) {
  
  # Define continuous variables for ALE plots
  continuous_vars <- c(
    "WATDTE_m_WATDTE_", "WATERBTE_m_WATERBTE_", "SLIBDTE_m_SLIBDTE_",
    "zichtdte", "TALBVWTR_graad_TALBVWTR_", "PTN_BEDKG_%_KROOS_", "jaar"
  )
  
  # Variable mapping for readable names
  var_mapping <- list(
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)", 
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "jaar" = "Jaar"
  )
  
  # Target variable mapping for readable names
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Verify which variables exist in training data
  valid_vars <- intersect(continuous_vars, colnames(train_data))
  
  # Store all ALE plots
  all_ale_plots <- list()
  
  # Loop through each target variable
  for (target_var in target_variables) {
    cat("Creating ALE plots for target:", target_var, "\n")
    
    model <- models[[target_var]]
    target_plots <- list()
    
    # Create ALE plots for each continuous variable
    for (var in valid_vars) {
      cat("  Creating ALE plot for:", var, "\n")
      
      # Calculate ALE values
      ale_data <- create_ale_plot(model, train_data, var)
      
      # Create plot with target-specific labeling
      p <- ggplot(ale_data, aes(x = x, y = ale)) +
        geom_line(linewidth = 1.2, color = "steelblue") +
        geom_rug(sides = "b", alpha = 0.2) +
        labs(
          title = paste("ALE:", var_mapping[[var]]),
          subtitle = paste("Effect op", target_mapping[[target_var]]),
          x = var_mapping[[var]],
          y = paste("Effect op", target_mapping[[target_var]])
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, face = "bold"),
          plot.subtitle = element_text(size = 12),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.minor = element_blank()
        )
      
      target_plots[[var]] <- p
      print(p)
    }
    
    # Store plots for this target
    all_ale_plots[[target_var]] <- target_plots
    
    # Create combined plot grid for this target
    if (length(target_plots) > 0) {
      if (requireNamespace("gridExtra", quietly = TRUE)) {
        grid_plot <- gridExtra::grid.arrange(
          grobs = target_plots, 
          ncol = 2,
          top = paste("ALE Plots voor", target_mapping[[target_var]])
        )
        print(grid_plot)
      }
    }
    
    cat("\n")
  }
  
  return(all_ale_plots)
}

# Create ALE plots for all targets
all_ale_plots <- create_ale_plots_all_targets(
  models = models,
  train_data = as.data.frame(train_x),
  target_variables = target_variables
)

# Optional: Create comparison plots for specific variables across all targets
create_comparison_ale_plots <- function(all_ale_plots, var_to_compare) {
  comparison_plots <- list()
  
  for (target in names(all_ale_plots)) {
    if (var_to_compare %in% names(all_ale_plots[[target]])) {
      plot <- all_ale_plots[[target]][[var_to_compare]] +
        labs(title = paste(target, "-", var_to_compare)) +
        theme(plot.title = element_text(size = 12))
      
      comparison_plots[[target]] <- plot
    }
  }
  
  if (length(comparison_plots) > 0) {
    grid_plot <- gridExtra::grid.arrange(
      grobs = comparison_plots,
      ncol = 2,
      top = paste("Vergelijking ALE plots voor", var_to_compare)
    )
    print(grid_plot)
  }
  
  return(comparison_plots)
}

# .Example: Compare waterbreedte effects across all targets
waterbreedte_comparison <- create_comparison_ale_plots(all_ale_plots, "WATERBTE_m_WATERBTE_")

# Example: Compare waterdiepte effects across all targets  
waterdiepte_comparison <- create_comparison_ale_plots(all_ale_plots, "WATDTE_m_WATDTE_")

# Summary function to show key insights
summarize_ale_effects <- function(all_ale_plots) {
  cat("=== ALE PLOT SAMENVATTING ===\n\n")
  
  for (target in names(all_ale_plots)) {
    cat("Target variabele:", target, "\n")
    cat("Aantal ALE plots gemaakt:", length(all_ale_plots[[target]]), "\n")
    cat("Variabelen geanalyseerd:", paste(names(all_ale_plots[[target]]), collapse = ", "), "\n")
    cat("\n")
  }
}

# Show summary
summarize_ale_effects(all_ale_plots)

# Create ALE plots for each continuous feature
continuous_vars <- c(
  "WATDTE_m_WATDTE_", "WATERBTE_m_WATERBTE_", "SLIBDTE_m_SLIBDTE_",
  "zichtdte", "TALBVWTR_graad_TALBVWTR_", "PTN_BEDKG_%_KROOS_", "jaar"
)

# Verify these variables exist in your training data
valid_vars <- intersect(continuous_vars, colnames(train_x))
cat("Creating ALE plots for these variables:", paste(valid_vars, collapse=", "), "\n")

var_mapping <- list(
  "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
  "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)",
  "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
  "zichtdte" = "Zichtdiepte/Waterdiepte",
  "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
  "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
  "jaar" = "Jaar"
)

# Create ALE plots
ale_plots <- list()
for (var in valid_vars) {
  cat("Creating ALE plot for:", var, "\n")
  
  # Calculate ALE values
  ale_data <- create_ale_plot(xgb_model, as.data.frame(train_x), var)
  
  # Create plot
  p <- ggplot(ale_data, aes(x = x, y = ale)) +
    geom_line(linewidth = 1.2, color = "steelblue") +
    geom_rug(sides = "b", alpha = 0.2) +
    labs(
      title = paste("ALE Plot:", var_mapping[[var]]),
      x = var,
      y = paste("Effect op", target_var)
    ) +
     theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      panel.grid.minor = element_blank()
    )
  
  ale_plots[[var]] <- p
  print(p)
}

# Display all plots together
if (length(ale_plots) > 0) {
  if (requireNamespace("gridExtra", quietly = TRUE)) {
    grid_plot <- gridExtra::grid.arrange(grobs = ale_plots, ncol = 2)
    print(grid_plot)
  }
}
```

## Import data not used

-   geodatabase not complete

```{r data geodatabase}
# Load sken je sloot------------
layer_list <- st_layers(paste0(workspace,'./Sken je sloot.gdb'))
layer_list <- unique(layer_list$name)
ss_2017 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[1])
ss_2018 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[3])
ss_2019 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[5])
ss_2020 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[7])
ss_2021 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[9])
ss_2022 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[11])
ss_2023 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[13])
ss_2024 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[15])

# combine---------------------
ss <- list(ss_2017,ss_2018,ss_2019,ss_2020,ss_2021,ss_2022,ss_2023,ss_2024)
ss <- rbindlist(ss, fill = T, use.names = T)
setDT(ss)
ss[,datum := as.Date(datum)]
ss[,jaar := year(datum)]
ss[globalid %in% ss_2017$globalid, jaar := 2017]
ss[globalid %in% ss_2019$globalid, jaar := 2019]

# reformat------------------------
ss2<- melt(ss, id.vars = c('globalid','datum','tijd','jaar','Shape'))
ss2 <- ss2[!is.na(value),]
ov_ss2 <- dcast(ss2, variable~jaar, value.var = 'value', fun.aggregate = length)
fwrite(ov_ss2, file= paste0('skenjesloot_pars.csv'), sep = ';', dec ='.', )

# filter set for unique locations (sloten), unique not possible with sf data -----------------------------
ssloc <- ss2[variable == 'blnDoorzicht',]
ssloc <- st_as_sf(ssloc, crs = 4326) %>% st_transform(28992)
ssloc <- st_join(ssloc, st_buffer(brpagv[!(brpagv$category == 'Landschapselement'),], dist = 5), left = TRUE, largest = TRUE)
check<- unique(ssloc[is.na(ssloc$ref_id),c('globalid','Shape','jaar.x')])
setDT(ssloc)
ssloc[,jaar_sjs := jaar.x] 
ssloc[,jaar.x:=NULL];ssloc[,jaar.y:=NULL]

# combine locations
ssloc[,brp_nr := rep(seq_len(.N), each = 1, length.out = .N), by = c('ref_id')]
# ssloc <- st_as_sf(ssloc)
ssloc[,dist := st_distance(Shape[brp_nr == 1], Shape), by ='ref_id'] 
ssloc[,id := globalid]
ssloc[,dist := as.numeric(dist)]
sslocmatch <- ssloc[brp_nr == 1,]
ssloc <- merge(ssloc, sslocmatch[,c('globalid','ref_id', 'jaar_sjs')], by = 'ref_id', suffixes = c('','_match'), all.x = TRUE, all.y = FALSE)
# combine locs within 100 meter on same brp gewasperceel in verschillende jaren (soms zijn het wel andere sloten)
ssloc[dist < 100 & !(jaar_sjs == jaar_sjs_match), id := globalid_match]
ssloc <- st_as_sf(ssloc)
st_write(ssloc, 'ssloc.gpkg')
```

-   fews format not complete

```{r import skenjesloot fews format}
skenjesloot <- list.files(path= paste0(workspace,'./skenjesloot_fewsformat/'), pattern=".csv", full.names =  T)
skenjesloot <- lapply(skenjesloot, fread, sep=';')
skenjesloot <- rbindlist(skenjesloot, fill =T, use.names = T)
# unique(skenjesloot$datum)
skenjesloot[,datum := as.Date(datum, format = "%d-%m-%Y")]
skenjesloot[,jaar := year(datum)]
skenjesloot[,maand := month(datum)]
skenjesloot[,meetwaarde := as.numeric(meetwaarde)]
skenjesloot[,c('xcoormonster','ycoormonster')  := list(as.integer(xcoormonster),as.integer(ycoormonster))]
parameter <- data.table::fread('../WaterEcoInzicht/input/20250603/parameterid.csv', fill = TRUE)
skenjesloot <- merge(skenjesloot, parameter[,c("code","naam", 'grootheid',"categorie","H_min", "H_max")], by.x = 'parameterid', by.y = 'code', suffixes = c('','_parameter'), all.x = TRUE)

```

-   selection agrarisch not by area but only data in same EAG's as anlb are used for analysis

```{r agrarische EAG sel}
# bereken agrarisch oppervlak per EAG
brpagv$agropp <- as.numeric(st_area(brpagv))
brpagv <- brpagv %>% as.data.table()
brpagv <- brpagv[,agropptot := sum(as.numeric(agropp)), by = c('Code','category')]
brpagv_agg <- unique(brpagv[,c('Code','category','agropptot')])
brpagv_agg <- dcast(brpagv_agg,Code~category, value.var = 'agropptot', fill = 0)

EAG <- merge(EAG, brpagv_agg, by = 'Code', all.x = TRUE)
setDT(EAG)
EAG[,OppLand:= as.numeric(Land_m2)]
EAG[,Relagr := (Bouwland+Grasland)/ OppLand]
EAG[Relagr > 0.5, gebiedstype := 'agrarisch']
EAG[is.na(gebiedstype), gebiedstype := 'overig']
st_write(EAG,'eag_gebiedstypeagrarisch.gpkg', append =FALSE)

```

## data verwerking not used
```{r anlb 2024 overzicht}
# overzicht 2024 ------------
anlb2024 <- merge(anlb2024[,-c('pakket2','pakket3')], anlb_cat, by = 'pakket', all.x = TRUE)
anlb2024 <- anlb2024[pakket2 == 'water',]
anlb2024 <- st_as_sf(anlb2024)
anlb2024 <- st_join(anlb2024, EAG, left = TRUE, largest = TRUE)
setDT(anlb2024)
write.table(anlb2024[,-'geom'],file ='anlb2024.csv',sep =';',dec='.', row.names = FALSE)
wat_agv_24 <- anlb2024[!is.na(Code) & pakket2 == 'water', sum(as.numeric(opp)), by = c('collectief')]
```

## visualisatie not used
```{r data exploration sjs}


# create table with beheer---------------
sjs_beheer <- ss2[grepl('^BEHPK', variable),]
ss2_beheer <- merge(ss2, sjs_beheer, by =c('globalid','jaar'),allow.cartesian = T, suffixes = c('','_beheer'))
ss2_beheer[value_beheer == 0, variable_beheer := "regulier beheer"]
id_beheer <- ss2_beheer[value_beheer == 1, globalid]
ss2_beheer <- ss2_beheer[!(variable_beheer == "regulier beheer" & globalid %in% id_beheer), ]

# add N obs
ss2_beheer[,n_obs:=uniqueN(globalid),by =c('variable','variable_beheer','jaar')]

# figuur metingen per pakket per jaar (geodb) --------------
ggplot(data = ss2[grepl('^BEHPK', variable),])+
  geom_bar(aes(x = variable, fill = as.factor(value)), 
           position = 'stack') +
  coord_flip()+
  facet_wrap(~jaar)+
  scale_fill_discrete(labels = c('onbekend','afwezig','aanwezig'))+
  guides(fill=guide_legend(title=''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Beheerpakketten in (s)Ken je sloot") +
    labs(x="",y="aantal opnamen")

## bedekking emers-------------
ggplot(data = ss2_beheer[variable == 'EMSPTN',])+
  geom_boxplot(aes(x = variable_beheer, y = as.numeric(value))) +
  geom_text(aes(x = variable_beheer, y=0, label = n_obs))+
  facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers") +
    labs(x="",y="%")
  # ylim(0,15)

## submers-------------
ggplot(data = ss2_beheer[variable == 'SUBMSPTN',])+
  geom_boxplot(aes(x = variable_beheer, y = as.numeric(value))) +
  geom_text(aes(x = variable_beheer, y=0, label = n_obs))+
  facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submers") +
    labs(x="",y="%")
  # ylim(0,15)

```