---
title: "main"
author: "Laura Moria"
date: "`r Sys.Date()`"
output: html_document
---


## Setup

```{r setup, include=FALSE}
#| label: setup
knitr::opts_chunk$set(echo = TRUE)
workspace <- paste0(Sys.getenv("NMI-SITE"), 'O 2000 - O 2001/2083.N.25 Effect ANLB pakketten op waterkwaliteit/04. Data en resultaten/')
nmidata <- Sys.getenv("NMI_DATA")

# load packages
library(dplyr)
library(data.table)
library(sf)
library(ggplot2)
library(gridExtra)
library(vip)
library(xgboost)
library(pdp)
library(ggspatial)
# Install corrplot if you don't have it
if (!require(corrplot)) install.packages("corrplot")
library(corrplot)

# Later weer inladen
load("anlb_project.RData")

```

-   per collectief een overzicht ha per jaar type pakket kan als ik st_area gebruik op anlb object
-   sken je sloot aantal locaties per jaar per pakket
-   locaties skenjesloot samenvoegen koppeling aan perceel + afstand dan check een unieke locatie per jaar en op kaart
-   datasets maken met relevante variabelen
-   cookbook runnen
-   grondsoort (OS in toplaag bodemschat),toevoegen percentage open water, PAL, P-belasting (wenr), drooglegging?

## Import data

```{r import geodata}
#| label: import geodata 
# Load base layer with EAGs 
EAG <- st_read(paste0(workspace,'./Beheerregister_EAG_20241218/Beheerregister_EAG_20241218.shp')) %>% st_transform(28992)

# load gewaspercelen
# brp <- st_read(paste0(nmidata,'./landgebruik/brp/products/brpgewaspercelen_2024_concept.gpkg')) %>% st_transform(28992)
# brpagv <- st_crop(brp, st_bbox(EAG))
# st_write(brpagv, 'brpagv.gpkg', append = FALSE)
brpagv <- st_read('output/brpagv.gpkg')

# load bodemschat
# bs6  <- st_read(paste0(nmidata, "bodem/bodemschat/products/BS6/BS6_2021.gpkg")) 
# bs6 <- st_crop(bs6,st_bbox(EAG))
# st_write(bs6, 'output/bs6agv.gpkg')
bs6 <- st_read('output/bs6agv.gpkg')
pvskp <- fread('input/PvskP.csv')
# pvskp <- readRDS('input/pvskp.rds')
```

### Load and prepare ANLB data
```{r load and ppr anlb}
#| label: load anlb

# # anlb------------------------
# ## collectieven: "RVV" "NHZ" "NP" "HV" 
# ## perioden: 2016 tm 2021
# anlb2016 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2016.gpkg'))%>% st_transform(28992)
# setDT(anlb2016);anlb2016[,jaar:= 2016]
# anlb2017 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2017.gpkg'))%>% st_transform(28992)
# setnames(anlb2017, c('PAKKETNAAM','PAKKETCODE','DEELN_NAAM','LENGTH','AREA','COL','geom'),c('pakket','code','boer','len','opp','collectief','geom'))
# setDT(anlb2017);anlb2017[,jaar:= 2017]
# anlb2018 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2018.gpkg'))%>% st_transform(28992)
# setDT(anlb2018);anlb2018[,jaar:= 2018]
# anlb2019 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2019.gpkg'))%>% st_transform(28992)
# setDT(anlb2019);anlb2019[,jaar:= 2019]
# anlb2020 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2020.gpkg'))%>% st_transform(28992)
# setDT(anlb2020);anlb2020[,jaar:= 2020]
# anlb2021 <- st_read(paste0(workspace,'./ANLB/ANLB_AGV_2021.gpkg'))%>% st_transform(28992)
# setDT(anlb2021);anlb2021[,jaar:= 2021]
# # 2022
# anlb2022 <- copy(anlb2021)
# anlb2022[,jaar:= 2022]
# # 2023 - 2028
# anlb2023_hv <- st_read(paste0(workspace,'./ANLB/Waterpakketten 2022.shp'))%>% st_transform(28992)
# anlb2023_hv$collectief <- "HV"
# anlb2023_hv$opp <- as.numeric(st_area(anlb2023_hv))/10000
# anlb2023_hv<- st_cast(anlb2023_hv,'MULTIPOLYGON')
# setDT(anlb2023_hv)
# setnames(anlb2023_hv, c('PAKKETNAAM','geometry'),c('pakket','geom'))
# anlb2023_uo <- st_read(paste0(workspace,'./ANLB/UO 2023 alle pakketten.gpkg'))%>% st_transform(28992)
# anlb2023_uo$collectief <- "UO"
# anlb2023_rvv <- st_read(paste0(workspace,'./ANLB/beheereenheden_2023-01-01_tot_2023-12-31_26-03-2024_12_47_boerennatuur-rijn-vecht-venen.shp'))%>% st_transform(28992)
# anlb2023_rvv$collectief <- "RVV"
# anlb2023_nhz <- st_read(paste0(workspace,'./ANLB/NHZ 2023 waterpakketten.gpkg'))%>% st_transform(28992)
# anlb2023_nhz$collectief <- "NHZ"
# setDT(anlb2023_uo);setDT(anlb2023_rvv);setDT(anlb2023_nhz)
# setnames(anlb2023_rvv, 'geometry', 'geom')
# anlb2023 <- rbind(anlb2023_uo,anlb2023_rvv,anlb2023_nhz)
# anlb2023 <- anlb2023[,c('PAKKETNAAM','PAKKETCODE','DEELN_ID','LENGTH','AREA','collectief','geom')]
# setnames(anlb2023, c('PAKKETNAAM','PAKKETCODE','DEELN_ID','LENGTH','AREA','geom'),c('pakket','code','boer','len','opp','geom'))
# anlb2023 <- rbind(anlb2023,anlb2023_hv, fill = TRUE)
# anlb2023[,jaar:= 2023]
# # 2024
# anlb2024 <- copy(anlb2023)
# anlb2024[,jaar:= 2024]

# ## alles samenvoegen ----------------
# anlb <- rbindlist(list(anlb2016,anlb2017,anlb2018,anlb2019,anlb2020,anlb2021,anlb2022,anlb2023, anlb2024), fill = TRUE, ignore.attr=TRUE)

# # overzichtstabel 4 pakketindeling --------------
# ## anlbchecktab <- unique(anlb[,c('pakket','pakket1','pakket2','pakket3')])
# ## write.csv2(anlbchecktab, file ='anlbchecktab.csv', fileEncoding = "latin4", quote = TRUE)
# # categorieen
# anlb_cat <- read.csv2(paste0(workspace,'./ANLB/anlbchecktab.csv'), sep =';', fileEncoding = "latin4")
# anlb_cat <- setDT(unique(anlb_cat[,c('pakket','pakket2','pakket3')]))
# anlb_cat <- anlb_cat[!is.na(pakket),]
# anlb <- merge(anlb[,-c('pakket2','pakket3')],anlb_cat, by = 'pakket', all.x = TRUE)
# anlb[pakket == 'hoog waterpeil\r\nverhoging 20 cm, 15 mrt tot 15 juni',pakket2 := 'water']
# anlb[pakket == 'hoog waterpeil\r\nverhoging 20 cm, 15 mrt tot 15 juni',pakket3 := 'water']
# anlb[pakket == 'plas-dras\r\n15 februari tot 15 mei, minstens 5 cm',pakket2 := 'water']
# anlb[pakket == 'plas-dras\r\n15 februari tot 15 mei, minstens 5 cm',pakket3 := 'water']
# anlb[pakket == 'verlenging Plas-dras 15 mei tot 15 juni',pakket2 := 'water']
# anlb[pakket == 'verlenging Plas-dras 15 mei tot 15 juni',pakket3 := 'water']

# ## filter waterpakketten -----------------------
# check <- as.data.table(unique(anlb$pakket[is.na(anlb$pakket2)]))
# anlb <- anlb[pakket2 == 'water',]
# #create sf object
# anlb <- anlb[,-c('fid')]
# anlb <- st_as_sf(anlb)
# unique(st_geometry_type(anlb))
# anlb <- st_cast(anlb,'MULTIPOLYGON')
# anlb <- st_make_valid(anlb)
# # save merged object
# st_write(anlb,'anlb_merged.gpkg', append = FALSE)
```

```{r add collectief}
#| label:  add collectief
#| # ## add collectief ---------------------------
# anlb_col <- st_read(paste0(workspace,'./ANLB/begrenzing_collectieven_manual.shp'))%>% st_transform(28992)
# anlb <- st_join(anlb, anlb_col, left = TRUE, largest = TRUE)
# setDT(anlb)
# anlb[is.na(Naam), Naam := 'HollandseVenen']
# anlb[,collectief := Naam]
# anlb <- st_as_sf(anlb)

# setDT(anlb)
# anlb <- anlb[,-c('boer','len','opp','lengte','layer','path','Naam')]
# # add area in ha and length in m
# anlb[,area_ha := as.numeric(st_area(st_as_sf(anlb)))/10000]
# anlb[,length_m := as.numeric(st_length(st_as_sf(anlb)))]
# # make spatial 4 koppeling
# anlb <- st_as_sf(anlb)
# #merge with EAG
# anlb <- st_join(anlb, EAG[,c('Code','geometry')], left = TRUE, largest = TRUE)

# st_write(anlb,'anlb_merged.gpkg', append = FALSE)


```

```{r load anlb}
#| label:  load merged object
anlb <- st_read('anlb_merged.gpkg')
```

### Import data waterschap: hybi, bodchem data
```{r import hybi}
#| label: import data hybi
hybi <- readRDS('../WaterEcoInzicht/data/hybi.rds') %>% as.data.table()
ptn_monsters <- unique(hybi$monsterident[hybi$analyse == 'PTN'])
hybi <- hybi[monsterident %in% ptn_monsters,]
hybiloc <- st_as_sf(unique(hybi[,c("locatie","EAGIDENT","XCOORD","YCOORD")]),coords = c("XCOORD","YCOORD"),crs = 28992)
```

```{r import bodchem}
#| label: import bodemchemie
bodchem <- readRDS('input/bodchem.rds')
# calc nalevering bodchemie
calc_watbod <- function(bodchem){
# dcast slootbodem
selb <- dcast.data.table(bodchem, EAGIDENT+locatie+datum+jaar ~ parameterid+compartiment, value.var = "meetwaarde", fun.aggregate = mean, fill= "")

  # calculate relevant ratios
  selb[,FeSP_DW := (Fe_mg_kg_dg_SB/55.845 - Stot_mgS_kg_dg_SB/32.065)/(Ptot_gP_kg_dg_SB*1000/30.974)]# deze zit in baggernut
  selb[,FeP_DW := (Fe_mg_kg_dg_SB/55.845)/(Ptot_gP_kg_dg_SB*1000/30.974)]
  selb[,FeS_DW := (Fe_mg_kg_dg_SB/55.845)/(Stot_mgS_kg_dg_SB/32.065)] # deze is meest relevant
  selb[,FeSP_FW := (Fe_mg_l_ng_SB/55.845 - Stot_mgS_l_ng_SB/32.065)/(Ptot_mgP_l_ng_SB/30.974)]# deze zit in baggernut
  selb[,FeP_FW := (Fe_mg_l_ng_SB/55.845)/(Ptot_mgP_l_ng_SB/30.974)]
  selb[,FeS_FW := (Fe_mg_l_ng_SB/55.845)/(Stot_mgS_l_ng_SB/32.065)]
  selb[,FeP_PW := (Fe_mg_l_nf_PW/55.845)/(Ptot_mgP_l_nf_PW/30.974)]# deze zit in baggernut & is meest relevant
  # selb[,FeS_PW := (Fe_mg_l_nf_PW/55.845)/(SO4_mg_l_nf_PW/96.06)]
  selb[,FeS_PW := (Fe_mg_l_nf_PW/55.845)/(Stot_mgS_l_nf_PW/96.06)]
  
  # calculate nalevering
  selb[,nlvr_FW := 0.0247 * Ptot_mgP_l_ng_SB - 1.6035]
  selb[,nlvr_PW := 0.8095 * Ptot_mgP_l_nf_PW - 0.2905]
  # selb[,nlvr_olson_FW := 5.8 * (Ptot_mgPOlsen_l_ng_BS/30.974) - 1.1361]
  
  #FW
  selb[,classFeSP_FW := cut(FeSP_FW, breaks = c((min(FeSP_FW, na.rm = TRUE)-1), 1.4, 4, max(FeSP_FW, na.rm = TRUE)), labels = c('geen ijzerval', 'beperkte ijzerval', 'functionele ijzerval'))]
  selb[FeSP_FW >= 4, nlvr_FW := 0.1 * nlvr_FW] # BaggerNut Tool zegt 0-1
  selb[FeSP_FW < 4 & FeSP_FW > 1.4, nlvr_FW := 0.5 * nlvr_FW] # BaggerNut zegt < nlvr_FW & > 0-1
  selb[FeSP_FW <= 1.4, nlvr_FW := nlvr_FW]
  selb[nlvr_FW < 0,nlvr_FW := 0]
  #PW
  selb[FeP_PW > 10 & FeS_PW > 1, c('nlvr_PW','classFESPPWratio') := list(0.1*nlvr_PW,'functionele ijzerval') ]  # BaggerNut zegt lage nalevering
  selb[FeP_PW > 1 & FeS_PW > 1, c('nlvr_PW','classFESPPWratio') := list(0.1*nlvr_PW,'functionele ijzerval') ]  # BaggerNut zegt lage nalevering
  selb[FeP_PW > 1 & FeS_PW <= 1, c('nlvr_PW','classFESPPWratio') := list(0.5*nlvr_PW,'beperkte ijzerval')] # BaggerNut zegt < nlvrPW 
  selb[FeP_PW <= 1, c('nlvr_PW','classFESPPWratio') := list(nlvr_PW,'geen ijzerval')]
  selb[nlvr_PW < 0,nlvr_PW := 0]
  
  return(selb)  
  
}

baggernut <- calc_watbod(bodchem)

```

### Import Sken je sloot data
```{r import skenjesloot}
#| label: import skenjesloot
skenjesloot <- list.files(path= paste0(workspace,'./skenjesloot/'), pattern=".csv", full.names =  T)
classes <- sapply(fread(skenjesloot[8L], sep=','), class)
skenjesloot <- lapply(skenjesloot, fread, sep=',', colClasses = unlist(classes))
skenjesloot <- rbindlist(skenjesloot, fill =T, use.names = T)
# unique(skenjesloot$datum)
# skenjesloot[,datum := as.Date(datum, format = "%Y-%m-%d")]
skenjesloot[,datum := as.Date(datum, format = "%d-%m-%Y")]
skenjesloot[,jaar := year(datum)]
skenjesloot[,maand := month(datum)]
skenjesloot[,c('xcoormonster','ycoormonster')  := list(as.integer(xcoormonster),as.integer(ycoormonster))]

ov_sjs <- dcast(skenjesloot, parameterid+parameter+parameterfractie+eenheid+eenheidreferentie~jaar, fill = FALSE, drop = TRUE, fun.aggregate = uniqueN, value.var = 'externereferentie')

# correct parcodes -----------
# skenjesloot[parameterid == 'PTN_BEDKG', parameterid := 'PTN_AANWZHD']
# skenjesloot[parameterid == 'PTN_AANWZHD', parameter := 'PTN_BEDKG']
# skenjesloot[parameterid == 'PERODSLSSNG_mnd', eenheid := 'mnd']
skenjesloot[parameterid == 'RIVIERKREEFTENLAND', parameter := 'Astacoidea_AANWZHD'] 
skenjesloot[parameterid %in% c('PERODSLSBGODHD_a','BEHMRGL_a','BEHMRGLHDG_a') & meetwaarde == 0, meetwaarde := NA]
skenjesloot[meetwaarde == 99, meetwaarde := 100]

# enumeratievelden toevoegen ------------------
## baggeren5jaar
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == 'Nooit', meetwaarde := 0]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == '1 keer', meetwaarde := 1]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == '2 keer', meetwaarde := 2]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == '3 keer', meetwaarde := 3]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == '4 keer', meetwaarde := 4]
skenjesloot[parameterid == 'BAGGEREN5JAAR' & meetwaarde == 'vaker', meetwaarde := 5]
## schonen5jaar
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == 'Nooit', meetwaarde := 0]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == '1 keer', meetwaarde := 1]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == '2 keer', meetwaarde := 2]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == '3 keer', meetwaarde := 3]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == '4 keer', meetwaarde := 4]
skenjesloot[parameterid == 'SCHONEN5JAAR' & meetwaarde == 'vaker', meetwaarde := 5]
## ander beheerpakket
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == 'Sloot_schonen', meetwaarde := 1]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == 'Sloot_maaien', meetwaarde := 2]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == 'Sloot_baggeren', meetwaarde := 3]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == 'Geen_maatregelen', meetwaarde := 4]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == "Sloot_schonen,Sloot_baggeren", meetwaarde := 5]             
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == "Sloot_schonen,Sloot_baggeren,Sloot_maaien", meetwaarde := 6]
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == "Sloot_schonen,Sloot_maaien", meetwaarde := 7]               
skenjesloot[parameterid == 'ANDER_BEHEERPAKKET' & meetwaarde == "Sloot_maaien,Sloot_schonen", meetwaarde := 7]
## type/ machine schonen
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'maaikorf', meetwaarde := 1]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'hemos', meetwaarde := 2]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'ecoreiniger', meetwaarde := 3]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'spijlen', meetwaarde := 4]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'gaatjes', meetwaarde := 5]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'anders', meetwaarde := 6]
skenjesloot[parameterid == 'TYPESLSSNG' & meetwaarde == 'nvt', meetwaarde := 7]
# fotodb separate
sjs_foto <- skenjesloot[parameterid %in% c('FOTONR','FOTO_n'),]
skenjesloot <- skenjesloot[!(parameterid %in% c('FOTONR','FOTO_n')),]
# replace puntkomma
# skenjesloot[,meetwaarde := gsub(',','.',meetwaarde)]
skenjesloot[,meetwaarde := as.numeric(meetwaarde)]
# correct diepte, doorzicht in 2023 en 2024
skenjesloot[parameterid %in% c("WATDTE_m", "SLIBDTE_m","ZICHT_m") & jaar %in% c(2020,2021,2022,2023,2024), meetwaarde := meetwaarde/100]
skenjesloot[parameterid %in% c("WATDTE_m", "SLIBDTE_m","ZICHT_m") & meetwaarde > 3, meetwaarde := meetwaarde/100]

# add par info -------------------
parameter <- data.table::fread(paste0(workspace,'./parameterid.csv'), fill = TRUE)
skenjesloot <- merge(skenjesloot, parameter[,c("code","naam",'pakket_agg','vraag sken je sloot', 'grootheid',"categorie","H_min", "H_max")], by.x = 'parameterid', by.y = 'code', suffixes = c('','_parameter'), all.x = TRUE)
skenjesloot <- skenjesloot[!parameterid == '',]

# check <- merge(parameter, unique(skenjesloot[,c('parameterid','parameter','parameterfractie','eenheid')]), by.x = 'code', by.y = 'parameterid', all.x = TRUE)

```

## data verwerking

### Anlb hybi

```{r merge hybi anlb} 
#| label: merge hybi anlb

# spatial merge met buffer van 8 meter rond pakketten
anlb <- st_as_sf(anlb)
anlbhybi <- st_intersection(hybiloc, st_buffer(anlb, dist = 8), left = TRUE)
# only locs in same EAG hybi as anlb
anlbhybi <- anlbhybi[anlbhybi$Code %in% anlbhybi$EAGIDENT,]
# percentage meetlocaties grenzend aan pakketten als jaren niet worden meegenomen 13.5 %
uniqueN(anlbhybi$locatie)/uniqueN(hybiloc$locatie)
# cast naar breed formaat, zodat locatie uniek is
setDT(anlbhybi)
anlbhybi[,jaar := as.numeric(jaar)] # jaar uit anlb
anlbhybi <- anlbhybi[,-c('geometry')]
anlbhybi <- unique(anlbhybi)
anlbhybi <- dcast(anlbhybi, locatie+jaar~pakket3, fun.aggregate = uniqueN, value.var = 'pakket', drop = TRUE)
# add aantal jaar anlb
anlbhybi[,maxjaaranlb := max(jaar), by = locatie]
anlbhybi[,minjaaranlb := min(jaar), by = locatie]
uniqueN(anlbhybi[is.na(maxjaaranlb),locatie])
# merge met hybi data
hybi[,jaar := as.numeric(jaar)]
hybianlb <- merge(hybi, anlbhybi, by = c('locatie','jaar'), all.x = T, suffixes = c('hybi','anlb'))

# Voeg historie van beheermaatregelen toe aan hybianlb
# Voor locaties die 1-3 jaar na ANLB pakketten worden bemonsterd

# Stap 1: Bereid ANLB historie data voor
anlb_historie <- anlbhybi[, .(
  locatie,
  jaar_anlb = jaar,
  baggeren_hist = baggeren,
  bufferzone_hist = bufferzone,
  nat_vriend_oever_hist = nat.vriend.oever,
  slootschonen_hist = slootschonen,
  water_hist = water
)]

# Stap 2: Maak alle mogelijke combinaties van hybi meetjaren en ANLB jaren
# voor dezelfde locaties (1-3 jaar historie)
hybi_locaties <- unique(hybianlb[, .(locatie, jaar_hybi = jaar)])

# Merge om mogelijke combinaties te krijgen
historie_matches <- merge(
  hybi_locaties,
  anlb_historie,
  by = "locatie",
  all.x = TRUE,
  allow.cartesian = TRUE
)

# Stap 3: Filter voor 1-3 jaar historie (ANLB jaar vóór hybi jaar)
historie_matches <- historie_matches[
  jaar_hybi - jaar_anlb >= 1 & jaar_hybi - jaar_anlb <= 3
]

# Stap 4: Voor elke locatie-jaar combinatie, aggregeer de historie
# Als er meerdere ANLB jaren zijn in de 1-3 jaar periode, neem de meest recente
historie_summary <- historie_matches[, .(
  jaar_anlb_recent = max(jaar_anlb, na.rm = TRUE),
  baggeren_hist_recent = baggeren_hist[which.max(jaar_anlb)],
  bufferzone_hist_recent = bufferzone_hist[which.max(jaar_anlb)],
  nat_vriend_oever_hist_recent = nat_vriend_oever_hist[which.max(jaar_anlb)],
  slootschonen_hist_recent = slootschonen_hist[which.max(jaar_anlb)],
  water_hist_recent = water_hist[which.max(jaar_anlb)],
  jaren_sinds_anlb = max(jaar_hybi - jaar_anlb, na.rm = TRUE)
), by = .(locatie, jaar_hybi)]

# Stap 5: Voeg de historie toe aan hybianlb
hybianlb_enhanced <- merge(
  hybianlb,
  historie_summary,
  by.x = c("locatie", "jaar"),
  by.y = c("locatie", "jaar_hybi"),
  all.x = TRUE
)

# Stap 6: Vul missing values met 0 voor locaties zonder ANLB historie
historie_cols <- c("baggeren_hist_recent", "bufferzone_hist_recent", 
                   "nat_vriend_oever_hist_recent", "slootschonen_hist_recent", 
                   "water_hist_recent")
hybianlb_enhanced[, (historie_cols) := lapply(.SD, function(x) {
  ifelse(is.na(x), 0, x)
}), .SDcols = historie_cols]
hybianlb_enhanced[is.na(jaren_sinds_anlb), jaren_sinds_anlb := NA]
hybianlb_enhanced[is.na(jaar_anlb_recent), jaar_anlb_recent := NA]

# Stap 7: Hernoem kolommen voor duidelijkheid
setnames(hybianlb_enhanced, 
         old = c("baggeren_hist_recent", "bufferzone_hist_recent", 
                 "nat_vriend_oever_hist_recent", "slootschonen_hist_recent", 
                 "water_hist_recent"),
         new = c("baggeren_historie", "bufferzone_historie", 
                 "nat_vriend_oever_historie", "slootschonen_historie", 
                 "water_historie"))

# Overzicht van historie per jaar
historie_overzicht <- hybianlb_enhanced[!is.na(jaar_anlb_recent), 
  .(n_locaties = .N), 
  by = .(jaar, jaren_sinds_anlb)]

# Update je hoofddataset
hybianlb <- hybianlb_enhanced

# add aantal paketten
hybianlb[,pakket_n_anlb := rowSums(.SD, na.rm = TRUE), .SDcols = c('baggeren','bufferzone','nat.vriend.oever','slootschonen','baggeren_historie','slootschonen_historie','nat_vriend_oever_historie','bufferzone_historie')]

# ============================================================================
# VERBETERDE BEHEER CATEGORISATIE - CORRECTE VOLGORDE
# ============================================================================

# Herdefinieer beheer categorieën met betere logica
hybianlb[, beheer := NA_character_]

# EERST: Combinaties met baggeren (meest dominant)
hybianlb[baggeren == 1 & nat.vriend.oever == 1 & slootschonen == 1, 
         beheer := 'baggeren_schonen_nvo']
hybianlb[is.na(beheer) & baggeren == 1 & nat.vriend.oever == 1 & slootschonen != 1, 
         beheer := 'baggeren_nvo']
hybianlb[is.na(beheer) & baggeren == 1 & nat.vriend.oever != 1 & slootschonen == 1, 
         beheer := 'baggeren_schonen']
hybianlb[is.na(beheer) & baggeren == 1, 
         beheer := 'baggeren']

# TWEEDE: Combinaties ZONDER baggeren maar met schonen/NVO
# BELANGRIJK: Natuurvriendelijke oever heeft voorrang boven bufferzone!
hybianlb[is.na(beheer) & nat.vriend.oever == 1 & slootschonen == 1, 
         beheer := 'schonen_nvo']
hybianlb[is.na(beheer) & nat.vriend.oever == 1, 
         beheer := 'nat.vriend.oever']  # Dit vangt ook bufferzone + NVO op!
hybianlb[is.na(beheer) & slootschonen == 1, 
         beheer := 'slootschonen']

# DERDE: Historie pakketten (als er geen huidig pakket is)
hybianlb[is.na(beheer) & slootschonen_historie == 1, 
         beheer := 'slootschonen_historie']
hybianlb[is.na(beheer) & baggeren_historie == 1, 
         beheer := 'baggeren_historie']

# VIERDE: Bufferzone (alleen als er GEEN NVO is!)
hybianlb[is.na(beheer) & bufferzone == 1, 
         beheer := 'bufferzone']

# VIJFDE: Alleen water pakket
hybianlb[is.na(beheer) & water == 1, 
         beheer := 'water']

# ZESDE: Regulier (geen van bovenstaande pakketten)
hybianlb[is.na(beheer) & pakket_n_anlb == 0, 
         beheer := 'regulier']

# LAATSTE: Overige combinaties
hybianlb[is.na(beheer), beheer := 'overig']

setorder(hybianlb,locatie, jaar)
# add anlb labels
hybianlb[pakket_n_anlb == 0, anlb := 'nee']
hybianlb[pakket_n_anlb >= 1, anlb := 'ja']
hybianlb[,njaaranlb := jaar-minjaaranlb+1]

# alternatief 1: merge with gebiedstype agrarisch
# hybianlb <- merge(hybianlb, EAG, by.x = 'EAGIDENT',by.y = 'Code', all.x = T)
# sel only agrarisch (421380)
# hybianlb <- hybianlb[gebiedstype == 'agrarisch',]

# alternatief 2: filter alleen EAGs met en zonder anlb pakket
anlbeag <- unique(hybianlb[hybianlb$anlb == 'ja', c('EAGIDENT', 'jaar')])
anlbeag[,eagjaar:= paste0(EAGIDENT,jaar)]
hybianlb <- hybianlb[paste0(EAGIDENT,jaar) %in% anlbeag$eagjaar,]
# filter by water type
hybianlb <- hybianlb[!watertype %in% c('M20','M27', 'M6b'),]
anlbhybi <- hybianlb

# for spatial check
hybianlb <- st_as_sf(hybianlb, coords = c("XCOORD","YCOORD"), crs = 28992)
geohybianlb <- hybianlb[hybianlb$parameter == "SUBMSPTN",
              c('locatie','jaar','anlb','njaaranlb','beheer','geometry')]
geohybianlb <- st_as_sf(geohybianlb)
st_write(geohybianlb, 'geoanlbhybi.gpkg', append=FALSE)

# ============================================================================
# CONTROLE: VERDELING OVER BEHEERTYPES
# ============================================================================

cat("\n========================================")
cat("\nVERDELING BEHEERTYPES")
cat("\n========================================\n")

# Totaal aantal monsters per beheertype
setDT(anlbhybi)
beheer_verdeling <- anlbhybi[, .N, by = .(beheer, anlb)][order(-N)]
beheer_verdeling[, percentage := round(N / sum(N) * 100, 1)]
print(beheer_verdeling)

```

```{r data enrichment anlbhybi}
#| label: data enrich anlbhybi
setDT(anlbhybi)
n_soort_sub <- anlbhybi[compartiment == 'EZ' & parameterid == 'PTN_BEDKG_%' & parameter == "", uniqueN(biotaxonnaam[submers == 1]), by = c('monsterident','locatie','jaar','compartiment')]
setnames(n_soort_sub, "V1", "n_soort_sub")
n_soort_sub[,n_soort_sub := n_soort_sub - 1]
n_soort_ems <- anlbhybi[compartiment == 'EZ' & parameterid == 'PTN_BEDKG_%' & parameter == "", uniqueN(biotaxonnaam[emers == 1]),by = c('monsterident','locatie','jaar','compartiment')]
setnames(n_soort_ems, "V1", "n_soort_ems")
n_soort_ems[,n_soort_ems := n_soort_ems - 1]
n_soort_oever <- anlbhybi[compartiment == 'OR' & parameterid == 'PTN_BEDKG_%' & parameter == "", uniqueN(biotaxonnaam),by = c('monsterident','locatie','jaar','compartiment')]
setnames(n_soort_oever, "V1", "n_soort_oever")

# cast naar breed formaat, zodat locatie uniek is
anlbhybi_cast <- dcast(anlbhybi, EAGIDENT+locatie+monsterident+compartiment+watertype+jaar+anlb+njaaranlb+pakket_n_anlb+beheer+baggeren+bufferzone+nat.vriend.oever+slootschonen+water~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde', drop = TRUE)
# merge aantal soorten
anlbhybi_cast <- merge(anlbhybi_cast, n_soort_sub, by = c('monsterident','locatie','jaar','compartiment'), all.x = TRUE)
anlbhybi_cast <- merge(anlbhybi_cast, n_soort_ems, by = c('monsterident','locatie','jaar','compartiment'), all.x = TRUE)
anlbhybi_cast <- merge(anlbhybi_cast, n_soort_oever, by = c('monsterident','locatie','jaar','compartiment'), all.x = TRUE)
# add diepte doorzicht
anlbhybi_cast[,zichtdte := ZICHT_m_ZICHT_/ WATDTE_m_WATDTE_]
# correct submers met flab
anlbhybi_cast[`PTN_BEDKG_%_SUBMSPTN_` > `PTN_BEDKG_%_FLAB_SUBMS`, `PTN_BEDKG_%_SUBMSPTN_`:= `PTN_BEDKG_%_SUBMSPTN_`-`PTN_BEDKG_%_FLAB_SUBMS`]
# remove columns with only NA
anlbhybi_cast <- anlbhybi_cast[, which(unlist(lapply(anlbhybi_cast, function(x) !all(is.na(x))))), with = FALSE]
colnames(anlbhybi_cast)
# remove certain cols
anlbhybi_cast <- anlbhybi_cast[,-c("FOTO_n_FOTO_","PTN_BEDKG_%__DRIJVD","PTN_BEDKG_%__EMS","PTN_BEDKG_%__SUBMS","SLIBDTE_m_LINKSMDPTJT_SLIBDTE_","SLIBDTE_m_RECHTSMDPTJT_SLIBDTE_")]
# add values
anlbhybi_cast[is.na(njaaranlb), njaaranlb := 0]
anlbhybi_cast[is.na(pakket_n_anlb), pakket_n_anlb := 0]
anlbhybi_cast[is.na(baggeren), baggeren := 0]
anlbhybi_cast[is.na(bufferzone), bufferzone := 0]
anlbhybi_cast[is.na(nat.vriend.oever), nat.vriend.oever := 0]
anlbhybi_cast[is.na(slootschonen), slootschonen := 0]
anlbhybi_cast[is.na(water), water := 0]

```

```{r eag hybi enrichment}
#| label: EAGdata toevoegen
anlbhybi_cast <- merge(anlbhybi_cast, EAG, by.x = 'EAGIDENT',by.y = 'Code', all.x = T)
anlbhybi_cast[, rel_water := Water_m2/EAG_m2*100]
```

```{r add bodemdata anlbhybi}
#| label: add bodemdata anlbhybi
# bodemdata toevoegen
# bodemschat
hybiloc_bs <- st_join(hybiloc, st_buffer(bs6, dist = 5), left = TRUE, largest = TRUE)

# bodemchemie
loc_bod <- unique(bodchem[!is.na(XCOORD) & !is.na(YCOORD), c("locatie","EAGIDENT","XCOORD","YCOORD")])
loc_bod <- st_as_sf(loc_bod, coords = c("XCOORD","YCOORD"), crs = 28992)

# Process each hybiloc point to find the nearest loc_bod in the same EAGIDENT

# Function to find nearest point within same EAGIDENT
find_nearest_in_same_eag <- function(point_sf, candidates_sf) {
  # Get the EAGIDENT of the current point
  current_eag <- point_sf$EAGIDENT[1]
  
  # Filter candidates to only those in the same EAGIDENT
  same_eag <- candidates_sf[candidates_sf$EAGIDENT == current_eag, ]
  
  # If no points in the same EAGIDENT, return NA
  if (nrow(same_eag) == 0) {
    return(NA)
  }
  
  # Calculate distances
  dists <- st_distance(point_sf, same_eag)
  
  # Find index of minimum distance
  min_idx <- which.min(dists[1,])
  
  # Return the nearest point
  return(same_eag[min_idx, ])
}

# Create new data frame to store results
matches <- data.frame(
  hybi_locatie = character(),
  hybi_eagident = character(),
  loc_bod_locatie = character(),
  distance = numeric(),
  stringsAsFactors = FALSE
)

# Process each hybi point
for (i in 1:nrow(hybiloc_bs)) {
  cat("Processing", i, "of", nrow(hybiloc_bs), "\r")
  
  # Get current point
  current_point <- hybiloc_bs[i, ]
  
  # Find nearest loc_bod in same EAGIDENT
  nearest_bod <- find_nearest_in_same_eag(current_point, loc_bod)
  
  # If match found, store it
  if (!is.na(nearest_bod)[1]) {
    dist <- st_distance(current_point, nearest_bod)
    matches <- rbind(matches, data.frame(
      hybi_locatie = current_point$locatie,
      hybi_eagident = current_point$EAGIDENT,
      loc_bod_locatie = nearest_bod$locatie,
      distance = as.numeric(dist),
      stringsAsFactors = FALSE
    ))
  }
}

# Convert to data.table for efficiency
matches <- as.data.table(matches)

# Join the matched data back to the hybi dataset
hybiloc_with_bod <- merge(
  as.data.table(st_drop_geometry(hybiloc_bs)),
  matches,
  by.x = c("locatie", "EAGIDENT"),
  by.y = c("hybi_locatie", "hybi_eagident"),
  all.x = TRUE
)

# Now you can join this with your anlbhybi_cast data
anlbhybi_bod <- merge(
  anlbhybi_cast,
  hybiloc_with_bod,
  by.x = c("locatie"),
  by.y = c("locatie"),
  all.x = TRUE,
  suffixes = c("", "_bodchem_loc")
)

# Check how many matches we got
cat("Found matches for", uniqueN(matches$loc_bod_locatie), "out of", nrow(loc_bod), "soil chemistry locations\n")
cat("These matches correspond to", uniqueN(matches$hybi_locatie), "hydrological locations\n")

# Now merge the soil chemistry data (let op dubbele jaren per locatie)
anlbhybi_bod <- merge(
  anlbhybi_bod,
  baggernut,
  by.x = c("loc_bod_locatie"),
  by.y = c("locatie"),
  all.x = TRUE,
  suffixes = c("", "_bodchem")
)

# correct locations with more than one year bodchem
anlbhybi_bod[,n_jaar_bodchem := uniqueN(jaar_bodchem), by = locatie]
check <- anlbhybi_bod[n_jaar_bodchem > 1, .(locatie, jaar, jaar_bodchem, n_jaar_bodchem)]
anlbhybi_bod <- anlbhybi_bod[!(n_jaar_bodchem > 1 & jaar_bodchem == 2013),]


```

```{r add pvskp}
#| label: add pvskp
anlbhybi_bod[,GAFIDENT := sapply(strsplit(EAGIDENT, '-'), `[`, 1)]
anlbhybi_bod[,GAFIDENT := as.numeric(GAFIDENT)]
pvskp[,GAFIDENT := as.numeric(GAFident)]
pvskp <- pvskp[!is.na(GAFIDENT) & !grepl('EAG', GAF),]
anlbhybi_bod <- merge(anlbhybi_bod, pvskp, by.x = 'GAFIDENT', by.y = 'GAFIDENT', all.x = TRUE)

```

### Skenjesloot

```{r sjs data npakket}
#| label:  dat ppr skenjesloot
# add aantal paketten
npakket <- skenjesloot[,sum(meetwaarde[grepl('^BEHPK', parameterid) | parameterid == 'BEHRPKNVO_SOORT'], na.rm = TRUE), by = c('monsterident','externereferentie','jaar')]
npakket[,parameterid := 'BEHP_AANWZG']
npakket[,parameter := 'pktaanwez']
npakket[,naam := 'aantal beheerpakketten']
npakket[,meetwaarde := V1]
skenjesloot <- rbindlist(list(skenjesloot,npakket), fill = TRUE)
```

```{r sjsloc aggregeren}

#| label: locaties aggregeren binnen een afstand van 150 meter op zelfde 1.5 meter gebufferde perceel 
skenjeslootloc <- unique(skenjesloot[,c("externereferentie","jaar","xcoormonster","ycoormonster")])
skenjeslootloc[,ident:= paste0(xcoormonster,"_",ycoormonster)]
skenjeslootloc <-skenjeslootloc[!is.na(xcoormonster),]
skenjeslootloc <- st_as_sf(skenjeslootloc,coords = c("xcoormonster","ycoormonster"),crs = 28992) #2182
skenjeslootloc <- st_join(skenjeslootloc, st_buffer(brpagv[!(brpagv$category == 'Landschapselement'),!names(brpagv) %in% "jaar"], dist = 5), left = TRUE, largest = TRUE)
setDT(skenjeslootloc)
check<- unique(skenjeslootloc[is.na(skenjeslootloc$ref_id),c("externereferentie",'ident','jaar','ref_id')])
skenjeslootloc[,brp_nr := rep(seq_len(.N), each = 1, length.out = .N), by = 'ref_id']
skenjeslootloc[,dist := st_distance(geometry[brp_nr == 1], geometry), by ='ref_id']
skenjeslootloc[,dist := as.numeric(dist)]
sslocmatch <- skenjeslootloc[brp_nr == 1,]
skenjeslootloc <- merge(skenjeslootloc, sslocmatch[,c('externereferentie','ref_id', 'jaar')], by = 'ref_id', suffixes = c('','_match'), all.x = TRUE, all.y = FALSE)
# combine locs within 100 meter on same brp gewasperceel in verschillende jaren (soms zijn het wel andere sloten)
skenjeslootloc[, id := externereferentie]
skenjeslootloc[dist < 150 & !(jaar == jaar_match), id := externereferentie_match]

```

```{r sjs loc join eag}
#| label:  join with EAG
skenjeslootloc <- st_as_sf(skenjeslootloc)
skenjeslootloc <- st_join(skenjeslootloc, EAG, left = TRUE, largest = TRUE)
skenjeslootloc <- merge(skenjeslootloc, npakket[,c('externereferentie','jaar','meetwaarde')], by = c('externereferentie','jaar'), suffixes = c('','_loc'), all.x = TRUE)
# export
skenjeslootloc <- st_as_sf(skenjeslootloc)
st_write(skenjeslootloc, 'output/skenjeslootloc.gpkg', append = FALSE)
# check in GIS door te kleuren op nieuwe locatiecode
# check als tabel/plot
setDT(skenjeslootloc)
skenjeslootloc[, nmeetjaar := uniqueN(jaar), by = 'id']
# merge new id with data
skenjesloot <- merge(skenjesloot,skenjeslootloc[,c('externereferentie','jaar','Code','nmeetjaar')], by = c('externereferentie','jaar'), suffixes = c('','_loc'), all.x = TRUE)
```

```{r sjs beheer toevoegen}
#| label: create table with beheer
sjs_beheer <- unique(skenjesloot[(grepl('^BEHPK', parameterid) | parameterid == 'BEHRPKNVO_SOORT') & meetwaarde == 1 , c('externereferentie','jaar','pakket_agg')])
# afrastering
sjs_beheer_2 <- unique(skenjesloot[parameterid=='OEVBSIG_SOORT'& meetwaarde %in% c(53,59,56,57),c('externereferentie','jaar','pakket_agg')])
sjs_beheer_2[,pakket_agg:='afrastering']
#samenvoegen
sjs_beheer <-rbind(sjs_beheer,sjs_beheer_2)
# format
sjs_beheer <- dcast(sjs_beheer, externereferentie+jaar~pakket_agg)
# PERODSLSSNG_mnd en 	PERODSLSBGODHD_a
sjs_beheer_3 <- dcast(skenjesloot[parameterid%in%c('PERODSLSSNG_mnd','PERODSLSBGODHD_a','BAGGEREN5JAAR','SCHONEN5JAAR','TYPESLSSNG'),],externereferentie+jaar~parameterid, value.var = 'meetwaarde', fun.aggregate = mean)
sjs_beheer <- merge(sjs_beheer,sjs_beheer_3, by = c('externereferentie','jaar'), all = TRUE)
# add 1 type beheer combi
sjs_beheer[,beheer := paste0(afrastering,'_',baggeren,'_',schonen,'_',nvo), by = externereferentie]
sjs_beheer[,beheer := gsub('_NA','',beheer)]
sjs_beheer[,beheer := gsub('NA_','',beheer)]
sjs_beheer[is.na(beheer)|beheer =='NA'& is.na(rand) & is.na(water), beheer:= 'regulier']
sjs_beheer[is.na(beheer)|beheer =='NA', beheer:= 'randen']
# merge with data
ss_beheer <- merge(skenjesloot, sjs_beheer, by =c('externereferentie','jaar'), suffixes = c('','_beheer'), all.x = TRUE)
ss_beheer[is.na(beheer)|beheer =='NA',beheer:= 'regulier']
# add label wel/niet beheer
ss_beheer[,welnietbeheer:= 'ja']
ss_beheer[beheer%in% c('regulier','overig'),welnietbeheer:= 'nee']
# check beheer
checknobs <- dcast(ss_beheer, value.var = 'externereferentie', fun.aggregate = uniqueN,jaar~beheer)
checknobs <- ss_beheer[,uniqueN(externereferentie),by =c('jaar','beheer' )]
fwrite(checknobs, file= paste0('skenjesloot_npakket.csv'), sep = ';', dec ='.', )

# Select only samples with matching grouping variables (same EAG, same year)
# This ensures we only compare locations within the same EAG where both treatment and control exist

match_samples <- ss_beheer[, .(has_both = uniqueN(welnietbeheer) == 2), by = .(Code, jaar)]
match_samples <- match_samples[has_both == TRUE]
ss_beheer <- ss_beheer[paste0(Code, jaar) %in% paste0(match_samples$Code, match_samples$jaar)]
ss_beheer <- ss_beheer[!is.na(Code) ,]

```

```{r merge sjs anlb}
#| label: merge anlb sjs
# spatial merge met buffer van 1 meter rond pakketten
# check if all sken je sloot are present and multiple anlb possible
skenjeslootloc <- st_as_sf(skenjeslootloc)
anlb <- st_as_sf(anlb)
anlbsjs <- st_join(skenjeslootloc, st_buffer(anlb[,!names(anlb)%in% c('id')], dist = 8), left = TRUE)
# Extract coordinates as a matrix
coords <- st_coordinates(anlbsjs)
setDT(anlbsjs)
anlbsjs <- cbind(anlbsjs, coords)
anlbsjs[,jaar_sjs := jaar.x];anlbsjs[,jaar_anlb := jaar.y];anlbsjs[,jaar.x:=NULL];anlbsjs[,jaar.y:=NULL]
anlbsjs[!(jaar_sjs == jaar_anlb), c('pakket','pakket2','pakket3') := list(NA,NA,NA)]
anlbsjs_cast <- dcast(anlbsjs, externereferentie+X+Y+id+jaar_sjs+ref_id+dist+Code.x+WtypeBR~pakket3, fun.aggregate = uniqueN, value.var = 'pakket')
anlbsjs_cast[,pakket_n_anlb := rowSums(.SD, na.rm = TRUE), .SDcols = c('baggeren','bufferzone','nat.vriend.oever','slootschonen','water')]
# merge met beheer info sken je sloot
anlbsjs_cast <- merge(anlbsjs_cast, sjs_beheer, by.x = c('externereferentie', 'jaar_sjs'), by.y = c('externereferentie', 'jaar'), all.x = T, suffixes = c('anlb','sjs'))

# for spatial check
# check wel niet beheer 'ja' en anlb = nee
geoanlbsjs <- unique(anlbsjs_cast[, c('externereferentie','jaar_sjs','beheer','afrastering','baggerensjs','nvo','rand','schonen','pakket_n_anlb', 'baggerenanlb','bufferzone','nat.vriend.oever','slootschonen','wateranlb',"X","Y")])
geoanlbsjs <- st_as_sf(geoanlbsjs[!is.na(X),], coords = c("X","Y"), crs = 28992)
st_write(geoanlbsjs, 'output/geoanlbsjs.gpkg', append=FALSE)
```

### Conclusie data

Omdat er nog steeds data ontbreekt in de skenjesloot data, de hoeveelheid monsters die geschikt is voor analyse beperkt is en ik twijfels heb over de kwaliteit van de gegevens, denk ik dat het beter is om de diepgaande XGBoost (machine learning) analyse alleen uit te voeren met de geografische bestanden van ANLB en data van Waterproef. De sken je sloot data wordt wel gerapporteerd in figuren, waarmee het onderstaande wordt onderbouwd.

In de skenjesloot data zijn maar weinig monsters verzameld op locaties waar alléén afrastering is (45 in 8 jaar) geplaatst of aléén is geschoond (165 in 8 jaar) en de baggerfrenquentie is niet bepaald op locaties waar geen pakketten zijn afgesloten. De hoeveelheid geschikte monsters wordt verder beperkt door de beschikbaarheid van monsters binnen eenzelfde watersysteem en meetjaar waar het beheer zowel wel als niet is aangepast. 

We zien ook weinig effect van beheer op de gemeten vegetatie in de data van skenjesloot. We zien een klein positief effect van afrastering en schonen op de emerse- en submerse vegetatiebedekking en een negatief effect van baggeren en combinaties van baggeren met andere pakketten. Wat wel te zien is, is dat de waterdiepte groter is op de meeste locaties met beheerpakketten en dat doorzicht/ waterdiepte (lichtklimaat) hoger is op locaties met beheerpakketten. 

Dilemma: ook in data van Waterproef zie ik weinig effect en blijven er uiteindelijk weinig monsterlocaties over als ik alleen kijk naar wel/ geen beheer in dezelfde EAG's. In deze data hebben we geen info over afrastering en het aantal jaren gelden dat er voor het laatst gebaggerd is (omdat dit niet uit pakketten is af te leiden). Daarnaast is de vraag hoe betrouwbaar de informatie is over de aanwezigheid van beheerpakketten en hoe onderscheidend dit is voor het werkelijk uitgevoerde beheer. 

Missende data:
- biotaxonnaam is NA, behalve in 2017 en 2021 (dit was niet zo in eerdere geleverde datasets)
- deelnemers (namen/ id) staan niet in de data geleverd
- het aantal unieke waarnemingen van de meeste parameters (beheerpakketten, vegetatiebedekking) is gelijk in 2020, 2021 en 2022. Deze aantallen komen niet overeen met het aantal bemonsterde sloten in de app/ data viewer en eerder geleverde data. Het lijkt erop alsof er data mist of juist dubbel is gerapporteerd
- data uit 2017 ontbreekt

Vragen over de data:
- geen biotaxa in de data van 2023 en 2024, zijn er in deze jaren geen biotaxa bepaald?
- klopt het dat laatste jaar gebaggerd en geschoond niet is ingevuld als er geen anlb pakket is aangevinkt?
- hoe is omgegeaan met het gerapporteerde getal bij "het aantal jaren geleden dat er voor het laatst is gebaggerd of geschoond". Gaat het om het aantal jaren voorafgaand aan de bemonstering of het aantal jaren voorafgaand aan een jaar dat baggeren op de planning staat of er een pakket is afgesloten (ook als de monitoring voorafgaand aan het uitvoeren van baggeren plaatsvindt)?

Fouten in geleverde data:
- meetwaarden waterdiepte, slibdikte (alles met eenheid m) is een factor 100 te groot in data van 2023 en 2024
-	het datumformaat in bestanden 2018 t/m 2022 is niet uniform (soms eerst jaar-maand-dag dan weer dag-maand-jaar), zelfs niet binnen één bestand van één meetjaar
-	datum ontbreekt bij veel records in 2019
- meetwaarden zijn niet altijd nummeriek; wenselijker is om ennumeraties of waardenbereiken te gebruiken (bijvoorbeeld bij laatste keer gebaggerd of geschoond, ander beheerpakket en type/machine schonen). Er zijn eerder afspraken gemaakt over te hanteren enumeraties
- er worden soms punten en soms komma's gebruikt als decimaalteken in meetwaarden

Twijfels kwaliteit data sken je sloot:
- het valt op dat er geen relatie is tussen de gemeten waterdiepte en de vegetatiebedekking. Dit roept vragen op over de kwaliteit van de data, omdat deze relatie wel wordt verwacht en wel zichtbaar is in de data die door Waterproef is verzameld
- ik heb er twijfels over of antwoorden/ meetwaarden altijd op dezlfde manieren geïnterpreteerd zijn, nu staat er bij sommige monsters met beheerpakket baggeren dat er 0, 1, 2 of 5 jaar geleden voor het laatst is gebaggerd; wat betekent het als er een getal 0 of 5 staat? In welk geval is er gebaggerd voorafgaand en wanneer in hetzelfde jaar, maar pas na het uitvoeren van skjesloot, als de monitoring?

Toekennen van beheer aan monsterlocaties:
Het valt op dat de gerapporteerde beheerpakketten in skenjesloot in veel gevallen niet overeen komen met de door de collectieven aangeleverde geografische informatie over de ligging van afgesloten beheerpakketten
  - er staan regematig natuur vriendelijke oevers in sken je sloot die niet in de anlb pakketten voorkomen. Komt dit omdat er geen vergoeding is voor het beheer van natuurvriendelijke oevers?
  - er staan regematig verschillende beheerpakketten in sken je sloot, terwijl er geen enkel anlb pakketten is afgesloten. Welke data is het meest representatief voor het werkelijke beheer?
  - er staan regelmatig verschillende beheerpakketen in sken je sloot en anlb. Bijvoorbeeld 2510-EAG-1, 2630-EAG-1, 6430-EAG-1, 2501-EAG-2, 2400-EAG-. Vooral beheerpakket baggeren komt niet overeen. Voor een analyse is het essentieel dat de toekenning van beheer aan meetlocaties correct is en beide bronnen geven een andere toekenning (de één schonen en de ander baggeren). Is het een idee om een aantal voorbeelden met collectieven te bespreken om te achterhalen welke data het meest representatief is voor het werkelijke beheer?

## visualisatie

### Anlb

```{r anlb}
#| label: anlb n pakket by brp
# overzichttabel obv csv bestanden
brp_anlb <- st_join( brpagv, anlb, left = TRUE, largest = TRUE)
setDT(brp_anlb)
ov_anlb <- dcast(brp_anlb, pakket2+pakket3+collectief~jaar.y, fun.aggregate = uniqueN, value.var = 'ref_id.x')
fwrite(ov_anlb, file= paste0('ov_anlb.csv'), sep = ';', dec ='.', )

npakket <- dcast(anlb, ref_id+jaar~., fun.aggregate = uniqueN, value.var = 'pakket')

ggplot(data = npakket)+
  geom_bar(aes(x = jaar, fill = as.factor(`.`)), 
           position = 'stack') +
  scale_fill_discrete(labels = c('1 pakket','2 pakketten','3 pakketten','4 pakketten','5 pakketten','6 pakketten','7 pakketten','8 pakketten'))+
  guides(fill=guide_legend(title=''))+
  scale_x_continuous(n.breaks = 8, labels = scales::number_format(accuracy = 1, big.mark = ''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Anlb beheerpakketten per brp eenheid") +
    labs(x="",y="aantal percelen")


```

```{r anlb hybi}
ov_anlb <- dcast(anlbhybi, locatie~jaar, fun.aggregate = uniqueN, value.var = 'pakket2')
fwrite(ov_anlb, file= paste0('ov_anlb.csv'), sep = ';', dec ='.', )
```

### Hybi - parameters

```{r overview hybi}
#| label: overview hybi
# overzichttabel obv csv bestanden
ov_hybi <- dcast(anlbhybi, parameterid+parameter+compartiment+watertype~jaar, fun.aggregate = uniqueN, value.var = 'locatie')
colnames(anlbhybi)
fwrite(ov_hybi, file= paste0('hybi_pars.csv'), sep = ';', dec ='.', )
```

```{r vegelijking emers, submers wel en geen pakket}
# Bereid data voor - gebruik hybianlb in plaats van anlbhybi voor meetgegevens
# Filter eerst de juiste data met parameterid
setDT(hybianlb)
hybianlb[beheer == 'water', anlb := 'ja']
# Bereken aantal observaties per groep
hybianlb[watertype %in% c('M10','M1a','M8'), 
         n_obs := uniqueN(monsterident), 
         by = c('parameterid','parameter','compartiment','beheer')]
# Tel hoeveel unieke beheertypen je hebt
hybianlb <- hybianlb[n_obs > 9, ]

# 1. Emerse bedekking
anlb_emers_data <- hybianlb[parameterid == 'PTN_BEDKG_%' & parameter == 'EMSPTN' & anlb %in% c('ja', 'nee')]
anlb_emers_cast <- dcast(anlb_emers_data, 
                         EAGIDENT + jaar ~ anlb, 
                         value.var = 'meetwaarde', 
                         fun.aggregate = mean)

# 2. Submerse bedekking
anlb_submers_data <- hybianlb[parameterid == 'PTN_BEDKG_%' & parameter == 'SUBMSPTN' & anlb %in% c('ja', 'nee')]
anlb_submers_cast <- dcast(anlb_submers_data, 
                           EAGIDENT + jaar ~ anlb, 
                           value.var = 'meetwaarde', 
                           fun.aggregate = mean)

# 3. Voor aantal soorten: bereken eerst per monster
n_soort_ems_data <- hybianlb[compartiment == 'EZ' & anlb %in% c('ja', 'nee'), 
                              .(n_soort_ems = uniqueN(biotaxonnaam[emers == 1]) - 1), 
                              by = .(monsterident, EAGIDENT, jaar, anlb, beheer)]

anlb_emers_soorten_cast <- dcast(n_soort_ems_data, 
                                 EAGIDENT + jaar ~ anlb , 
                                 value.var = 'n_soort_ems', 
                                 fun.aggregate = mean)

# ggplot(anlb_emers_soorten_cast)+
#   geom_boxplot(aes(y= ja, x = 'wel pakket'))+
#   geom_boxplot(aes(y= nee, x= 'geen pakket'))
# ggplot(n_soort_ems_data)+
#   geom_boxplot(aes(y= n_soort_ems, x = beheer, fill = anlb))

# 4. Submerse soorten
n_soort_sub_data <- hybianlb[compartiment == 'EZ' & anlb %in% c('ja', 'nee'), 
                              .(n_soort_sub = uniqueN(biotaxonnaam[submers == 1]) - 1), 
                              by = .(monsterident, EAGIDENT, jaar, anlb, beheer)]

anlb_submers_soorten_cast <- dcast(n_soort_sub_data, 
                                   EAGIDENT + jaar ~ anlb, 
                                   value.var = 'n_soort_sub', 
                                   fun.aggregate = mean)

# Bereken R² voor elk paneel - NA DCAST, anders bestaan kolommen nog niet
complete_cases_emers <- anlb_emers_cast[!is.na(nee) & !is.na(ja)]
r2_emers <- if(nrow(complete_cases_emers) > 0) {
  cor(complete_cases_emers$nee, complete_cases_emers$ja, use = "complete.obs")^2
} else { NA }

complete_cases_submers <- anlb_submers_cast[!is.na(nee) & !is.na(ja)]
r2_submers <- if(nrow(complete_cases_submers) > 0) {
  cor(complete_cases_submers$nee, complete_cases_submers$ja, use = "complete.obs")^2
} else { NA }

complete_cases_emers_soorten <- anlb_emers_soorten_cast[!is.na(nee) & !is.na(ja)]
r2_emers_soorten <- if(nrow(complete_cases_emers_soorten) > 0) {
  cor(complete_cases_emers_soorten$nee, complete_cases_emers_soorten$ja, use = "complete.obs")^2
} else { NA }

complete_cases_submers_soorten <- anlb_submers_soorten_cast[!is.na(nee) & !is.na(ja)]
r2_submers_soorten <- if(nrow(complete_cases_submers_soorten) > 0) {
  cor(complete_cases_submers_soorten$nee, complete_cases_submers_soorten$ja, use = "complete.obs")^2
} else { NA }

# Okabe-Ito kleurenpalet
okabe_colors <- palette.colors(palette = "Okabe-Ito")

# Gemeenschappelijk thema
common_theme <- theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    axis.title.x = element_text(size = 12, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 12, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 11, color = "gray40"),
    axis.text.y = element_text(size = 11, color = "gray40"),
    legend.position = "bottom",
    legend.title = element_text(size = 11, face = "bold", color = "gray30"),
    legend.text = element_text(size = 10, color = "gray40"),
    legend.key.size = unit(0.8, "cm"),
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    plot.margin = margin(10, 10, 10, 10)
  )

# Plot 1: Emerse bedekking
p1 <- ggplot(data = anlb_emers_cast) +
  geom_jitter(aes(x = nee, y = ja, color = as.factor(jaar)), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, linetype = "dashed", color = "Black", linewidth = 0.5) +
  annotate("text", x = 5, y = 95, 
           label = paste0("R² = ", round(r2_emers, 3)),
           size = 4, hjust = 0, fontface = "bold") +
  scale_color_manual(values = okabe_colors, name = "Meetjaar") +
  xlim(0, 100) + ylim(0, 100) +
  labs(title = "Emerse bedekking",
       x = "Geen beheerpakket (%)",
       y = "Wel beheerpakket (%)") +
  common_theme

# Plot 2: Submerse bedekking
p2 <- ggplot(data = anlb_submers_cast) +
  geom_jitter(aes(x = nee, y = ja, color = as.factor(jaar)), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, linetype = "dashed", color = "Black", linewidth = 0.5) +
  annotate("text", x = 5, y = 95, 
           label = paste0("R² = ", round(r2_submers, 3)),
           size = 4, hjust = 0, fontface = "bold") +
  scale_color_manual(values = okabe_colors, name = "Meetjaar") +
  xlim(0, 100) + ylim(0, 100) +
  labs(title = "Submerse bedekking",
       x = "Geen beheerpakket (%)",
       y = "Wel beheerpakket (%)") +
  common_theme

# Plot 3: Emerse soorten
p3 <- ggplot(data = anlb_emers_soorten_cast) +
  geom_jitter(aes(x = nee, y = ja, color = as.factor(jaar)), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, linetype = "dashed", color = "Black", linewidth = 0.5) +
  annotate("text", x = 1, y = max(anlb_emers_soorten_cast$ja, na.rm = TRUE) * 0.95, 
           label = paste0("R² = ", round(r2_emers_soorten, 3)),
           size = 4, hjust = 0, fontface = "bold") +
  scale_color_manual(values = okabe_colors, name = "Meetjaar") +
  labs(title = "Aantal emerse soorten",
       x = "Geen beheerpakket ",
       y = "Wel beheerpakket ") +
  common_theme



# Plot 4: Submerse soorten
p4 <- ggplot(data = anlb_submers_soorten_cast) +
  geom_jitter(aes(x = nee, y = ja, color = as.factor(jaar)), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, linetype = "dashed", color = "Black", linewidth = 0.5) +
  annotate("text", x = 1, y = max(anlb_submers_soorten_cast$ja, na.rm = TRUE) * 0.95, 
           label = paste0("R² = ", round(r2_submers_soorten, 3)),
           size = 4, hjust = 0, fontface = "bold") +
  scale_color_manual(values = okabe_colors, name = "Meetjaar") +
  labs(title = "Aantal submerse soorten",
       x = "Geen beheerpakket ",
       y = "Wel beheerpakket ") +
  common_theme

# Combineer alle plots
library(gridExtra)
grid.arrange(p1, p2, p3, p4, ncol = 2,
             top = grid::textGrob("Effect anlb-beheerpakketten op vegetatie", 
                                 gp = grid::gpar(fontsize = 16, fontface = "bold")))

# Sla de gecombineerde figuur op
ggsave("anlb_hybi_vegetatie_vergelijking.png", 
       arrangeGrob(p1, p2, p3, p4, ncol = 2,
                   top = grid::textGrob("Effect beheerpakketten op vegetatie", 
                                       gp = grid::gpar(fontsize = 16, fontface = "bold"))),
       width = 14, height = 12, units = "in", dpi = 300)


```

```{r voeg paired t test toe}
# ============================================================================
# BEREID DATA VOOR - VOEG PAIRED T-TESTS TOE
# ============================================================================

# Functie voor paired t-test en significantie labeling
perform_paired_ttest <- function(data_cast, col_ja, col_nee) {
  # Filter complete cases
  complete <- data_cast[!is.na(get(col_ja)) & !is.na(get(col_nee))]
  
  if(nrow(complete) < 3) {
    return(list(
      p_value = NA,
      sig_label = "Onvoldoende data",
      mean_diff = NA,
      n = nrow(complete)
    ))
  }
  
  # Paired t-test
  test_result <- t.test(complete[[col_ja]], complete[[col_nee]], paired = TRUE)
  
  # Significantie label
  sig_label <- case_when(
    test_result$p.value < 0.001 ~ "***",
    test_result$p.value < 0.01 ~ "**",
    test_result$p.value < 0.05 ~ "*",
    TRUE ~ "ns"
  )
  
  return(list(
    p_value = test_result$p.value,
    sig_label = sig_label,
    mean_diff = mean(complete[[col_ja]] - complete[[col_nee]]),
    n = nrow(complete),
    t_stat = test_result$statistic,
    ci_lower = test_result$conf.int[1],
    ci_upper = test_result$conf.int[2]
  ))
}

# Bereken R² EN paired t-test voor elk paneel
complete_cases_emers <- anlb_emers_cast[!is.na(nee) & !is.na(ja)]
r2_emers <- if(nrow(complete_cases_emers) > 0) {
  cor(complete_cases_emers$nee, complete_cases_emers$ja, use = "complete.obs")^2
} else { NA }
ttest_emers <- perform_paired_ttest(anlb_emers_cast, "ja", "nee")

complete_cases_submers <- anlb_submers_cast[!is.na(nee) & !is.na(ja)]
r2_submers <- if(nrow(complete_cases_submers) > 0) {
  cor(complete_cases_submers$nee, complete_cases_submers$ja, use = "complete.obs")^2
} else { NA }
ttest_submers <- perform_paired_ttest(anlb_submers_cast, "ja", "nee")

complete_cases_emers_soorten <- anlb_emers_soorten_cast[!is.na(nee) & !is.na(ja)]
r2_emers_soorten <- if(nrow(complete_cases_emers_soorten) > 0) {
  cor(complete_cases_emers_soorten$nee, complete_cases_emers_soorten$ja, use = "complete.obs")^2
} else { NA }
ttest_emers_soorten <- perform_paired_ttest(anlb_emers_soorten_cast, "ja", "nee")

complete_cases_submers_soorten <- anlb_submers_soorten_cast[!is.na(nee) & !is.na(ja)]
r2_submers_soorten <- if(nrow(complete_cases_submers_soorten) > 0) {
  cor(complete_cases_submers_soorten$nee, complete_cases_submers_soorten$ja, use = "complete.obs")^2
} else { NA }
ttest_submers_soorten <- perform_paired_ttest(anlb_submers_soorten_cast, "ja", "nee")

# ============================================================================
# PLOTS MET T-TEST RESULTATEN (MET ORIGINELE KLEUREN)
# ============================================================================

# Okabe-Ito kleurenpalet
okabe_colors <- palette.colors(palette = "Okabe-Ito")

# Gemeenschappelijk thema
common_theme <- theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    axis.title.x = element_text(size = 12, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 12, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 11, color = "gray40"),
    axis.text.y = element_text(size = 11, color = "gray40"),
    legend.position = "bottom",
    legend.title = element_text(size = 11, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(0.8, "cm"),
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    plot.margin = margin(10, 10, 10, 10)
  )


# Plot 1: Emerse bedekking
p1 <- ggplot(data = anlb_emers_cast) +
  geom_jitter(aes(x = nee, y = ja, color = as.factor(jaar)), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, linetype = "dashed", color = "Black", linewidth = 0.5) +
  annotate("text", x = 5, y = 85, 
           label = paste0("R² = ", round(r2_emers, 3), "\n",
                         "p ", ifelse(ttest_emers$p_value < 0.001, "< 0.001", 
                                     paste("=", round(ttest_emers$p_value, 3))), " ", 
                         ttest_emers$sig_label, "\n",
                         "Δ = ", round(ttest_emers$mean_diff, 1), "%"),
           size = 4, hjust = 0, fontface = "bold", color = "black") +
  scale_color_manual(values = okabe_colors, name = "Meetjaar") +
  xlim(0, 100) + ylim(0, 100) +
  labs(title = "Emerse bedekking",
       subtitle = paste0("n = ", ttest_emers$n, " gebieden"),
       x = "Geen beheerpakket (%)",
       y = "Wel beheerpakket (%)") +
  common_theme

# Plot 2: Submerse bedekking
p2 <- ggplot(data = anlb_submers_cast) +
  geom_jitter(aes(x = nee, y = ja, color = as.factor(jaar)), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, linetype = "dashed", color = "Black", linewidth = 0.5) +
  annotate("text", x = 5, y = 85, 
           label = paste0("R² = ", round(r2_submers, 3), "\n",
                         "p ", ifelse(ttest_submers$p_value < 0.001, "< 0.001", 
                                     paste("=", round(ttest_submers$p_value, 3))), " ", 
                         ttest_submers$sig_label, "\n",
                         "Δ = ", round(ttest_submers$mean_diff, 1), "%"),
           size = 4, hjust = 0, fontface = "bold", color = "black") +
  scale_color_manual(values = okabe_colors, name = "Meetjaar") +
  xlim(0, 100) + ylim(0, 100) +
  labs(title = "Submerse bedekking",
       subtitle = paste0("n = ", ttest_submers$n, " gebieden"),
       x = "Geen beheerpakket (%)",
       y = "Wel beheerpakket (%)") +
  common_theme

# Plot 3: Emerse soorten
p3 <- ggplot(data = anlb_emers_soorten_cast) +
  geom_jitter(aes(x = nee, y = ja, color = as.factor(jaar)), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, linetype = "dashed", color = "Black", linewidth = 0.5) +
  annotate("text", x = 1, y = max(anlb_emers_soorten_cast$ja, na.rm = TRUE) * 0.85, 
           label = paste0("R² = ", round(r2_emers_soorten, 3), "\n",
                         "p ", ifelse(ttest_emers_soorten$p_value < 0.001, "< 0.001", 
                                     paste("=", round(ttest_emers_soorten$p_value, 3))), " ", 
                         ttest_emers_soorten$sig_label, "\n",
                         "Δ = ", round(ttest_emers_soorten$mean_diff, 1)),
           size = 4, hjust = 0, fontface = "bold", color = "black") +
  scale_color_manual(values = okabe_colors, name = "Meetjaar") +
  labs(title = "Aantal emerse soorten",
       subtitle = paste0("n = ", ttest_emers_soorten$n, " gebieden"),
       x = "Geen beheerpakket ",
       y = "Wel beheerpakket ") +
  common_theme

# Plot 4: Submerse soorten
p4 <- ggplot(data = anlb_submers_soorten_cast) +
  geom_jitter(aes(x = nee, y = ja, color = as.factor(jaar)), size = 3, alpha = 0.7) +
  geom_abline(slope = 1, linetype = "dashed", color = "Black", linewidth = 0.5) +
  annotate("text", x = 1, y = max(anlb_submers_soorten_cast$ja, na.rm = TRUE) * 0.85, 
           label = paste0("R² = ", round(r2_submers_soorten, 3), "\n",
                         "p ", ifelse(ttest_submers_soorten$p_value < 0.001, "< 0.001", 
                                     paste("=", round(ttest_submers_soorten$p_value, 3))), " ", 
                         ttest_submers_soorten$sig_label, "\n",
                         "Δ = ", round(ttest_submers_soorten$mean_diff, 1)),
           size = 4, hjust = 0, fontface = "bold", color = "black") +
  scale_color_manual(values = okabe_colors, name = "Meetjaar") +
  labs(title = "Aantal submerse soorten",
       subtitle = paste0("n = ", ttest_submers_soorten$n, " gebieden"),
       x = "Geen beheerpakket ",
       y = "Wel beheerpakket ") +
  common_theme

# ============================================================================
# COMBINEER PLOTS EN PRINT SAMENVATTING
# ============================================================================

# Combineer alle plots
grid.arrange(p1, p2, p3, p4, ncol = 2,
             top = grid::textGrob("Effect anlb-beheerpakketten op vegetatie", 
                                 gp = grid::gpar(fontsize = 16, fontface = "bold")))

# Print statistische samenvatting
cat("\n========================================")
cat("\nSTATISTISCHE SAMENVATTING (Paired t-tests)")
cat("\n========================================\n")

cat("\nEmerse bedekking:")
cat("\n  n paren:", ttest_emers$n)
cat("\n  Gemiddeld verschil:", round(ttest_emers$mean_diff, 2), "%")
cat("\n  95% CI: [", round(ttest_emers$ci_lower, 2), ",", round(ttest_emers$ci_upper, 2), "]")
cat("\n  t =", round(ttest_emers$t_stat, 3))
cat("\n  p-waarde:", ifelse(ttest_emers$p_value < 0.001, "< 0.001", round(ttest_emers$p_value, 4)))
cat("\n  Significantie:", ttest_emers$sig_label, "\n")

cat("\nSubmerse bedekking:")
cat("\n  n paren:", ttest_submers$n)
cat("\n  Gemiddeld verschil:", round(ttest_submers$mean_diff, 2), "%")
cat("\n  95% CI: [", round(ttest_submers$ci_lower, 2), ",", round(ttest_submers$ci_upper, 2), "]")
cat("\n  t =", round(ttest_submers$t_stat, 3))
cat("\n  p-waarde:", ifelse(ttest_submers$p_value < 0.001, "< 0.001", round(ttest_submers$p_value, 4)))
cat("\n  Significantie:", ttest_submers$sig_label, "\n")

cat("\nEmerse soorten:")
cat("\n  n paren:", ttest_emers_soorten$n)
cat("\n  Gemiddeld verschil:", round(ttest_emers_soorten$mean_diff, 2))
cat("\n  95% CI: [", round(ttest_emers_soorten$ci_lower, 2), ",", round(ttest_emers_soorten$ci_upper, 2), "]")
cat("\n  t =", round(ttest_emers_soorten$t_stat, 3))
cat("\n  p-waarde:", ifelse(ttest_emers_soorten$p_value < 0.001, "< 0.001", round(ttest_emers_soorten$p_value, 4)))
cat("\n  Significantie:", ttest_emers_soorten$sig_label, "\n")

cat("\nSubmerse soorten:")
cat("\n  n paren:", ttest_submers_soorten$n)
cat("\n  Gemiddeld verschil:", round(ttest_submers_soorten$mean_diff, 2))
cat("\n  95% CI: [", round(ttest_submers_soorten$ci_lower, 2), ",", round(ttest_submers_soorten$ci_upper, 2), "]")
cat("\n  t =", round(ttest_submers_soorten$t_stat, 3))
cat("\n  p-waarde:", ifelse(ttest_submers_soorten$p_value < 0.001, "< 0.001", round(ttest_submers_soorten$p_value, 4)))
cat("\n  Significantie:", ttest_submers_soorten$sig_label, "\n")

cat("\n========================================")
cat("\nSignificantie codes: *** p<0.001, ** p<0.01, * p<0.05, ns = niet significant")
cat("\n========================================\n")


```

```{r analyse verschillen submerse bedekking en soorten}
# Vervang eerst alle NA's door 0 in de pakket kolommen
pakket_cols <- c("baggeren", "slootschonen", "bufferzone", "nat.vriend.oever", "water")
hybianlb[, (pakket_cols) := lapply(.SD, function(x) fifelse(is.na(x), 0, x)), .SDcols = pakket_cols]

# Dan kun je de originele code gebruiken zonder na.rm = TRUE
pakketten_per_eag <- hybianlb[anlb == "ja", 
  .(pakketten = paste(unique(c(
    if(any(baggeren == 1)) "Baggeren",
    if(any(slootschonen == 1)) "Schonen",
    if(any(bufferzone == 1)) "Bufferzone",
    if(any(nat.vriend.oever == 1)) "NVO",
    if(any(water == 1)) "Water"
  )), collapse = " + ")),
  by = EAGIDENT
]

# 1. BEREID DATA VOOR - VOOR SUBMERSE SOORTEN
# ============================================================================

# Gebruik de cast data die we eerder hebben gemaakt
# Voor SOORTEN:
soorten_verschillen <- anlb_submers_soorten_cast[!is.na(nee) & !is.na(ja)]
soorten_verschillen[, verschil := ja - nee]

# Voor BEDEKKING:
bedekking_verschillen <- anlb_submers_cast[!is.na(nee) & !is.na(ja)]
bedekking_verschillen[, verschil := ja - nee]

# Bepaal threshold voor "groot verschil" (bijv. 1 standaarddeviatie)
threshold_soorten <- sd(soorten_verschillen$verschil, na.rm = TRUE)
threshold_bedekking <- sd(bedekking_verschillen$verschil, na.rm = TRUE)

cat("\nThreshold voor groot verschil:\n")
cat("Soorten:", round(threshold_soorten, 2), "\n")
cat("Bedekking:", round(threshold_bedekking, 10), "%\n")

# 2. IDENTIFICEER GEBIEDEN MET GROTE VERSCHILLEN
# ============================================================================

# Gebieden waar GEEN pakket beter is (voor soorten)
eag_meer_zonder_soorten <- soorten_verschillen[verschil < -threshold_soorten]

# Gebieden waar WEL pakket beter is (voor soorten)
eag_meer_met_soorten <- soorten_verschillen[verschil > threshold_soorten]

# Gebieden waar GEEN pakket beter is (voor bedekking)
eag_meer_zonder_bedekking <- bedekking_verschillen[verschil < -threshold_bedekking]

# Gebieden waar WEL pakket beter is (voor bedekking)
eag_meer_met_bedekking <- bedekking_verschillen[verschil > threshold_bedekking]

cat("\nAantal EAG's met grote verschillen:\n")
cat("Zonder pakket beter (soorten):", nrow(eag_meer_zonder_soorten), "\n")
cat("Met pakket beter (soorten):", nrow(eag_meer_met_soorten), "\n")
cat("Zonder pakket beter (bedekking):", nrow(eag_meer_zonder_bedekking), "\n")
cat("Met pakket beter (bedekking):", nrow(eag_meer_met_bedekking), "\n")

# 3. VOEG PAKKET INFORMATIE TOE
# ============================================================================

# Bepaal welke pakketten in elk EAG aanwezig zijn
pakketten_per_eag <- hybianlb[anlb == "ja", 
  .(pakketten = paste(unique(c(
    if(any(baggeren == 1)) "Baggeren",
    if(any(slootschonen == 1)) "Schonen",
    if(any(bufferzone == 1)) "Bufferzone",
    if(any(nat.vriend.oever == 1)) "NVO",
    if(any(water == 1)) "Water"
  )), collapse = " + ")),
  by = EAGIDENT
]

# Merge met verschil data
eag_meer_zonder_soorten <- merge(eag_meer_zonder_soorten, 
                                  pakketten_per_eag, 
                                  by = "EAGIDENT", 
                                  all.x = TRUE)

eag_meer_met_soorten <- merge(eag_meer_met_soorten, 
                              pakketten_per_eag, 
                              by = "EAGIDENT", 
                              all.x = TRUE)

# 4. VOEG GEOMETRIE TOE VOOR KAARTEN
# ============================================================================
EAG <- st_as_sf(EAG)
# Voor "zonder pakket beter" (soorten)
eag_meer_zonder_sf <- merge(
  EAG, 
  eag_meer_zonder_soorten[, .(EAGIDENT, verschil, pakketten)],
  by.x = "Code",
  by.y = "EAGIDENT",
  all.y = TRUE
)

# Voor "met pakket beter" (soorten)
eag_meer_met_sf <- merge(
  EAG,
  eag_meer_met_soorten[, .(EAGIDENT, verschil, pakketten)],
  by.x = "Code",
  by.y = "EAGIDENT",
  all.y = TRUE
)

# 5. MAAK KLEUREN VOOR PAKKETTEN
# ============================================================================

# Voor gebieden zonder pakket beter
pakket_kleuren_zonder <- setNames(
  colorRampPalette(okabe_colors)(length(unique(eag_meer_zonder_sf$pakketten))),
  unique(eag_meer_zonder_sf$pakketten)
)

# Voor gebieden met pakket beter
pakket_kleuren_met <- setNames(
  colorRampPalette(okabe_colors)(length(unique(eag_meer_met_sf$pakketten))),
  unique(eag_meer_met_sf$pakketten)
)

# 6. KAART 1: GEBIEDEN WAAR GEEN PAKKET BETER IS
# ============================================================================

ggplot() +
  geom_sf(data = EAG, fill = "grey90", color = "grey70", linewidth = 0.3) +
  geom_sf(data = eag_meer_zonder_sf, 
          aes(fill = abs(verschil), color = pakketten), 
          linewidth = 1.2) +
  scale_fill_gradient2(
    low = "white", 
    mid = "lightblue", 
    high = "darkblue",
    midpoint = median(abs(eag_meer_zonder_sf$verschil)),
    name = "Verschil\naantal soorten"
  ) +
  scale_color_manual(
    values = pakket_kleuren_zonder,
    name = "Beheerpakketten"
  ) +
  labs(
    title = "Gebieden waar GEEN beheerpakket meer submerse soorten heeft",
    subtitle = "Vulling = verschil in soorten, rand = type beheerpakket"
  ) +
  theme_minimal() +
  theme(
    axis.text = element_blank(),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank(),
    legend.position = "right"
  )

# 7. KAART 2: GEBIEDEN WAAR WEL PAKKET BETER IS
# ============================================================================

ggplot() +
  geom_sf(data = EAG, fill = "grey90", color = "grey70", linewidth = 0.3) +
  geom_sf(data = eag_meer_met_sf, 
          aes(fill = verschil, color = pakketten), 
          linewidth = 1.2) +
  scale_fill_gradient2(
    low = "white", 
    mid = "lightgreen", 
    high = "darkgreen",
    midpoint = median(eag_meer_met_sf$verschil),
    name = "Verschil\naantal soorten"
  ) +
  scale_color_manual(
    values = pakket_kleuren_met,
    name = "Beheerpakketten"
  ) +
  labs(
    title = "Gebieden waar WEL beheerpakket meer submerse soorten heeft",
    subtitle = "Vulling = verschil in soorten, rand = type beheerpakket"
  ) +
  theme_minimal() +
  theme(
    axis.text = element_blank(),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank(),
    legend.position = "right"
  )

# 8. DETAILKAARTEN PER DEELGEBIED (MET CORRECTE NAMEN)
# ============================================================================

# ============================================================================
# FIX: Gebruik het juiste bron-object met alle kolommen
# ============================================================================

# STAP 1: Maak eerst de data zonder geometry
locaties_grote_verschillen <- hybianlb[
  EAGIDENT %in% eag_meer_zonder_soorten$EAGIDENT,
  .(locatie, EAGIDENT, EAGNAAM, anlb, 
    n_soort_sub = uniqueN(biotaxonnaam[submers == 1]) - 1),
  by = .(locatie, jaar)
]

# Verwijder duplicaten en behoud alleen unieke combinaties
locaties_grote_verschillen <- unique(locaties_grote_verschillen[, 
  .(locatie, EAGIDENT, EAGNAAM, anlb, n_soort_sub)
])

# STAP 2: Voeg label toe
locaties_grote_verschillen[, anlb_label := fifelse(
  anlb == "ja", 
  "Met pakket", 
  "Zonder pakket"
)]

# STAP 3: Voeg geometry toe door te mergen met geohybianlb
# Gebruik alleen 'locatie' als merge key omdat dat de enige gemeenschappelijke kolom is
locaties_grote_verschillen <- merge(
  geohybianlb[, c("locatie", "geometry")],  # Selecteer alleen nodige kolommen
  locaties_grote_verschillen,
  by = "locatie",
  all.y = TRUE
)

# Zorg dat het een sf object blijft
locaties_grote_verschillen <- st_as_sf(locaties_grote_verschillen)

# ============================================================================
# VERVOLG: Transform en maak kaarten
# ============================================================================

# Transform voor web maps
locaties_wm <- st_transform(locaties_grote_verschillen, crs = 3857)

# Haal EAG data op
eag_deelgebieden <- EAG[EAG$Code %in% eag_meer_zonder_soorten$EAGIDENT, ]
eag_deelgebieden_wm <- st_transform(eag_deelgebieden, crs = 3857)

# Update andere variabelen
geohybianlb_verschillen <- locaties_grote_verschillen
geohybianlb_verschillen_wm <- locaties_wm

# Maak kaarten per uniek deelgebied
deelgebieden <- unique(locaties_grote_verschillen$EAGNAAM)

for(dg in deelgebieden) {
  # Filter data voor dit deelgebied
  locs_dg <- locaties_wm[locaties_wm$EAGNAAM == dg, ]
  eag_dg <- eag_deelgebieden_wm[eag_deelgebieden_wm$Code == unique(locs_dg$EAGIDENT), ]
  
  if(nrow(eag_dg) == 0) next
  
  # Bereken bounding box
  bbox <- st_bbox(st_buffer(st_union(eag_dg), 500))
  
  # Maak plot
  p <- ggplot() +
    annotation_map_tile(type = "osm", zoom = 14, alpha = 0.5) +
    geom_sf(data = eag_dg, fill = "transparent", color = "grey40", linewidth = 0.8) +
    geom_sf(data = locs_dg, 
            aes(color = anlb_label, size = n_soort_sub),
            alpha = 0.7) +
    geom_sf_text(data = locs_dg,
                 aes(label = n_soort_sub),
                 size = 3,
                 color = "black",
                 fontface = "bold",
                 nudge_y = 100) +
    scale_color_manual(
      values = c("Met pakket" = "blue", "Zonder pakket" = "red"),
      name = "Beheerpakket"
    ) +
    scale_size_continuous(
      range = c(2, 8),
      name = "Aantal\nsubmerse\nsoorten"
    ) +
    coord_sf(xlim = c(bbox["xmin"], bbox["xmax"]),
             ylim = c(bbox["ymin"], bbox["ymax"]),
             crs = 3857) +
    labs(
      title = paste("Meetlocaties in", dg),
      subtitle = "Aantal submerse soorten (rood = zonder pakket, blauw = met pakket)"
    ) +
    theme_minimal() +
    theme(
      axis.text = element_blank(),
      axis.title = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank(),
      legend.position = "right",
      plot.title = element_text(size = 14, face = "bold"),
      plot.subtitle = element_text(size = 11)
    )
  
  print(p)
}

# 9. SAMENVATTING
# ============================================================================

cat("\n========================================")
cat("\nSAMENVATTING GROTE VERSCHILLEN")
cat("\n========================================\n")

cat("\nGebieden waar GEEN pakket beter is:\n")
print(eag_meer_zonder_soorten[, .(EAGIDENT, verschil, pakketten)])

cat("\nGebieden waar WEL pakket beter is:\n")
print(eag_meer_met_soorten[, .(EAGIDENT, verschil, pakketten)])
```

```{r eags waar verschil met en zonder pakket groot zijn op submerse soorten}

# ============================================================================
# 1. AGGREGEER DATA PER EAGIDENT (LAATSTE MEETJAAR)
# ============================================================================

# Voor soorten verschillen: neem de meest recente data per EAGIDENT
soorten_verschillen_agg <- soorten_verschillen[, .SD[which.max(jaar)], by = .(EAGIDENT)]
setDT(EAG)
soorten_verschillen_agg <- merge(soorten_verschillen_agg, EAG[, .(Code, Naam)], 
                                 by.x = "EAGIDENT", by.y = "Code", all.x = TRUE)
setnames(soorten_verschillen_agg, "Naam", "EAGNAAM")

# ============================================================================
# 2. SELECTEER TOP 10 NEGATIEF EN TOP 10 POSITIEF
# ============================================================================

# Top 10 negatieve verschillen (zonder pakket beter)
top10_negatief <- soorten_verschillen_agg[order(verschil)][1:10]

# Top 10 positieve verschillen (met pakket beter)
top10_positief <- soorten_verschillen_agg[order(-verschil)][1:10]

# Combineer beide
top_verschillen <- rbind(
  top10_negatief[, richting := "Zonder pakket beter"],
  top10_positief[, richting := "Met pakket beter"]
)

# ============================================================================
# 3. VOEG PAKKETTEN INFO TOE
# ============================================================================

# Merge met pakketten info
top_verschillen <- merge(
  top_verschillen,
  pakketten_per_eag,
  by = "EAGIDENT",
  all.x = TRUE
)

# Als pakketten kolom nog steeds niet bestaat, maak deze aan
if(!"pakketten" %in% names(top_verschillen)) {
  top_verschillen[, pakketten := "Onbekend"]
}

# ============================================================================
# 4. MAAK KLEUREN OP BASIS VAN ABSOLUTE WAARDE
# ============================================================================

# Gebruik absolute waarde voor kleurintensiteit
top_verschillen[, abs_verschil := abs(verschil)]

# ============================================================================
# 5. PLOT MET EAGNAAM EN PAKKETTEN RECHTS
# ============================================================================

p_top_verschillen <- ggplot(top_verschillen, 
                             aes(x = reorder(EAGNAAM, verschil), 
                                 y = verschil,
                                 fill = abs_verschil)) +
  
  # Bars met kleurgradient op basis van absolute waarde
  geom_col() +
  
  # Voeg verschil waarde toe aan het einde van de bar
  geom_text(aes(label = round(verschil, 1)),
            hjust = ifelse(top_verschillen$verschil > 0, -0.2, 1.2),
            size = 5,
            fontface = "bold") +
  
   
  # Kleurenschaal voor absolute waarde
  scale_fill_gradient2(
    low = "lightblue",
    mid = "steelblue",
    high = "darkblue",
    midpoint = median(top_verschillen$abs_verschil),
    name = "Grootte\nverschil"
  ) +
  
  # Horizontale lijn op 0
  geom_hline(yintercept = 0, linetype = "solid", color = "black", linewidth = 0.8) +
  
  # Flip coordinaten
  coord_flip() +
  
  # Labels en thema
  labs(
    title = "Top 10 gebieden met grootste verschillen in submerse soorten",
    subtitle = "Negatief = zonder pakket beter | Positief = met pakket beter",
    x = "EAG Gebied",
    y = "Verschil aantal soorten (met - zonder pakket)"
    
  ) +
  
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 14, hjust = 1),
    axis.text.x = element_text(size = 14),
    axis.title = element_text(size = 14, face = "bold"),
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 14, color = "gray40"),
    plot.caption = element_text(size = 9, color = "gray50", hjust = 0),
    legend.position = "right",
    plot.margin = margin(10, 80, 10, 10)  # Extra ruimte rechts voor pakketten
  )

print(p_top_verschillen)


```

```{r eags waar verschil met en zonder pakket groot zijn op emerse soorten}

# ============================================================================
# 1. BEREID DATA VOOR - VOOR EMERSE SOORTEN
# ============================================================================

# Voor EMERSE SOORTEN:
emers_soorten_verschillen <- anlb_emers_soorten_cast[!is.na(nee) & !is.na(ja)]
emers_soorten_verschillen[, verschil := ja - nee]

# 2. AGGREGEER DATA PER EAGIDENT (LAATSTE MEETJAAR)
# ============================================================================

emers_soorten_verschillen_agg <- emers_soorten_verschillen[, .SD[which.max(jaar)], by = EAGIDENT]
setDT(EAG)
# soorten_verschillen_agg <- merge(soorten_verschillen_agg, EAG[, .(Code, Naam)], 
#                                  by.x = "EAGIDENT", by.y = "Code", all.x = TRUE)
# setnames(soorten_verschillen_agg, "Naam", "EAGNAAM")

# 3. SELECTEER TOP 10 NEGATIEF EN TOP 10 POSITIEF
# ============================================================================

top10_negatief_emers <- emers_soorten_verschillen_agg[order(verschil)][1:10]
top10_positief_emers <- emers_soorten_verschillen_agg[order(-verschil)][1:10]

# Combineer beide
top_verschillen_emers <- rbind(
  top10_negatief_emers[, richting := "Zonder pakket beter"],
  top10_positief_emers[, richting := "Met pakket beter"]
)

# 4. VOEG EAG NAMEN TOE DOOR TE MERGEN MET EAG DATA
# ============================================================================

# Haal EAG namen op uit de EAG dataset
EAG_dt <- as.data.table(st_drop_geometry(EAG))
eag_namen <- EAG_dt[, .(Code, Naam)]

# Merge met top verschillen
top_verschillen_emers <- merge(
  top_verschillen_emers,
  eag_namen,
  by.x = "EAGIDENT",
  by.y = "Code",
  all.x = TRUE
)

# Als er geen naam is, gebruik dan EAGIDENT
top_verschillen_emers[is.na(Naam), Naam := EAGIDENT]

# 5. VOEG PAKKETTEN INFO TOE
# ============================================================================

top_verschillen_emers <- merge(
  top_verschillen_emers,
  pakketten_per_eag,
  by = "EAGIDENT",
  all.x = TRUE
)

# Als pakketten kolom nog steeds niet bestaat, maak deze aan
if(!"pakketten" %in% names(top_verschillen_emers)) {
  top_verschillen_emers[, pakketten := "Onbekend"]
}

# 6. MAAK KLEUREN OP BASIS VAN ABSOLUTE WAARDE
# ============================================================================

top_verschillen_emers[, abs_verschil := abs(verschil)]

# 7. PLOT MET NAAM IN PLAATS VAN EAGNAAM
# ============================================================================

p_top_verschillen_emers <- ggplot(top_verschillen_emers, 
                                   aes(x = reorder(Naam, verschil), 
                                       y = verschil,
                                       fill = abs_verschil)) +
  
  geom_col() +
  
  geom_text(aes(label = round(verschil, 1)),
            hjust = ifelse(top_verschillen_emers$verschil > 0, -0.2, 1.2),
            size = 5,
            fontface = "bold") +
  
  scale_fill_gradient2(
    low = "lightblue",
    mid = "steelblue",
    high = "darkblue",
    midpoint = median(top_verschillen_emers$abs_verschil),
    name = "Grootte\nverschil"
  ) +
  
  geom_hline(yintercept = 0, linetype = "solid", color = "black", linewidth = 0.8) +
  
  coord_flip() +
  
  labs(
    title = "Top 10 gebieden met grootste verschillen in emerse soorten",
    subtitle = "Negatief = zonder pakket beter | Positief = met pakket beter",
    x = "EAG Gebied",
    y = "Verschil aantal soorten (met - zonder pakket)"
  ) +
  
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 14, hjust = 1),
    axis.text.x = element_text(size = 14),
    axis.title = element_text(size = 14, face = "bold"),
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 14, color = "gray40"),
    legend.position = "right",
    plot.margin = margin(10, 80, 10, 10)
  )

print(p_top_verschillen_emers)


```

```{r overzicht eags waar verschillen vegetatie groot zijn}
# ============================================================================
# VISUALISATIE 6C: KAARTEN VOOR SPECIFIEKE GEBIEDEN
# ============================================================================

# Lijst met gewenste deelgebieden
gewenste_gebieden <- c("Veldhuiswetering", "Groot Wilnis Vinkeveen Zuid", "Polder Achttienhoven")

# Zoek in EAG namen naar deze gebieden
for(gebied_naam in gewenste_gebieden) {
  # gebied_naam <- gewenste_gebieden[1]
  cat("\n========================================")
  cat("\nZoeken naar:", gebied_naam)
  cat("\n========================================\n")
  
  # Zoek in EAG namen (case-insensitive)
  eag_gebied <- EAG[grep(gebied_naam, EAG$Naam, ignore.case = TRUE), ]
  
  if(nrow(eag_gebied) > 0) {
    cat("Gevonden EAG's:\n")
    print(eag_gebied$Naam)
    
    # Haal alle locaties op in dit gebied uit hybianlb
    locs_gebied_data <- hybianlb[EAGIDENT %in% eag_gebied$Code & 
                                   compartiment == 'EZ',
                                  .(n_soort_sub = uniqueN(biotaxonnaam[submers == 1]) - 1),
                                  by = .(locatie, EAGIDENT, anlb)]
    
    # Maak breed formaat
    locs_gebied_cast <- dcast(locs_gebied_data,
                               locatie + EAGIDENT ~ anlb,
                               value.var = "n_soort_sub")
    
    # Maak lang formaat voor plotting
    locs_gebied_long <- melt(locs_gebied_cast,
                              id.vars = c("locatie", "EAGIDENT"),
                              measure.vars = c("nee", "ja"),
                              variable.name = "anlb",
                              value.name = "n_soort_sub")
    
    locs_gebied_long <- locs_gebied_long[!is.na(n_soort_sub)]
    locs_gebied_long[, anlb_label := ifelse(anlb == "ja", "Met pakket", "Zonder pakket")]
    
    # BELANGRIJKE STAP: Merge met geohybianlb om geometry kolom toe te voegen
    locs_gebied_merged <- merge(
      geohybianlb,
      locs_gebied_long,
      by = "locatie"
    )
    
    # Check of er locaties zijn
    if(nrow(locs_gebied_merged) == 0) {
      cat("Geen meetlocaties gevonden in", gebied_naam, "\n")
      next
    }
    
    cat("Aantal locaties gevonden:", nrow(locs_gebied_merged), "\n")
    
    # Transform naar Web Mercator
    locs_gebied_wm <- st_transform(st_as_sf(locs_gebied_merged), crs = 3857)
    eag_gebied_wm <- st_transform(st_as_sf(eag_gebied), crs = 3857)
    
    # Bereken bounding box met buffer
    bbox <- st_bbox(st_buffer(st_union(eag_gebied_wm), 500))
    
    # Maak de plot
    p_gebied <- ggplot() +
      annotation_map_tile(type = "osm", zoom = 14, alpha = 0.5) +
      geom_sf(data = eag_gebied_wm, fill = "transparent", color = "grey40", linewidth = 0.8) +
      geom_sf(data = locs_gebied_wm, 
              aes(color = anlb_label, size = n_soort_sub),
              alpha = 0.7) +
      geom_sf_text(data = locs_gebied_wm,
                   aes(label = n_soort_sub),
                   size = 3,
                   color = "black",
                   fontface = "bold",
                   nudge_y = 100) +
      scale_color_manual(
        values = c("Met pakket" = "blue", "Zonder pakket" = "red"),
        name = "Beheerpakket"
      ) +
      scale_size_continuous(
        range = c(2, 8),
        name = "Aantal\nsubmerse\nsoorten"
      ) +
      coord_sf(xlim = c(bbox["xmin"], bbox["xmax"]),
               ylim = c(bbox["ymin"], bbox["ymax"]),
               crs = 3857) +
      labs(
        title = paste("Meetlocaties in", gebied_naam),
        subtitle = "Aantal submerse soorten (rood = zonder pakket, blauw = met pakket)"
      ) +
      theme_minimal() +
      theme(
        axis.text = element_blank(),
        axis.title = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank(),
        legend.position = "right",
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 11)
      )
    
    print(p_gebied)
    
    # Sla de plot op
    ggsave(
      filename = paste0("kaart_", gsub(" ", "_", tolower(gebied_naam)), ".png"),
      plot = p_gebied,
      width = 12,
      height = 10,
      dpi = 300
    )
    
    cat("\nKaart opgeslagen als: kaart_", gsub(" ", "_", tolower(gebied_naam)), ".png\n")
    
  } else {
    cat("WAARSCHUWING: Geen EAG gevonden voor", gebied_naam, "\n")
    cat("Probeer de exacte naam te controleren in de data.\n")
    
    # Zoek naar vergelijkbare namen
    mogelijke_namen <- grep(strsplit(gebied_naam, " ")[[1]][1], 
                            EAG$Naam, 
                            ignore.case = TRUE, 
                            value = TRUE)
    
    if(length(mogelijke_namen) > 0) {
      cat("\nMogelijk bedoelde gebieden:\n")
      print(unique(mogelijke_namen))
    }
  }
}

# ============================================================================
# ALTERNATIEF: ALS EXACTE NAMEN NIET WERKEN, ZOEK IN ALLE EAG NAMEN
# ============================================================================

cat("\n========================================")
cat("\nBESCHIKBARE DEELGEBIEDEN IN EAG DATA")
cat("\n========================================\n")

# Toon alle unieke EAG namen die vergelijkbaar zijn
cat("\nEAG's met 'Veldhu' in de naam:\n")
print(unique(grep("veldhu", EAG$Naam, ignore.case = TRUE, value = TRUE)))

cat("\nEAG's met 'Wilnis' in de naam:\n")
print(unique(grep("wilnis", EAG$Naam, ignore.case = TRUE, value = TRUE)))

cat("\nEAG's met 'Achttienhoven' in de naam:\n")
print(unique(grep("achttienhoven", EAG$Naam, ignore.case = TRUE, value = TRUE)))
```

```{r RELATIE TUSSEN VERSCHIL submers EN HETEROGENITEIT}
# ============================================================================
# ANALYSE: RELATIE TUSSEN VERSCHIL EN HETEROGENITEIT
# ============================================================================

# Bereken heterogeniteit (standaarddeviatie) per EAG voor beide situaties
heterogeniteit_per_eag <- n_soort_sub_data[, .(
  gem_soorten = mean(n_soort_sub, na.rm = TRUE),
  sd_soorten = sd(n_soort_sub, na.rm = TRUE),
  min_soorten = min(n_soort_sub, na.rm = TRUE),
  max_soorten = max(n_soort_sub, na.rm = TRUE),
  range_soorten = max(n_soort_sub, na.rm = TRUE) - min(n_soort_sub, na.rm = TRUE),
  cv_soorten = sd(n_soort_sub, na.rm = TRUE) / mean(n_soort_sub, na.rm = TRUE),  # Variatiecoëfficiënt
  n_monsters = .N
), by = .(EAGIDENT, anlb)]

# Bereken heterogeniteit apart per ANLB status
heterogeniteit_zonder <- heterogeniteit_per_eag[anlb == "nee"]
setnames(heterogeniteit_zonder, 
         old = c("sd_soorten", "range_soorten", "cv_soorten"),
         new = c("sd_zonder", "range_zonder", "cv_zonder"))

heterogeniteit_met <- heterogeniteit_per_eag[anlb == "ja"]
setnames(heterogeniteit_met, 
         old = c("sd_soorten", "range_soorten", "cv_soorten"),
         new = c("sd_met", "range_met", "cv_met"))

# Merge met verschil data
verschil_heterogeniteit <- merge(
  soorten_vergelijking,
  heterogeniteit_zonder[, .(EAGIDENT, sd_zonder, range_zonder, cv_zonder)],
  by = "EAGIDENT",
  all.x = TRUE
)

verschil_heterogeniteit <- merge(
  verschil_heterogeniteit,
  heterogeniteit_met[, .(EAGIDENT, sd_met, range_met, cv_met)],
  by = "EAGIDENT",
  all.x = TRUE
)

# Bereken gemiddelde heterogeniteit
verschil_heterogeniteit[, sd_gemiddeld := (sd_zonder + sd_met) / 2]
verschil_heterogeniteit[, range_gemiddeld := (range_zonder + range_met) / 2]
verschil_heterogeniteit[, cv_gemiddeld := (cv_zonder + cv_met) / 2]

# Bereken absolute verschil
verschil_heterogeniteit[, abs_verschil := abs(verschil)]

# Verwijder NA's voor correlatie analyse
verschil_heterogeniteit_clean <- verschil_heterogeniteit[
  !is.na(abs_verschil) & !is.na(sd_gemiddeld) & 
  !is.infinite(cv_gemiddeld) & !is.na(cv_gemiddeld)
]

# Bereken correlaties
cat("\n========================================")
cat("\nCORRELATIE ANALYSE: VERSCHIL vs HETEROGENITEIT")
cat("\n========================================\n")

cor_sd <- cor(verschil_heterogeniteit_clean$abs_verschil, 
              verschil_heterogeniteit_clean$sd_gemiddeld, 
              use = "complete.obs")
cat("Correlatie tussen |verschil| en standaarddeviatie:", round(cor_sd, 3), "\n")

cor_range <- cor(verschil_heterogeniteit_clean$abs_verschil, 
                 verschil_heterogeniteit_clean$range_gemiddeld, 
                 use = "complete.obs")
cat("Correlatie tussen |verschil| en range:", round(cor_range, 3), "\n")

cor_cv <- cor(verschil_heterogeniteit_clean$abs_verschil, 
              verschil_heterogeniteit_clean$cv_gemiddeld, 
              use = "complete.obs")
cat("Correlatie tussen |verschil| en variatiecoëfficiënt:", round(cor_cv, 3), "\n")

# Maak scatter plots
library(ggplot2)

# Plot 1: Verschil vs Standaarddeviatie
p1 <- ggplot(verschil_heterogeniteit_clean, 
             aes(x = sd_gemiddeld, y = abs_verschil)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  labs(
    title = "Relatie tussen verschil en heterogeniteit (standaarddeviatie)",
    x = "Gemiddelde standaarddeviatie aantal soorten",
    y = "Absoluut verschil tussen met/zonder pakket",
    subtitle = paste0("Correlatie: ", round(cor_sd, 3))
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

print(p1)

# Plot 2: Verschil vs Range
p2 <- ggplot(verschil_heterogeniteit_clean, 
             aes(x = range_gemiddeld, y = abs_verschil)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "red") +
  labs(
    title = "Relatie tussen verschil en heterogeniteit (range)",
    x = "Gemiddelde range aantal soorten",
    y = "Absoluut verschil tussen met/zonder pakket",
    subtitle = paste0("Correlatie: ", round(cor_range, 3))
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

print(p2)

# Plot 3: Verschil vs Variatiecoëfficiënt
p3 <- ggplot(verschil_heterogeniteit_clean, 
             aes(x = cv_gemiddeld, y = abs_verschil)) +
  geom_point(alpha = 0.6, size = 3) +
  geom_smooth(method = "lm", se = TRUE, color = "darkgreen") +
  labs(
    title = "Relatie tussen verschil en heterogeniteit (variatiecoëfficiënt)",
    x = "Gemiddelde variatiecoëfficiënt",
    y = "Absoluut verschil tussen met/zonder pakket",
    subtitle = paste0("Correlatie: ", round(cor_cv, 3))
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

print(p3)

# Vergelijk heterogeniteit tussen groepen
cat("\n========================================")
cat("\nVERGELIJKING HETEROGENITEIT TUSSEN GROEPEN")
cat("\n========================================\n")

# Grote verschillen (top 25%)
threshold_groot <- quantile(verschil_heterogeniteit_clean$abs_verschil, 0.75, na.rm = TRUE)
verschil_heterogeniteit_clean[, groep := ifelse(abs_verschil >= threshold_groot, 
                                                 "Groot verschil", 
                                                 "Klein verschil")]

vergelijking <- verschil_heterogeniteit_clean[, .(
  gem_sd = mean(sd_gemiddeld, na.rm = TRUE),
  gem_range = mean(range_gemiddeld, na.rm = TRUE),
  gem_cv = mean(cv_gemiddeld, na.rm = TRUE),
  n_eags = .N
), by = groep]

print(vergelijking)

# Statistische test (t-test)
cat("\nT-test voor verschil in heterogeniteit:\n")
t_test_result <- t.test(
  sd_gemiddeld ~ groep,
  data = verschil_heterogeniteit_clean
)
print(t_test_result)

# Boxplot vergelijking
p4 <- ggplot(verschil_heterogeniteit_clean, 
             aes(x = groep, y = sd_gemiddeld, fill = groep)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.3) +
  scale_fill_manual(values = c("Groot verschil" = "red", "Klein verschil" = "lightblue")) +
  labs(
    title = "Heterogeniteit (standaarddeviatie) per groep",
    x = "Groep",
    y = "Gemiddelde standaarddeviatie aantal soorten",
    subtitle = paste0("p-waarde: ", round(t_test_result$p.value, 4))
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    legend.position = "none"
  )

print(p4)

# Conclusie
cat("\n========================================")
cat("\nCONCLUSIE")
cat("\n========================================\n")

if(cor_sd > 0.3 & t_test_result$p.value < 0.05) {
  cat("JA, er is een significante positieve correlatie tussen het verschil\n")
  cat("in aantal soorten en de heterogeniteit binnen gebieden.\n")
  cat("Gebieden met grotere heterogeniteit vertonen grotere verschillen\n")
  cat("tussen locaties met en zonder beheerpakket.\n")
} else if(cor_sd > 0.1 & cor_sd <= 0.3) {
  cat("Er is een zwakke positieve correlatie tussen verschil en heterogeniteit,\n")
  cat("maar het effect is niet heel sterk.\n")
} else {
  cat("NEEN, er is geen duidelijke relatie tussen het verschil in aantal soorten\n")
  cat("en de heterogeniteit binnen gebieden.\n")
}
```

```{r boxplots vegetatie per jaar}
# ============================================================================
# BOXPLOTS PER JAAR - EMERSE EN SUBMERSE BEDEKKING EN SOORTEN
# ============================================================================

# Bereken aantal soorten per monster (zoals je al deed)
n_soort_ems_data <- hybianlb[compartiment == 'EZ' , 
                              .(n_soort_ems = uniqueN(biotaxonnaam[emers == 1]) - 1), 
                              by = .(monsterident, locatie, EAGIDENT, jaar, anlb, beheer)]

n_soort_sub_data <- hybianlb[compartiment == 'EZ' , 
                              .(n_soort_sub = uniqueN(biotaxonnaam[submers == 1]) - 1), 
                              by = .(monsterident, locatie, EAGIDENT, jaar, anlb, beheer)]

# Maak nieuwe rijen voor emerse soorten
n_soort_ems_long <- n_soort_ems_data[, .(
  monsterident = monsterident,
  locatie = locatie,
  EAGIDENT = EAGIDENT,
  jaar = jaar,
  anlb = anlb,
  beheer = beheer,
  parameterid = 'N_SOORT_EMS',
  parameter = 'EMERSE_SOORTEN',
  compartiment = 'EZ',
  meetwaarde = as.numeric(n_soort_ems)
)]

# Maak nieuwe rijen voor submerse soorten
n_soort_sub_long <- n_soort_sub_data[, .(
  monsterident = monsterident,
  locatie = locatie,
  EAGIDENT = EAGIDENT,
  jaar = jaar,
  anlb = anlb,
  beheer = beheer,
  parameterid = 'N_SOORT_SUB',
  parameter = 'SUBMERSE_SOORTEN',
  compartiment = 'EZ',
  meetwaarde = as.numeric(n_soort_sub)
)]

# Voeg de nieuwe rijen toe aan hybianlb
hybianlb_extended <- rbindlist(
  list(hybianlb, n_soort_ems_long, n_soort_sub_long),
  use.names = TRUE,
  fill = TRUE
)

# Maak labels voor facetten
hybianlb_extended[, variabele_label := fcase(
  compartiment == 'EZ' & parameterid == 'PTN_BEDKG_%' & parameter == "EMSPTN", "Emerse bedekking (%)",
  compartiment == 'EZ' & parameterid == 'PTN_BEDKG_%' & parameter == "SUBMSPTN", "Submerse bedekking (%)",
  compartiment == 'EZ' & parameterid == 'N_SOORT_EMS' , "Emerse soorten (n)",
  compartiment == 'EZ' & parameterid == 'N_SOORT_SUB', "Submerse soorten (n)"
)]

# Maak de plot met facets
p_jaar_boxplots <- ggplot(hybianlb_extended[!is.na(variabele_label),], aes(x = factor(jaar), y = meetwaarde, fill = anlb)) +
  geom_boxplot(alpha = 0.7) +
  facet_wrap(~variabele_label, scales = "free_y", ncol = 2) +
  scale_fill_manual(
    values = c("ja" = okabe_colors[2], "nee" = okabe_colors[9]),
    labels = c("ja" = "Met ANLB", "nee" = "Zonder ANLB")
  ) +
  labs(
    title = "Ontwikkeling watervegetatie per jaar",
    subtitle = "Vergelijking tussen locaties met en zonder ANLB-beheer",
    x = "Jaar",
    y = "Waarde",
    fill = "ANLB-beheer"
  ) +
  theme_minimal() +
  theme(
    size = 14,
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12, color = "gray30"),
    axis.text.x = element_text(size = 14,angle = 45, hjust = 1),
    strip.text = element_text(size = 14, face = "bold"),
    
    legend.position = "bottom"
  )

print(p_jaar_boxplots)



```

```{r LINEAIRE TREND ANALYSE - SUBMERSE VEGETATIE OVER TIJD}
# ============================================================================
# LINEAIRE TREND ANALYSE - SUBMERSE VEGETATIE OVER TIJD
# ============================================================================

# Bereid data voor
trend_data <- hybianlb_extended[!is.na(variabele_label) & 
                                 variabele_label %in% c("Submerse bedekking (%)", 
                                                       "Submerse soorten (n)")]

# ============================================================================
# 1. LINEAIRE REGRESSIE PER ANLB STATUS
# ============================================================================

# Submerse bedekking
submers_bed_trend <- trend_data[variabele_label == "Submerse bedekking (%)"]

# Model voor locaties MET ANLB
model_bed_ja <- lm(meetwaarde ~ jaar, data = submers_bed_trend[anlb == "ja"])
summary_bed_ja <- summary(model_bed_ja)

# Model voor locaties ZONDER ANLB
model_bed_nee <- lm(meetwaarde ~ jaar, data = submers_bed_trend[anlb == "nee"])
summary_bed_nee <- summary(model_bed_nee)

# Submerse soorten
submers_srt_trend <- trend_data[variabele_label == "Submerse soorten (n)"]

# Model voor locaties MET ANLB
model_srt_ja <- lm(meetwaarde ~ jaar, data = submers_srt_trend[anlb == "ja"])
summary_srt_ja <- summary(model_srt_ja)

# Model voor locaties ZONDER ANLB
model_srt_nee <- lm(meetwaarde ~ jaar, data = submers_srt_trend[anlb == "nee"])
summary_srt_nee <- summary(model_srt_nee)

# ============================================================================
# 2. PRINT RESULTATEN
# ============================================================================

cat("\n========================================")
cat("\nLINEAIRE TREND ANALYSE - SUBMERSE VEGETATIE")
cat("\n========================================\n")

cat("\nSUBMERSE BEDEKKING:")
cat("\n------------------")
cat("\nMet ANLB:")
cat("\n  Helling (% per jaar):", round(coef(model_bed_ja)[2], 3))
cat("\n  R²:", round(summary_bed_ja$r.squared, 3))
cat("\n  p-waarde:", format.pval(summary_bed_ja$coefficients[2,4], digits = 3))
cat("\n  Significantie:", 
    ifelse(summary_bed_ja$coefficients[2,4] < 0.001, "***",
           ifelse(summary_bed_ja$coefficients[2,4] < 0.01, "**",
                  ifelse(summary_bed_ja$coefficients[2,4] < 0.05, "*", "ns"))))

cat("\n\nZonder ANLB:")
cat("\n  Helling (% per jaar):", round(coef(model_bed_nee)[2], 3))
cat("\n  R²:", round(summary_bed_nee$r.squared, 3))
cat("\n  p-waarde:", format.pval(summary_bed_nee$coefficients[2,4], digits = 3))
cat("\n  Significantie:", 
    ifelse(summary_bed_nee$coefficients[2,4] < 0.001, "***",
           ifelse(summary_bed_nee$coefficients[2,4] < 0.01, "**",
                  ifelse(summary_bed_nee$coefficients[2,4] < 0.05, "*", "ns"))))

cat("\n\nSUBMERSE SOORTEN:")
cat("\n-----------------")
cat("\nMet ANLB:")
cat("\n  Helling (soorten per jaar):", round(coef(model_srt_ja)[2], 3))
cat("\n  R²:", round(summary_srt_ja$r.squared, 3))
cat("\n  p-waarde:", format.pval(summary_srt_ja$coefficients[2,4], digits = 3))
cat("\n  Significantie:", 
    ifelse(summary_srt_ja$coefficients[2,4] < 0.001, "***",
           ifelse(summary_srt_ja$coefficients[2,4] < 0.01, "**",
                  ifelse(summary_srt_ja$coefficients[2,4] < 0.05, "*", "ns"))))

cat("\n\nZonder ANLB:")
cat("\n  Helling (soorten per jaar):", round(coef(model_srt_nee)[2], 3))
cat("\n  R²:", round(summary_srt_nee$r.squared, 3))
cat("\n  p-waarde:", format.pval(summary_srt_nee$coefficients[2,4], digits = 3))
cat("\n  Significantie:", 
    ifelse(summary_srt_nee$coefficients[2,4] < 0.001, "***",
           ifelse(summary_srt_nee$coefficients[2,4] < 0.01, "**",
                  ifelse(summary_srt_nee$coefficients[2,4] < 0.05, "*", "ns"))))

# ============================================================================
# 3. VISUALISATIE MET TRENDLIJNEN
# ============================================================================

# Submerse bedekking met trendlijn
p_trend_bed <- ggplot(submers_bed_trend, 
                      aes(x = jaar, y = meetwaarde, color = anlb)) +
  geom_boxplot(aes(group = interaction(jaar, anlb)), alpha = 0.5) +
  geom_smooth(method = "lm", se = TRUE, linewidth = 1.5) +
  scale_color_manual(
    values = c("ja" = okabe_colors[2], "nee" = okabe_colors[9]),
    labels = c("ja" = "Met ANLB", "nee" = "Zonder ANLB")
  ) +
  labs(
    title = "Lineaire trend: Submerse bedekking over tijd",
    subtitle = paste0(
      "Met ANLB: ", round(coef(model_bed_ja)[2], 2), "%/jaar (p=", 
      format.pval(summary_bed_ja$coefficients[2,4], digits=2), "), ",
      "Zonder ANLB: ", round(coef(model_bed_nee)[2], 2), "%/jaar (p=",
      format.pval(summary_bed_nee$coefficients[2,4], digits=2), ")"
    ),
    x = "Jaar",
    y = "Submerse bedekking (%)",
    color = "ANLB-beheer"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 10),
    legend.position = "bottom"
  )

print(p_trend_bed)

# Submerse soorten met trendlijn
p_trend_srt <- ggplot(submers_srt_trend, 
                      aes(x = jaar, y = meetwaarde, color = anlb)) +
  geom_boxplot(aes(group = interaction(jaar, anlb)), alpha = 0.5) +
  geom_smooth(method = "lm", se = TRUE, linewidth = 1.5) +
  scale_color_manual(
    values = c("ja" = okabe_colors[2], "nee" = okabe_colors[9]),
    labels = c("ja" = "Met ANLB", "nee" = "Zonder ANLB")
  ) +
  labs(
    title = "Lineaire trend: Submerse soorten over tijd",
    subtitle = paste0(
      "Met ANLB: ", round(coef(model_srt_ja)[2], 3), " soorten/jaar (p=", 
      format.pval(summary_srt_ja$coefficients[2,4], digits=2), "), ",
      "Zonder ANLB: ", round(coef(model_srt_nee)[2], 3), " soorten/jaar (p=",
      format.pval(summary_srt_nee$coefficients[2,4], digits=2), ")"
    ),
    x = "Jaar",
    y = "Aantal submerse soorten",
    color = "ANLB-beheer"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 10),
    legend.position = "bottom"
  )

print(p_trend_srt)

# Gecombineerde plot
grid.arrange(p_trend_bed, p_trend_srt, ncol = 1,
             top = grid::textGrob("Temporele trends submerse vegetatie", 
                                 gp = grid::gpar(fontsize = 16, fontface = "bold")))

cat("\n========================================\n")
```

```{r RELATIES BEHEERMAATREGELEN EN FYSISCHE PARAMETERS}
# ============================================================================
# VISUALISATIE: RELATIES BEHEERMAATREGELEN EN FYSISCHE PARAMETERS
# ============================================================================

# Okabe-Ito kleurenpalet voor consistent gebruik
okabe_colors <- palette.colors(palette = "Okabe-Ito")

# ============================================================================
# 1. RELATIE BAGGEREN - WATERDIEPTE EN SLIBDIKTE
# ============================================================================

# Bereid data voor - gebruik anlbhybi_cast (niet hybianlb!)
bagger_data <- anlbhybi_cast[
  !is.na(WATDTE_m_WATDTE_) | !is.na(SLIBDTE_m_SLIBDTE_),
  .(
    locatie,
    jaar,
    EAGIDENT,
    anlb,
    baggeren,
    WATDTE_m_WATDTE_,
    SLIBDTE_m_SLIBDTE_,
    watertype
  )
]

# Verwijder duplicaten op locatie-jaar niveau
bagger_data <- unique(bagger_data)

# Maak baggeren label
bagger_data[is.na(baggeren) | baggeren == 0, bagger_label := "Geen baggerpakket"]
bagger_data[!is.na(baggeren) & baggeren != 0, bagger_label := "Wel baggerpakket"]

# Bereken statistieken voor waterdiepte
test1 <- t.test(WATDTE_m_WATDTE_ ~ bagger_label, 
                data = bagger_data[!is.na(bagger_label) & !is.na(WATDTE_m_WATDTE_)])
diff1 <- diff(test1$estimate)
sig1 <- ifelse(test1$p.value < 0.001, "***",
               ifelse(test1$p.value < 0.01, "**",
                      ifelse(test1$p.value < 0.05, "*", "ns")))

# Bereken statistieken voor slibdikte
test2 <- t.test(SLIBDTE_m_SLIBDTE_ ~ bagger_label, 
                data = bagger_data[!is.na(bagger_label) & !is.na(SLIBDTE_m_SLIBDTE_)])
diff2 <- diff(test2$estimate)
sig2 <- ifelse(test2$p.value < 0.001, "***",
               ifelse(test2$p.value < 0.01, "**",
                      ifelse(test2$p.value < 0.05, "*", "ns")))

# PLOT 1A: Waterdiepte vs Baggeren
p1a <- ggplot(bagger_data[!is.na(bagger_label) & !is.na(WATDTE_m_WATDTE_)], 
              aes(x = bagger_label, y = WATDTE_m_WATDTE_, fill = bagger_label)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.shape = NA) +
  annotate("text", x = 1.5, y = 1.4,
           label = paste0("Δ = ", round(diff1, 3), " m\n",
                         "p ", ifelse(test1$p.value < 0.001, "< 0.001", 
                                     paste0("= ", round(test1$p.value, 3))), " ", sig1),
           size = 5, fontface = "bold", color = "black") +
  scale_fill_manual(values = c("Geen baggerpakket" = okabe_colors[9], 
                               "Wel baggerpakket" = okabe_colors[2])) +
  scale_y_continuous(
    breaks = seq(0, 2, by = 0.2),
    labels = function(x) paste0(x, " m"),
    limits = c(0, 1.5)
  ) +
  labs(
    title = "Waterdiepte bij wel/geen baggerpakket",
    x = "",
    y = "Waterdiepte (m)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", color = "gray20"),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30"),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 12, color = "gray40"),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA)
  )

# PLOT 1B: Slibdikte vs Baggeren  
p1b <- ggplot(bagger_data[!is.na(bagger_label) & !is.na(SLIBDTE_m_SLIBDTE_)], 
              aes(x = bagger_label, y = SLIBDTE_m_SLIBDTE_, fill = bagger_label)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.shape = NA) +
  annotate("text", x = 1.5, y = 0.75,
           label = paste0("Δ = ", round(diff2, 3), " m\n",
                         "p ", ifelse(test2$p.value < 0.001, "< 0.001", 
                                     paste0("= ", round(test2$p.value, 3))), " ", sig2),
           size = 5, fontface = "bold", color = "black") +
  scale_fill_manual(values = c("Geen baggerpakket" = okabe_colors[9], 
                               "Wel baggerpakket" = okabe_colors[2])) +
  scale_y_continuous(
    breaks = seq(0, 1, by = 0.1),
    labels = function(x) paste0(x, " m"),
    limits = c(0, 0.8)
  ) +
  labs(
    title = "Slibdikte bij wel/geen baggerpakket",
    x = "",
    y = "Slibdikte (m)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", color = "gray20"),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30"),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 12, color = "gray40"),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA)
  )

# Combineer beide plots
library(gridExtra)
grid.arrange(p1a, p1b, ncol = 2,
             top = grid::textGrob("Effect van baggerpakket op waterdiepte en slibdikte", 
                                 gp = grid::gpar(fontsize = 18, fontface = "bold")))

# ============================================================================
# 2. RELATIE SCHONEN - DOORZICHT EN SLIBDIKTE
# ============================================================================

# Bereid data voor - gebruik anlbhybi_cast
schoon_data <- anlbhybi_cast[
  !is.na(zichtdte) | !is.na(SLIBDTE_m_SLIBDTE_),
  .(
    locatie,
    jaar,
    EAGIDENT,
    anlb,
    slootschonen,
    zichtdte,
    SLIBDTE_m_SLIBDTE_,
    watertype
  )
]

# Verwijder duplicaten
schoon_data <- unique(schoon_data)

# Maak schonen label
schoon_data[is.na(slootschonen) | slootschonen == 0, schoon_label := "Geen schoonpakket"]
schoon_data[!is.na(slootschonen) & slootschonen != 0, schoon_label := "Wel schoonpakket"]

# Bereken statistieken voor doorzicht
test3 <- t.test(zichtdte ~ schoon_label, 
                data = schoon_data[!is.na(schoon_label) & !is.na(zichtdte)])
diff3 <- diff(test3$estimate)
sig3 <- ifelse(test3$p.value < 0.001, "***",
               ifelse(test3$p.value < 0.01, "**",
                      ifelse(test3$p.value < 0.05, "*", "ns")))

# Bereken statistieken voor slibdikte
test4 <- t.test(SLIBDTE_m_SLIBDTE_ ~ schoon_label, 
                data = schoon_data[!is.na(schoon_label) & !is.na(SLIBDTE_m_SLIBDTE_)])
diff4 <- diff(test4$estimate)
sig4 <- ifelse(test4$p.value < 0.001, "***",
               ifelse(test4$p.value < 0.01, "**",
                      ifelse(test4$p.value < 0.05, "*", "ns")))

# PLOT 2A: Doorzicht vs Schonen
p2a <- ggplot(schoon_data[!is.na(schoon_label) & !is.na(zichtdte)], 
              aes(x = schoon_label, y = zichtdte, fill = schoon_label)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.shape = NA) +
  annotate("text", x = 1.5, y = 0.95,
           label = paste0("Δ = ", round(diff3, 3), "\n",
                         "p ", ifelse(test3$p.value < 0.001, "< 0.001", 
                                     paste0("= ", round(test3$p.value, 3))), " ", sig3),
           size = 5, fontface = "bold", color = "black") +
  scale_fill_manual(values = c("Geen schoonpakket" = okabe_colors[9], 
                               "Wel schoonpakket" = okabe_colors[3])) +
  scale_y_continuous(
    breaks = seq(0, 1, by = 0.1),
    labels = function(x) paste0(x),
    limits = c(0, 1)
  ) +
  labs(
    title = "Doorzicht/waterdiepte bij wel/geen schoonpakket",
    x = "",
    y = "Doorzicht/waterdiepte (-)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", color = "gray20"),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30"),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 12, color = "gray40"),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA)
  )

# PLOT 2B: Slibdikte vs Schonen
p2b <- ggplot(schoon_data[!is.na(schoon_label) & !is.na(SLIBDTE_m_SLIBDTE_)], 
              aes(x = schoon_label, y = SLIBDTE_m_SLIBDTE_, fill = schoon_label)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.shape = NA) +
  annotate("text", x = 1.5, y = 0.75,
           label = paste0("Δ = ", round(diff4, 3), " m\n",
                         "p ", ifelse(test4$p.value < 0.001, "< 0.001", 
                                     paste0("= ", round(test4$p.value, 3))), " ", sig4),
           size = 5, fontface = "bold", color = "black") +
  scale_fill_manual(values = c("Geen schoonpakket" = okabe_colors[9], 
                               "Wel schoonpakket" = okabe_colors[3])) +
  scale_y_continuous(
    breaks = seq(0, 1, by = 0.1),
    labels = function(x) paste0(x, " m"),
    limits = c(0, 0.8)
  ) +
  labs(
    title = "Slibdikte bij wel/geen schoonpakket",
    x = "",
    y = "Slibdikte (m)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", color = "gray20"),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30"),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 12, color = "gray40"),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA)
  )

# Combineer beide plots
grid.arrange(p2a, p2b, ncol = 2,
             top = grid::textGrob("Effect van schoonpakket op doorzicht en slibdikte", 
                                 gp = grid::gpar(fontsize = 18, fontface = "bold")))

# ============================================================================
# 3. RELATIE NATUURVRIENDELIJKE OEVER - TALUDHOEK
# ============================================================================

# Bereid data voor - gebruik anlbhybi_cast
nvo_data <- anlbhybi_cast[
  !is.na(TALBVWTR_graad_TALBVWTR_),
  .(
    locatie,
    jaar,
    EAGIDENT,
    anlb,
    nat.vriend.oever,
    TALBVWTR_graad_TALBVWTR_,
    watertype
  )
]

# Verwijder duplicaten
nvo_data <- unique(nvo_data)

# Maak NVO label
nvo_data[is.na(nat.vriend.oever) | nat.vriend.oever == 0, nvo_label := "Geen NVO"]
nvo_data[!is.na(nat.vriend.oever) & nat.vriend.oever != 0, nvo_label := "Wel NVO"]

# Bereken statistieken voor taludhoek
test5 <- t.test(TALBVWTR_graad_TALBVWTR_ ~ nvo_label, 
                data = nvo_data[!is.na(nvo_label)])
diff5 <- diff(test5$estimate)
sig5 <- ifelse(test5$p.value < 0.001, "***",
               ifelse(test5$p.value < 0.01, "**",
                      ifelse(test5$p.value < 0.05, "*", "ns")))

# PLOT 3: Taludhoek vs NVO
p3 <- ggplot(nvo_data[!is.na(nvo_label)], 
             aes(x = nvo_label, y = TALBVWTR_graad_TALBVWTR_, fill = nvo_label)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.2, alpha = 0.8, outlier.shape = NA) +
  annotate("text", x = 1.5, y = 85,
           label = paste0("Δ = ", round(diff5, 1), "°\n",
                         "p ", ifelse(test5$p.value < 0.001, "< 0.001", 
                                     paste0("= ", round(test5$p.value, 3))), " ", sig5),
           size = 5, fontface = "bold", color = "black") +
  scale_fill_manual(values = c("Geen NVO" = okabe_colors[9], 
                               "Wel NVO" = okabe_colors[4])) +
  scale_y_continuous(
    breaks = seq(0, 90, by = 10),
    labels = function(x) paste0(x, "°"),
    limits = c(0, 90)
  ) +
  labs(
    title = "Taludhoek bij wel/geen natuurvriendelijke oever",
    subtitle = "Lagere hoek = flauwer talud",
    x = "",
    y = "Taludhoek (graden)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold", color = "gray20"),
    plot.subtitle = element_text(size = 13, color = "gray50"),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30"),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 12, color = "gray40"),
    legend.position = "none",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA)
  )

print(p3)

# ============================================================================
# STATISTISCHE TESTS
# ============================================================================

cat("\n========================================")
cat("\nSTATISTISCHE TESTS")
cat("\n========================================\n")

cat("\n1. WATERDIEPTE vs BAGGEREN\n")
cat("Gemiddeld verschil:", round(diff1, 3), "m\n")
cat("p-waarde:", format.pval(test1$p.value, digits = 3), sig1, "\n")

cat("\n2. SLIBDIKTE vs BAGGEREN\n")
cat("Gemiddeld verschil:", round(diff2, 3), "m\n")
cat("p-waarde:", format.pval(test2$p.value, digits = 3), sig2, "\n")

cat("\n3. DOORZICHT vs SCHONEN\n")
cat("Gemiddeld verschil:", round(diff3, 3), "\n")
cat("p-waarde:", format.pval(test3$p.value, digits = 3), sig3, "\n")

cat("\n4. SLIBDIKTE vs SCHONEN\n")
cat("Gemiddeld verschil:", round(diff4, 3), "m\n")
cat("p-waarde:", format.pval(test4$p.value, digits = 3), sig4, "\n")

cat("\n5. TALUDHOEK vs NVO\n")
cat("Gemiddeld verschil:", round(diff5, 1), "graden\n")
cat("p-waarde:", format.pval(test5$p.value, digits = 3), sig5, "\n")

cat("\n========================================\n")
```

```{r VISUALISATIE: EMERSE VEGETATIE PER BEHEERTYPE extended}
# ============================================================================
# VISUALISATIE: EMERSE VEGETATIE PER BEHEERTYPE
# ============================================================================

# Bereken aantal observaties per groep
hybianlb[watertype %in% c('M10','M1a','M8'), 
         n_obs > 9,]

# Tel hoeveel unieke beheertypen je hebt
n_beheer <- uniqueN(hybianlb[parameterid == 'PTN_BEDKG_%' & 
                              parameter == 'EMSPTN' & 
                              compartiment == 'EZ' &
                              watertype %in% c('M10','M1a','M8'), beheer])

cat("Aantal beheertypen:", n_beheer, "\n")

# Genereer voldoende kleuren
getPalette <- palette.colors(palette = "Okabe-Ito")[-1]  # Verwijder zwart

# Als dat niet genoeg is, gebruik colorRampPalette om meer kleuren te maken
if(n_beheer > length(getPalette)) {
  getPalette <- colorRampPalette(palette.colors(palette = "Okabe-Ito")[-1])(n_beheer)
}

# ============================================================================
# BEREKEN AANTAL SOORTEN PER MONSTER - CONSISTENT MET EERDERE ANALYSES
# ============================================================================

# Gebruik EXACT DEZELFDE BEREKENING als in het vergelijkings-chunk
# Dit is de enige juiste manier om aantal soorten per monster te berekenen
n_soort_ems_data <- hybianlb[compartiment == 'EZ' & 
                              watertype %in% c('M10','M1a','M8'), 
                              .(n_soort_ems = uniqueN(biotaxonnaam[emers == 1]) - 1), 
                              by = .(monsterident, locatie, jaar, EAGIDENT, beheer, anlb)]

# Verwijder eventuele duplicaten (voor de zekerheid)
n_soort_ems_data <- unique(n_soort_ems_data)

# Check of monsterident uniek is
cat("Aantal unieke monsters:", uniqueN(n_soort_ems_data$monsterident), "\n")
cat("Aantal rijen in n_soort_ems_data:", nrow(n_soort_ems_data), "\n")
cat("Verschil (moet 0 zijn):", nrow(n_soort_ems_data) - uniqueN(n_soort_ems_data$monsterident), "\n")

# ============================================================================
# PLOT 1: EMERSE BEDEKKING PER BEHEERTYPE - MONSTER NIVEAU
# ============================================================================

n_obs_data_bedekking <- hybianlb[parameterid == 'PTN_BEDKG_%' & 
                                  parameter == 'EMSPTN' & 
                                  compartiment == 'EZ' &
                                  watertype %in% c('M10','M1a','M8') &
                                  n_obs > 9, 
                                  .(n = unique(n_obs)), 
                                  by = .(beheer)]

p_emers_bedekking <- ggplot(data = hybianlb[parameterid == 'PTN_BEDKG_%' & 
                                             parameter == 'EMSPTN' & 
                                             compartiment == 'EZ' &
                                             watertype %in% c('M10','M1a','M8') &
                                             n_obs > 9,]) +
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = beheer), 
               outlier.shape = NA) +
  geom_text(data = n_obs_data_bedekking, 
            aes(x = beheer, y = 95, label = n), 
            size = 3.5) +
  scale_fill_manual(values = getPalette) +
  guides(fill = guide_legend(title = 'Beheertype')) +
  ylim(0, 100) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    title = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 10),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 11),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  ) +
  ggtitle("Bedekking (monster niveau)") +
  labs(x = "", y = "Bedekking (%)")

# ============================================================================
# PLOT 2: AANTAL EMERSE SOORTEN PER BEHEERTYPE - MONSTER NIVEAU
# ============================================================================

# Filter alleen beheertypes met > 9 observaties
n_soort_ems_data[, n_obs_soorten := uniqueN(monsterident), by = beheer]
n_soort_ems_data_filtered <- n_soort_ems_data[n_obs_soorten > 9]

# Maak aparte dataset voor labels
n_obs_data_soorten <- n_soort_ems_data_filtered[, .(n = unique(n_obs_soorten)), by = beheer]

# Bereken max waarde voor label positie
max_soorten <- max(n_soort_ems_data_filtered$n_soort_ems, na.rm = TRUE)

p_emers_soorten <- ggplot(data = n_soort_ems_data_filtered) +
  geom_boxplot(aes(x = beheer, y = n_soort_ems, fill = beheer), 
               outlier.shape = NA) +
  geom_text(data = n_obs_data_soorten, 
            aes(x = beheer, y = max_soorten + 1, label = n),
            size = 3.5) +
  scale_fill_manual(values = getPalette) +
  guides(fill = guide_legend(title = 'Beheertype')) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    title = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 10),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 11),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  ) +
  ggtitle("Aantal soorten (monster niveau)") +
  labs(x = "", y = "Aantal soorten")

# ============================================================================
# CONTROLE: VERGELIJK MET EERDER GEMAAKTE PLOT
# ============================================================================

# Deze plot moet NU identiek zijn aan de plot uit het vergelijkings-chunk
p_controle <- ggplot(n_soort_ems_data_filtered) +
  geom_boxplot(aes(y = n_soort_ems, x = beheer, fill = anlb)) +
  scale_fill_manual(values = getPalette[1:2]) +
  theme_minimal() +
  ggtitle("CONTROLE: Aantal soorten per beheer (met anlb kleuring)") +
  labs(x = "Beheertype", y = "Aantal soorten")

print(p_controle)

# ============================================================================
# PLOT 3: EMERSE BEDEKKING PER BEHEERTYPE - EAG NIVEAU
# ============================================================================

# Bereken gemiddelde bedekking per EAG en beheertype
eag_gemiddelden <- hybianlb[parameterid == 'PTN_BEDKG_%' & 
                             parameter == 'EMSPTN' & 
                             compartiment == 'EZ' &
                             watertype %in% c('M10','M1a','M8'),
                             .(gem_bedekking = mean(as.numeric(meetwaarde), na.rm = TRUE),
                               n_monsters = .N),
                             by = .(EAGIDENT, jaar, beheer)]

# Tel aantal EAG's per beheertype
n_eag_data <- eag_gemiddelden[, .(n_eag = uniqueN(EAGIDENT)), by = beheer]

# Filter alleen beheertypes met > 5 EAG's voor overzichtelijkheid
eag_gemiddelden_filtered <- eag_gemiddelden[beheer %in% n_eag_data[n_eag > 5, beheer]]

p_emers_bedekking_eag <- ggplot(data = eag_gemiddelden_filtered) +
  geom_boxplot(aes(x = beheer, y = gem_bedekking, fill = beheer), 
               outlier.shape = NA) +
  geom_text(data = n_eag_data[n_eag > 5], 
            aes(x = beheer, y = 95, label = paste0("n=", n_eag)), 
            size = 3.5) +
  scale_fill_manual(values = getPalette) +
  guides(fill = guide_legend(title = 'Beheertype')) +
  ylim(0, 100) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    title = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 10),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 11),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  ) +
  ggtitle("Bedekking (EAG niveau)") +
  labs(x = "", y = "Gemiddelde bedekking per EAG (%)")

# ============================================================================
# PLOT 4: AANTAL EMERSE SOORTEN - EAG NIVEAU
# ============================================================================

# Bereken gemiddeld aantal soorten per EAG en beheertype
# GEBRUIK n_soort_ems_data die we eerder hebben gemaakt
eag_soorten <- n_soort_ems_data[, 
                                .(gem_soorten = mean(n_soort_ems, na.rm = TRUE)),
                                by = .(EAGIDENT, jaar, beheer, anlb)]

# Tel aantal EAG's per beheertype
n_eag_soorten <- eag_soorten[, .(n_eag = uniqueN(EAGIDENT)), by = beheer]

# Filter alleen beheertypes met > 5 EAG's
eag_soorten_filtered <- eag_soorten[beheer %in% n_eag_soorten[n_eag > 5, beheer]]

max_soorten_eag <- max(eag_soorten_filtered$gem_soorten, na.rm = TRUE)

p_emers_soorten_eag <- ggplot(data = eag_soorten_filtered) +
  geom_boxplot(aes(x = beheer, y = gem_soorten, fill = beheer), 
               outlier.shape = NA) +
  geom_text(data = n_eag_soorten[n_eag > 5], 
            aes(x = beheer, y = max_soorten_eag + 1, 
                label = paste0("n=", n_eag)), 
            size = 3.5) +
  scale_fill_manual(values = getPalette) +
  guides(fill = guide_legend(title = 'Beheertype')) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    title = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 10),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 11),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  ) +
  ggtitle("Aantal soorten (EAG niveau)") +
  labs(x = "", y = "Gemiddeld aantal soorten per EAG")

# ============================================================================
# GECOMBINEERDE PLOT: BEDEKKING EN SOORTEN, MONSTER BOVEN, EAG ONDER
# ============================================================================

library(gridExtra)

grid.arrange(p_emers_bedekking, p_emers_soorten,
             p_emers_bedekking_eag, p_emers_soorten_eag,
             ncol = 2, nrow = 2,
             top = grid::textGrob("Emerse vegetatie per beheertype", 
                                 gp = grid::gpar(fontsize = 16, fontface = "bold")))

# Sla op
ggsave("emerse_vegetatie_volledig.png", 
       arrangeGrob(p_emers_bedekking, p_emers_soorten,
                   p_emers_bedekking_eag, p_emers_soorten_eag,
                   ncol = 2, nrow = 2,
                   top = grid::textGrob("Emerse vegetatie per beheertype", 
                                       gp = grid::gpar(fontsize = 16, fontface = "bold"))),
       width = 16, height = 14, units = "in", dpi = 300)

# ============================================================================
# STATISTIEKEN
# ============================================================================

cat("\n========================================")
cat("\nSTATISTIEKEN EMERSE VEGETATIE")
cat("\n========================================\n")

cat("\nEmerse bedekking per beheertype (EAG niveau):\n")
bedekking_stats <- eag_gemiddelden[, .(
  gemiddelde = mean(gem_bedekking, na.rm = TRUE),
  mediaan = median(gem_bedekking, na.rm = TRUE),
  sd = sd(gem_bedekking, na.rm = TRUE),
  n_eag = uniqueN(EAGIDENT)
), by = beheer][order(-gemiddelde)]

print(bedekking_stats)

cat("\nAantal emerse soorten per beheertype (EAG niveau):\n")
soorten_stats <- eag_soorten[, .(
  gemiddelde = mean(gem_soorten, na.rm = TRUE),
  mediaan = median(gem_soorten, na.rm = TRUE),
  sd = sd(gem_soorten, na.rm = TRUE),
  n_eag = uniqueN(EAGIDENT)
), by = beheer][order(-gemiddelde)]

print(soorten_stats)
```

```{r VISUALISATIE: SUBMERSE VEGETATIE PER BEHEERTYPE extended}
# ============================================================================
# VISUALISATIE: VEGETATIE PER BEHEERTYPE
# ============================================================================

# Bereken aantal observaties per groep
hybianlb[watertype %in% c('M10','M1a','M8'), 
         n_obs > 9,]

# Tel hoeveel unieke beheertypen je hebt
n_beheer <- uniqueN(hybianlb[parameterid == 'PTN_BEDKG_%' & 
                              parameter == 'SUBMSPTN' & 
                              compartiment == 'EZ' &
                              watertype %in% c('M10','M1a','M8'), beheer])

cat("Aantal beheertypen:", n_beheer, "\n")

# Genereer voldoende kleuren
getPalette <- palette.colors(palette = "Okabe-Ito")[-1]  # Verwijder zwart

# Als dat niet genoeg is, gebruik colorRampPalette om meer kleuren te maken
if(n_beheer > length(getPalette)) {
  getPalette <- colorRampPalette(palette.colors(palette = "Okabe-Ito")[-1])(n_beheer)
}

# ============================================================================
# BEREKEN AANTAL SOORTEN PER MONSTER - CONSISTENT MET EERDERE ANALYSES
# ============================================================================

# Gebruik EXACT DEZELFDE BEREKENING als in het vergelijkings-chunk
# Dit is de enige juiste manier om aantal soorten per monster te berekenen
n_soort_subm_data <- hybianlb[compartiment == 'EZ' & 
                              watertype %in% c('M10','M1a','M8'), 
                              .(n_soort_subm = uniqueN(biotaxonnaam[submers == 1]) - 1), 
                              by = .(monsterident, locatie, jaar, EAGIDENT, beheer, anlb)]

# Verwijder eventuele duplicaten (voor de zekerheid)
n_soort_subm_data <- unique(n_soort_subm_data)

# Check of monsterident uniek is
cat("Aantal unieke monsters:", uniqueN(n_soort_subm_data$monsterident), "\n")
cat("Aantal rijen in n_soort_subm_data:", nrow(n_soort_subm_data), "\n")
cat("Verschil (moet 0 zijn):", nrow(n_soort_subm_data) - uniqueN(n_soort_subm_data$monsterident), "\n")

# ============================================================================
# PLOT 1: EMERSE BEDEKKING PER BEHEERTYPE - MONSTER NIVEAU
# ============================================================================

n_obs_data_bedekking <- hybianlb[parameterid == 'PTN_BEDKG_%' & 
                                  parameter == 'SUBMSPTN' & 
                                  compartiment == 'EZ' &
                                  watertype %in% c('M10','M1a','M8') &
                                  n_obs > 9, 
                                  .(n = unique(n_obs)), 
                                  by = .(beheer)]

p_submers_bedekking <- ggplot(data = hybianlb[parameterid == 'PTN_BEDKG_%' & 
                                             parameter == 'SUBMSPTN' & 
                                             compartiment == 'EZ' &
                                             watertype %in% c('M10','M1a','M8') &
                                             n_obs > 9,]) +
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = beheer), 
               outlier.shape = NA) +
  geom_text(data = n_obs_data_bedekking, 
            aes(x = beheer, y = 95, label = n), 
            size = 3.5) +
  scale_fill_manual(values = getPalette) +
  guides(fill = guide_legend(title = 'Beheertype')) +
  ylim(0, 100) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    title = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 14),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  ) +
  ggtitle("Bedekking (monster niveau)") +
  labs(x = "", y = "Bedekking (%)")

# ============================================================================
# PLOT 2: AANTAL subERSE SOORTEN PER BEHEERTYPE - MONSTER NIVEAU
# ============================================================================

# Filter alleen beheertypes met > 9 observaties
n_soort_subm_data[, n_obs_soorten := uniqueN(monsterident), by = beheer]
n_soort_subm_data_filtered <- n_soort_subm_data[n_obs_soorten > 9]

# Maak aparte dataset voor labels
n_obs_data_soorten <- n_soort_subm_data_filtered[, .(n = unique(n_obs_soorten)), by = beheer]

# Bereken max waarde voor label positie
max_soorten <- max(n_soort_subm_data_filtered$n_soort_subm, na.rm = TRUE)

p_submers_soorten <- ggplot(data = n_soort_subm_data_filtered) +
  geom_boxplot(aes(x = beheer, y = n_soort_subm, fill = beheer), 
               outlier.shape = NA) +
  geom_text(data = n_obs_data_soorten, 
            aes(x = beheer, y = max_soorten + 1, label = n),
            size = 3.5) +
  scale_fill_manual(values = getPalette) +
  guides(fill = guide_legend(title = 'Beheertype')) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    title = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 14),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  ) +
  ggtitle("Aantal soorten (monster niveau)") +
  labs(x = "", y = "Aantal soorten")

# ============================================================================
# CONTROLE: VERGELIJK MET EERDER GEMAAKTE PLOT
# ============================================================================

# Deze plot moet NU identiek zijn aan de plot uit het vergelijkings-chunk
p_controle <- ggplot(n_soort_subm_data_filtered) +
  geom_boxplot(aes(y = n_soort_subm, x = beheer, fill = anlb)) +
  scale_fill_manual(values = getPalette[1:2]) +
  theme_minimal() +
  ggtitle("CONTROLE: Aantal soorten per beheer (met anlb kleuring)") +
  labs(x = "Beheertype", y = "Aantal soorten")

print(p_controle)

# ============================================================================
# PLOT 3: EMERSE BEDEKKING PER BEHEERTYPE - EAG NIVEAU
# ============================================================================

# Bereken gemiddelde bedekking per EAG en beheertype
eag_gemiddelden <- hybianlb[parameterid == 'PTN_BEDKG_%' & 
                             parameter == 'SUBMSPTN' & 
                             compartiment == 'EZ' &
                             watertype %in% c('M10','M1a','M8'),
                             .(gem_bedekking = mean(as.numeric(meetwaarde), na.rm = TRUE),
                               n_monsters = .N),
                             by = .(EAGIDENT, jaar, beheer)]

# Tel aantal EAG's per beheertype
n_eag_data <- eag_gemiddelden[, .(n_eag = uniqueN(EAGIDENT)), by = beheer]

# Filter alleen beheertypes met > 5 EAG's voor overzichtelijkheid
eag_gemiddelden_filtered <- eag_gemiddelden[beheer %in% n_eag_data[n_eag > 5, beheer]]

p_submers_bedekking_eag <- ggplot(data = eag_gemiddelden_filtered) +
  geom_boxplot(aes(x = beheer, y = gem_bedekking, fill = beheer), 
               outlier.shape = NA) +
  geom_text(data = n_eag_data[n_eag > 5], 
            aes(x = beheer, y = 95, label = paste0("n=", n_eag)), 
            size = 3.5) +
  scale_fill_manual(values = getPalette) +
  guides(fill = guide_legend(title = 'Beheertype')) +
  ylim(0, 100) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    title = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 10),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 11),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  ) +
  ggtitle("Bedekking (EAG niveau)") +
  labs(x = "", y = "Gemiddelde bedekking per EAG (%)")

# ============================================================================
# PLOT 4: AANTAL submRSE SOORTEN - EAG NIVEAU
# ============================================================================

# Bereken gemiddeld aantal soorten per EAG en beheertype
# GEBRUIK n_soort_subm_data die we eerder hebben gemaakt
eag_soorten <- n_soort_subm_data[, 
                                .(gem_soorten = mean(n_soort_subm, na.rm = TRUE)),
                                by = .(EAGIDENT, jaar, beheer, anlb)]

# Tel aantal EAG's per beheertype
n_eag_soorten <- eag_soorten[, .(n_eag = uniqueN(EAGIDENT)), by = beheer]

# Filter alleen beheertypes met > 5 EAG's
eag_soorten_filtered <- eag_soorten[beheer %in% n_eag_soorten[n_eag > 5, beheer]]

max_soorten_eag <- max(eag_soorten_filtered$gem_soorten, na.rm = TRUE)

p_submers_soorten_eag <- ggplot(data = eag_soorten_filtered) +
  geom_boxplot(aes(x = beheer, y = gem_soorten, fill = beheer), 
               outlier.shape = NA) +
  geom_text(data = n_eag_soorten[n_eag > 5], 
            aes(x = beheer, y = max_soorten_eag + 1, 
                label = paste0("n=", n_eag)), 
            size = 3.5) +
  scale_fill_manual(values = getPalette) +
  guides(fill = guide_legend(title = 'Beheertype')) +
  theme_minimal() +
  theme(
    strip.background = element_blank(),
    title = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 10),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 11),
    legend.position = "none",
    plot.margin = margin(10, 10, 10, 10)
  ) +
  ggtitle("Aantal soorten (EAG niveau)") +
  labs(x = "", y = "Gemiddeld aantal soorten per EAG")

# ============================================================================
# GECOMBINEERDE PLOT: BEDEKKING EN SOORTEN, MONSTER BOVEN, EAG ONDER
# ============================================================================

library(gridExtra)

grid.arrange(p_submers_bedekking, p_submers_soorten,
             p_submers_bedekking_eag, p_submers_soorten_eag,
             ncol = 2, nrow = 2,
             top = grid::textGrob("Submerse vegetatie per beheertype", 
                                 gp = grid::gpar(fontsize = 16, fontface = "bold")))

grid.arrange(p_submers_bedekking, p_submers_soorten,
             ncol = 2, nrow = 1,
             top = grid::textGrob("Submerse vegetatie per beheertype", 
                                 gp = grid::gpar(fontsize = 16, fontface = "bold")))

# Sla op
ggsave("submerse_vegetatie_volledig.png", 
       arrangeGrob(p_emers_bedekking, p_emers_soorten,
                   p_emers_bedekking_eag, p_emers_soorten_eag,
                   ncol = 2, nrow = 2,
                   top = grid::textGrob("Emerse vegetatie per beheertype", 
                                       gp = grid::gpar(fontsize = 16, fontface = "bold"))),
       width = 16, height = 14, units = "in", dpi = 300)


```



#### hybi - parameters oud en vaak niet werkend
```{r emers versus beheer}
#| label: emers versus beheer 
getPalette = palette.colors(palette = "Okabe-Ito")[-c(1, 10)]
ss_emers <- anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter == 'EMSPTN' & compartiment == 'EZ' & watertype %in% c('M10','M1a','M8'),]
ss_emers[,n_obs:=uniqueN(externereferentie),by =c('parameter','jaar','beheer')]

ggplot(data = ss_emers[n_obs > 9,])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = beheer),) +
  geom_text(aes(x = beheer, y=110, label = n_obs), size = 4)+
  guides(fill=guide_legend(title='Beheer'))+
  scale_fill_manual(values = getPalette)+
  facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking emers") +
    labs(x="",y="%")

```

```{r emers bedekking by eag}
#| label: submerse bedekking by eag
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], EAGIDENT+jaar~anlb, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee, y = ja)) +
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14,
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren en/of schonen (%)")
```

```{r submers bedekking by eag bageren}
#| label: submerse bedekking by eag baggeren

anlbhybi[is.na(baggeren),baggeren:= 0]
anlbhybi[baggeren == 2, baggeren := 1]
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], EAGIDENT+jaar~baggeren, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = `0`, y = `1`)) +
  facet_wrap(jaar~.)+
  geom_abline(slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren en/of schonen (%)")
```

```{r data emers soorten vs beheer}
#| label: emers verus beheer soorten (geen combipakketten)
anlbhybi[watertype %in%c('M10','M1a','M8'),n_obs:=uniqueN(monsterident),by =c('parameterid','parameter','compartiment','beheer')]
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%"  
                               & compartiment == "EZ" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = n_soort_ems)) +
  geom_text(aes(x = beheer, y=max(anlbhybi$n_soort_ems, na.rm = T), label = n_obs))+
  facet_wrap(watertype~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Aantal unieke emerse soorten") +
    labs(x="",y="n")
  # ylim(0,15)
```

```{r data sluiting emers}
#| label: emers verus beheer sluiting (geen combipakketten)	
ggplot(data = anlbhybi[parameterid == "PTN_LENGTFTE_%"  
                               & parameter == "EMSPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=100, label = n_obs))+
  facet_wrap(watertype~.)+
    theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Sluitingspercentage emers") +
    labs(x="",y="%")
  # ylim(0,15)
```

```{r data breedte emers}	
#| label: emers verus beheer breedte (geen combipakketten)
ggplot(data = anlbhybi[parameterid == "PTN_BREEDTE_m"  
                               & parameter == "EMSPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=max(anlbhybi[parameterid == "PTN_BREEDTE_m"  
                               & parameter == "EMSPTN" 
                               & watertype %in%
                          c('M10','M1a','M8'),'meetwaarde']+0.1), label = n_obs))+
  facet_wrap(watertype~.)+
    theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Breedte emers") +
    labs(x="",y="m")
```

#### Oever
```{r data oeverplanten vs beheer}
#| label: oeverplanten verus beheer (geen combipakketten)	
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%"  
                               & parameter == "OEVPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=100, label = n_obs))+
  facet_wrap(watertype~.)+
   theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking oeverplanten boven de waterlijn") +
    labs(x="",y="%")
  # ylim(0,15)
```

```{r data oever soorten vs beheer}
#| label: oever verus beheer soorten (geen combipakketten)
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%" & parameter == ""
                               & compartiment == "OR" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = n_soort_oever)) +
  geom_text(aes(x = beheer, y=max(anlbhybi$n_soort_oever, na.rm = TRUE), label = n_obs))+
  facet_wrap(watertype~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Aantal unieke oeversoorten") +
    labs(x="",y="n")
```

```{r data sluiting oeverplanten}	
ggplot(data = anlbhybi[parameterid == "PTN_LENGTFTE_%"  
                               & parameter == "OEVPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=100, label = n_obs))+
  facet_wrap(watertype~.)+
   theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Sluitingspercentage oeverplanten") +
    labs(x="",y="%")
  # ylim(0,15)
```

#### Submers
```{r submers vs beheer}
#| label: submers
ss_submers <- anlbhybi[parameter == 'SUBMSPTN' & compartiment == 'EZ' & watertype %in% c('M10','M1a','M8'),]
ss_submers[,n_obs:=uniqueN(externereferentie),by =c('parameter','jaar','beheer')]

ggplot(data = ss_submers[n_obs > 9,])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = beheer)) +
  geom_text(aes(x = beheer, y=110, label = n_obs), size = 4)+
  guides(fill=guide_legend(title='Beheer'))+
  scale_fill_manual(values = getPalette)+
  facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers") +
    labs(x="",y="%")
```

```{r submers bedekking by eag}
#| label: submerse bedekking by eag
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], EAGIDENT+jaar~anlb, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee, y = ja)) +
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12, angle = 45, hjust =1),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Bedekking submers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren en/of schonen (%)")
```

```{r submers bedekking by eag bageren}
#| label: submerse bedekking by eag baggeren

anlbhybi[is.na(baggeren),baggeren:= 0]
anlbhybi[baggeren == 2, baggeren := 1]
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], EAGIDENT+jaar~baggeren, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = `0`, y = `1`)) +
  facet_wrap(jaar~.)+
  geom_abline(slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren (%)")
```

```{r submers bedekking by eag schonen}
#| label: submerse bedekking by eag schonen

anlbhybi[is.na(slootschonen),slootschonen:= 0]
anlbhybi[slootschonen == 2, slootschonen := 1]
ss_beheer_cast <- dcast(anlbhybi[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], EAGIDENT+jaar~slootschonen, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = `0`, y = `1`)) +
  # facet_wrap(jaar~.)+
  geom_abline(slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submers") +
    labs(x="geen beheerpakket (%)",y="beheerpakket schonen (%)")
```

```{r data submers vs beheer per watertype}	
#| label: submers verus beheer (geen combipakketten)
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%"  
                               & parameter == "SUBMSPTN" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = meetwaarde)) +
  geom_text(aes(x = beheer, y=100, label = n_obs))+
  # facet_wrap(watertype~.)+
   theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submerse planten") +
    labs(x="",y="%")
  # ylim(0,15)
```

```{r data submers soorten vs beheer}
#| label: submers verus beheer soorten (geen combipakketten)
ggplot(data = anlbhybi[parameterid == "PTN_BEDKG_%"  
                               & compartiment == "EZ" 
                               & watertype %in%
                          c('M10','M1a','M8')])+
  geom_boxplot(aes(x = beheer, y = n_soort_sub)) +
  geom_text(aes(x = beheer, y=max(anlbhybi$n_soort_sub, na.rm = TRUE), label = n_obs))+
  facet_wrap(watertype~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Aantal unieke submerse soorten") +
    labs(x="",y="n")
```

```{r submers vs doorzicht}
#| label: submers vs doorzicht

palette <- palette.colors(palette = "Okabe-Ito", n = unique(anlbhybi_cast$jaar))
ggplot(data = anlbhybi_cast)+
  geom_point(aes(x = zichtdte , y = `PTN_BEDKG_%_SUBMSPTN_`, color = as.factor(jaar))) +
  geom_smooth(aes(x = zichtdte , y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'lm', color = 'black')+
  xlim(0,1)+
  # facet_wrap(anlb~.)+
  scale_color_manual(values = palette, name = 'Jaar')+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Doorzicht vs bedekking submers") +
    labs(x="doorzicht/waterdiepte",y="bedekking submers (%)")

# Bereid data voor en maak waterdiepte categorieën
ss_cast_plot <- anlbhybi_cast[!is.na(`PTN_BEDKG_%_SUBMSPTN_`) & zichtdte <= 1]

# Maak waterdiepte categorieën met nieuwe indeling
ss_cast_plot[, waterdiepte_cat := case_when(
  WATDTE_m_WATDTE_ <= 0.3 ~ "Zeer ondiep (≤ 0.3m)",
  WATDTE_m_WATDTE_ > 0.3 & WATDTE_m_WATDTE_ <= 0.4 ~ "Ondiep (0.3-0.4m)",
  WATDTE_m_WATDTE_ > 0.4 & WATDTE_m_WATDTE_ <= 0.5 ~ "Matig diep (0.4-0.5m)",
  WATDTE_m_WATDTE_ > 0.5 & WATDTE_m_WATDTE_ <= 1.0 ~ "Diep (0.5-1.0m)",
  TRUE ~ "Zeer diep (> 1.0m)"
)]

# Maak waterdiepte_cat een factor met juiste volgorde
ss_cast_plot[, waterdiepte_cat := factor(waterdiepte_cat, 
  levels = c("Zeer ondiep (≤ 0.3m)", "Ondiep (0.3-0.4m)", 
             "Matig diep (0.4-0.5m)", "Diep (0.5-1.0m)", "Zeer diep (> 1.0m)"))]

# Kleurenpalet voor betere onderscheiding
diepte_kleuren <- c(
  "Zeer ondiep (≤ 0.3m)" = "#d73027",      # Donkerrood
  "Ondiep (0.3-0.4m)" = "#fc8d59",         # Oranje  
  "Matig diep (0.4-0.5m)" = "#fee08b",     # Lichtgeel
  "Diep (0.5-1.0m)" = "#4575b4",           # Blauw
  "Zeer diep (> 1.0m)" = "#313695"         # Donkerblauw
)

# Maak de verbeterde plot
ggplot(data = ss_cast_plot) +
  geom_jitter(aes(x = zichtdte, y = `PTN_BEDKG_%_SUBMSPTN_`, 
                  color = waterdiepte_cat), 
              width = 0.02, alpha = 0.7, size = 5, stroke = 0) +
  
  # Alleen trendlijnen per waterdiepte categorie
  geom_smooth(aes(x = zichtdte, y = `PTN_BEDKG_%_SUBMSPTN_`), 
              method = 'loess', se = TRUE, linewidth = 1.2, alpha = 0.3) +
  
  # Kleurschaal
  scale_color_manual(
    values = diepte_kleuren,
    name = "Waterdiepte categorie",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 4, alpha = 1)
    )
  ) +
  
  # Verbeterde schaling
  scale_x_continuous(
    breaks = seq(0, 1, by = 0.2),
    labels = function(x) paste0(x),
    limits = c(0, 1)
  ) +
  
  scale_y_continuous(
    breaks = seq(0, 100, by = 20),
    labels = function(x) paste0(x, "%"),
    limits = c(0, 100)
  ) +
  
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submerse vegetatie en lichtklimaat",
    x = "Doorzicht / Waterdiepte ratio (-)",
    y = "Bedekking submerse vegetatie (%)"
  )

```

```{r submers vs waterdiepte}
#| label: submers vs waterdiepte

palette<- palette.colors(palette = "Okabe-Ito", n = unique(anlbhybi_cast$jaar))

ggplot(data = anlbhybi_cast)+
  geom_point(aes(x = WATDTE_m_WATDTE_ , y = `PTN_BEDKG_%_SUBMSPTN_`, color = as.factor(jaar))) +
  geom_smooth(aes(x = WATDTE_m_WATDTE_ , y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'loess', color = 'black')+
  xlim(0,1)+
  # facet_wrap(anlb~.)+
  scale_color_manual(values = palette, name = 'Jaar')+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 12),
      axis.text.y = element_text(size= 12),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=12))+
    ggtitle( "Waterdiepte vs bedekking submers") +
    labs(x="waterdiepte",y="bedekking submers (%)")

 ggplot(data = anlbhybi_cast[!is.na(`PTN_BEDKG_%_SUBMSPTN_`) & !is.na(ZICHT_m_ZICHT_) & WATDTE_m_WATDTE_ ,])+
  geom_jitter(aes(x = WATDTE_m_WATDTE_, y = `PTN_BEDKG_%_SUBMSPTN_`), 
              width = 0.02, alpha = 0.7, size = 4, stroke = 0) +
  geom_smooth(aes(x = WATDTE_m_WATDTE_, y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'loess', color = 'black')+
  geom_smooth(aes(x = WATDTE_m_WATDTE_, y = `PTN_BEDKG_%_SUBMSPTN_`), 
              method = 'loess', se = TRUE, linewidth = 1.2, alpha = 0.3) +
  # Verbeterde schaling
  scale_x_continuous(
    breaks = seq(0, 1, by = 0.2),
    labels = function(x) paste0(x),
    limits = c(0, 1)
  ) +
  
  scale_y_continuous(
    breaks = seq(0, 100, by = 20),
    labels = function(x) paste0(x, "%"),
    limits = c(0, 100)
  ) +
  
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submerse vegetatie en waterdiepte",
    x = "Waterdiepte (m)",
    y = "Bedekking submerse vegetatie (%)"
  ) 

```

#### fysische parameters

```{r data waterdiepte vs beheer}	
#| label: waterdiepte verus beheer (geen combipakketten)
ggplot()+
  geom_boxplot(data = anlbhybi[ parameterid == "TALBVWTR_graad"  ], aes(x = beheer, y = meetwaarde))#+ ylim(0,15)

ggplot()+
  geom_boxplot(data = anlbhybi[parameterid == "WATDTE_m" &
                              watertype %in% c('M10','M1a','M8')], aes(x = beheer, y = meetwaarde))+ ylim(0,1)
```

### Skenjesloot - Anlb
```{r pakketten vergelijking}
#| label: aantal gemeten jaren per locatie
anlbsjs_cast[,jaar_char := as.character(jaar_sjs)]
anlbsjs_cast[,baggerensjs := ifelse(baggerensjs == 'baggeren', 1, 0)]
anlbsjs_cast[is.na(baggerensjs),baggerensjs := 0]
anlbsjs_cast[baggerenanlb == 2,baggerenanlb := 1]
anlbsjs_cast[,schonen := ifelse(schonen == 'schonen', 1, 0)]
anlbsjs_cast[is.na(schonen),schonen := 0]
anlbsjs_cast[slootschonen == 2,slootschonen := 1]
anlbsjs_cast[,nvo := ifelse(nvo == 'nvo', 1, 0)]
anlbsjs_cast[is.na(nvo),nvo := 0]
anlbsjs_cast[nat.vriend.oever == 2,nat.vriend.oever := 1]

# Maak een nieuwe variabele voor overeenkomst tussen SJS en ANLB
# Voor baggeren vergelijking
anlbsjs_cast[, baggeren_match := fifelse(
  baggerensjs == baggerenanlb, "Overeenkomst", 
  fifelse(baggerensjs != baggerenanlb, "Verschil", "Onbekend")
)]

# Voor schonen vergelijking
anlbsjs_cast[, schonen_match := fifelse(
  schonen == slootschonen, "Overeenkomst", 
  fifelse(schonen != slootschonen, "Verschil", "Onbekend")
)]

# Voor NVO vergelijking
anlbsjs_cast[, nvo_match := fifelse(
  nvo == nat.vriend.oever, "Overeenkomst", 
  fifelse(nvo != nat.vriend.oever, "Verschil", "Onbekend")
)]

# Voor meer subtiele groene kleuren uit het Okabe-Ito pallet
okabe_colors <- palette.colors(palette = "Okabe-Ito")

# Gebruik specifieke kleuren uit het Okabe-Ito pallet
p1 <- ggplot(data = anlbsjs_cast) +
  geom_bar(aes(x = as.factor(baggerensjs), fill = baggeren_match), 
           position = 'stack', stat = 'count') +
  facet_grid(. ~ jaar_char) +
  scale_x_discrete(labels = c('Geen', 'Wel')) +
  scale_fill_manual(values = c("Overeenkomst" = okabe_colors[4],    # Groene tint
                              "Verschil" = okabe_colors[7],         # Oranje/rode tint  
                              "Onbekend" = "gray50"),
                   labels = c("SJS = ANLB", "SJS ≠ ANLB", "Onbekend")) +
  guides(fill = guide_legend(title = 'SJS vs ANLB')) +
  labs(title = "Baggeren",
       x = "Wel of geen baggerpakket Sken je sloot", 
       y = "Aantal locaties") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold")
  )

# Voor p2 en p3 gebruik je dezelfde kleuren:
p2 <- ggplot(data = anlbsjs_cast) +
  geom_bar(aes(x = as.factor(schonen), fill = schonen_match), 
           position = 'stack', stat = 'count') +
  facet_grid(. ~ jaar_char) +
  scale_x_discrete(labels = c('Geen', 'Wel')) +
  scale_fill_manual(values = c("Overeenkomst" = okabe_colors[4],    
                              "Verschil" = okabe_colors[7],         
                              "Onbekend" = "gray50"),
                   labels = c("SJS = ANLB", "SJS ≠ ANLB", "Onbekend")) +
  guides(fill = guide_legend(title = 'SJS vs ANLB')) +
  labs(title = "Schonen",
       x = "Wel of geen pakket ecologisch schonen Sken je sloot", 
       y = "Aantal locaties") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold")
  )

p3 <- ggplot(data = anlbsjs_cast) +
  geom_bar(aes(x = as.factor(nvo), fill = nvo_match), 
           position = 'stack', stat = 'count') +
  facet_grid(. ~ jaar_char) +
  scale_x_discrete(labels = c('Geen', 'Wel')) +
  scale_fill_manual(values = c("Overeenkomst" = okabe_colors[4],    
                              "Verschil" = okabe_colors[7],         
                              "Onbekend" = "gray50"),
                   labels = c("SJS = ANLB", "SJS ≠ ANLB", "Onbekend")) +
  guides(fill = guide_legend(title = 'SJS vs ANLB')) +
  labs(title = "Natuurvriendelijke oever",
       x = "Wel of geen natuurvriendelijke oever Sken je sloot", 
       y = "Aantal locaties") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    plot.title = element_text(size = 18, face = "bold"),
    strip.text = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14, face = "bold")
  )

# Print plots
print(p1)
print(p2) 
print(p3)

grid.arrange(p1, p2, p3, ncol = 1)

# Als je de kleuren wilt zien:
print(okabe_colors)

# Create overlap analysis
overlap_analysis <- anlbsjs_cast[, .(
  beide_baggeren = sum(baggerensjs == 1 & baggerenanlb == 1, na.rm = TRUE),
  alleen_sjs_baggeren = sum(baggerensjs == 1 & baggerenanlb == 0, na.rm = TRUE),
  alleen_anlb_baggeren = sum(baggerensjs == 0 & baggerenanlb == 1, na.rm = TRUE),
  beide_geen_baggeren = sum(baggerensjs == 0 & baggerenanlb == 0, na.rm = TRUE)
)]

print("Overlap analyse baggeren:")
print(overlap_analysis)
```

### Skenjesloot - locaties
```{r n jaren per loc}
#| label: aantal gemeten jaren per locatie
ggplot(data = skenjeslootloc)+
  geom_histogram(aes(x = nmeetjaar, fill = as.factor(jaar)), binwidth = 1) +
  guides(fill=guide_legend(title=''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Aantal gemeten jaren per locatie in (s)Ken je sloot") +
    labs(x="",y="aantal unieke monsters (metingen)")

```

### Skenjesloot - parameters

```{r overview skenjesloot}
#| label: overview sjs
# overzichttabel obv csv bestanden
ov_sjs <- dcast(skenjesloot, parameterid+naam+`vraag sken je sloot`+parameter+parameterfractie+eenheid~jaar)
fwrite(ov_sjs, file= paste0('skenjesloot_pars.csv'), sep = ';', dec ='.', )

# figuur metingen per pakket per jaar (csv) --------------

ggplot(data = skenjesloot[grepl('^BEHPK', parameterid),])+
  geom_bar(aes(x = naam, fill = as.factor(meetwaarde)), 
           position = 'stack') +
  coord_flip()+
  facet_wrap(~jaar)+
  scale_fill_discrete(labels = c('afwezig','aanwezig','onbekend'))+
  guides(fill=guide_legend(title=''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Beheerpakketten in (s)Ken je sloot") +
    labs(x="",y="aantal opnamen")

# figuur n pakket per jaar (csv) --------------
# & Code %in% c('2501-EAG-1','2501-EAG-2','2505-EAG-1','2502-EAG-1','2510-EAG-1'
colourCount = uniqueN(npakket[, 'V1'])
# getPalette = colorRampPalette(brewer.pal(8, "Set2"))
getPalette = colorRampPalette(palette.colors(palette = "Okabe-Ito"))
ggplot(data = npakket)+
  geom_bar(aes(x = jaar, fill = as.factor(V1)), 
           position = 'stack') +
  # coord_flip()+
  scale_fill_discrete(palette = getPalette(colourCount), labels = c('geen anlb','1 pakket','2 pakketten','3 pakketten','4 pakketten','5 pakketten','6 pakketten','7 pakketten'))+
  guides(fill=guide_legend(title=''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 14),
      axis.text.y = element_text(size= 14),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      legend.text = element_text(size=14),
      legend.title = element_text(size=14),
      plot.background = element_blank(),
      axis.title=element_text(size=14))+
    ggtitle( "Beheerpakketten in (s)Ken je sloot") +
    labs(x="",y="aantal opnamen")

# figuur welke pakket per jaar (csv) --------------
ggplot(data = checknobs)+
  geom_col(aes(x = jaar, y = V1, fill = as.factor(beheer)), 
           position = 'dodge') +                            guides(fill=guide_legend(title='Type beheer'))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Beheerpakketten in (s)Ken je sloot") +
    labs(x="",y="aantal opnamen")
```

#### Emers 
```{r bedekking vs beheer}
#| label: bedekking emers by beheer
getPalette = palette.colors(palette = "Okabe-Ito")[-c(1, 9)]
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameterid','parameter','jaar','beheer')]
# Bereken n_obs en maak een aparte dataset voor de labels
n_obs_data <- ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter == 'EMSPTN' & n_obs > 9, 
                        .(n = unique(n_obs)), 
                        by = .(beheer, jaar)]

ggplot(data = ss_beheer[parameterid == 'PTN_BEDKG_%'&
                          parameter =='EMSPTN' & n_obs > 9,])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = welnietbeheer), outliers = FALSE) +
  # Gebruik de aparte n_obs dataset voor de labels
  geom_text(data = n_obs_data, 
            aes(x = beheer, y = 85, label = n), 
            size = 5) +
  
  scale_fill_discrete(palette = getPalette) +
  guides(fill = guide_legend(title = 'Aangepast beheer?')) +
  facet_wrap(jaar ~ ., ncol = 2) +
  theme(
    size = 14,
    strip.background = element_blank(),
    title = element_text(size = 14),
    axis.text.x = element_text(size = 14, angle = 90, hjust = 1, vjust = 0),
    axis.text.y = element_text(size = 14),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    legend.position = "bottom",
    strip.text = element_text(size = 14)
  ) +
  ggtitle("Bedekking emerse vegetatie per beheertype") +
  labs(x = "", y = "%") +
  ylim(0, 90)


# zonder beheer variatie jaren
# Bereken n_obs en maak een aparte dataset voor de labels

ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameterid','parameter','jaar')]
n_obs_data <- ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter == 'EMSPTN' , 
                        .(n = unique(n_obs)), 
                        by = .(jaar)]

ggplot(data = ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter == 'EMSPTN' ,]) +
  geom_boxplot(aes(x = as.character(jaar), y = as.numeric(meetwaarde), fill = welnietbeheer), outliers = FALSE) +
  # Gebruik de aparte n_obs dataset voor de labels
  geom_text(data = n_obs_data, 
            aes(x = as.character(jaar), y = 85, label = n), 
            size = 5) +
  scale_fill_discrete(palette = getPalette) +
  guides(fill = guide_legend(title = 'Beheerpakket?')) +
  # facet_wrap(jaar ~ ., ncol = 2) +
  theme(
    size = 14,
    strip.background = element_blank(),
    title = element_text(size = 14),
    axis.text.x = element_text(size = 14, angle = 90, hjust = 1, vjust = 0),
    axis.text.y = element_text(size = 14),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    legend.position = "bottom",
    strip.text = element_text(size = 14)
  ) +
  ggtitle("Bedekking emerse vegetatie per beheertype") +
  labs(x = "", y = "%") +
  ylim(0, 90)

```

Emerse bedekking is lager in sloten met een beheerpakket baggeren. In sloten met afrastering en natuurvriendelijke oevers is de bedekking emers juist hoger. Dit kan komen doordat afrastering begrazing beperkt, wat gunstig is voor de ontwikkeling van oever- en moerasvegetatie. In sloten met een beheerpakket schonen is de bedekking emers vergelijkbaar met sloten zonder beheerpakket.

```{r bedekking emers wel niet bagger per EAG}
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], Code+jaar~baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietbaggeren := `NA`]

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietbaggeren , y = baggeren, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
    xlim(0, 40)+
    ylim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 13, face = "bold", color = "gray30"),
    legend.text = element_text(size = 11, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking emerse vegetatie - anlb-beheerpakket baggeren",
    x = "locaties zonder beheerpakket (%)",
    y = "locaties met beheerpakket baggeren (%)"
  )
  
```

```{r bedekking emers wel niet bagger per EAG }
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer[,PERODSLSBGODHD_a := as.numeric(PERODSLSBGODHD_a)]
ss_beheer[,recent_bagger := fifelse(PERODSLSBGODHD_a <=1, 'ja', 'nee')]
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], Code+jaar~recent_bagger, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee , y = ja, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
     xlim(0, 40)+
    ylim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking emerse vegetatie - recent gebaggerd",
    x = "locaties waar langer dan een jaar geleden is gebaggerd (%)",
    y = "locaties waar minder dan een jaar geleden is gebaggerd (%)"
  )
```

De bedekking emers is gemiddeld hoger in sloten zonder beheerpakket baggeren. Dit kan komen doordat baggeren de vegetatie (tijdelijk) verstoort. Zeker waarneer dit jaarlijks of meerdere keren per jaar gebeurt. In sloten met een beheerpakket baggeren is de bedekking emers in 2018 tot en met 2022 gemiddeld lager dan in 2023 en 2024. Mogelijk komt dit doordat in deze laatste jaren minder vaak is gebaggerd, of omdat er meer tijd is geweest voor herstel van de vegetatie na het baggeren.

```{r bedekking emers wel niet schonen per EAG}
#| label: bedekking analysis by EAG - emers by schonen
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], Code+jaar~schonen+baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietschonen := `NA_NA`]
ss_beheer_cast <- ss_beheer_cast[, schonen := `schonen_NA`]


ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietschonen , y = schonen, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
     xlim(0, 40)+
    ylim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking emerse vegetatie - beheerpakket schonen",
    x = "bedekking op locaties zonder beheerpakket (%)",
    y = "bedekking op locaties met beheerpakket (%)"
  )
   

```

```{r bedekking emers wel niet schonen2 per EAG}
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer[,PERODSLSSNG_mnd := as.numeric(PERODSLSSNG_mnd)]
ss_beheer[,recent_schonen := fifelse(PERODSLSSNG_mnd <=6, 'ja', 'nee')]
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], Code+jaar~recent_schonen, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee , y = ja, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
    xlim(0, 40)+
    ylim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking emerse vegetatie - recent geschoond",
    x = "locaties waar langer dan een half jaar geleden is geschoond (%)",
    y = "locaties waar minder dan een half jaar geleden is geschoond (%)"
  )
```

Er is geen duidelijk verschil in bedekking emers tussen sloten met en zonder beheerpakket schonen. Mogelijk komt dit doordat er in sloten met een beheerpakket soms vaker is geschoond dan in sloten zonder beheerpakket. Schoonmaken kan de vegetatie (tijdelijk) verstoren, ook als dit op ecologische wijze gebeurt. 

```{r bedekking emers wel niet afrastering per EAG}
#| label: bedekking analysis by EAG - emers by afrastering

ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='EMSPTN',], Code+jaar~afrastering, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietafrasteren := `NA`]
ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietafrasteren , y = afrastering)) +
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers - beheerpakket afrasteren") +
    labs(x="bedekking op locaties zonder beheerpakket (%)",y="bedekking op locaties met beheerpakket (%)")
```

Alleen in 2023 is duidelijk een hogere bedekking emers in sloten met een beheerpakket afrastering. Mogelijk komt dit doordat afrastering begrazing beperkt, wat gunstig is voor de ontwikkeling van oever- en moerasvegetatie. In andere jaren is dit effect niet duidelijk zichtbaar, mogelijk doordat er in deze jaren ook andere pakketten (met een tijdelijk negatief effect) zijn afgesloten op locaties waar afrastering stond.

```{r emers vs waterbreedt}
#| label: emers vs waterbreedte
ss_cast <- dcast(ss_beheer, externereferentie+jaar+welnietbeheer~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde')

# plot emers vs waterbreedte
ggplot(data = ss_cast[!is.na(`PTN_BEDKG_%_EMSPTN_`),])+
  geom_jitter(aes(x = WATERBTE_m_WATERBTE_, y = `PTN_BEDKG_%_EMSPTN_`, color = as.factor(jaar)), size = 5) +
  geom_smooth(aes(x = WATERBTE_m_WATERBTE_, y = `PTN_BEDKG_%_EMSPTN_`), method = 'loess', color = 'black', se = TRUE)+
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
    xlim(0, 20)+
    ylim(0, 40)+
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking emerse vegetatie - waterbreedte",
    x = "waterbreedte (m)",
    y = "emerse bedekking (%)"
  )



```

#### Submers

```{r submers bedekking by beheer}
#| label: submers bedekking by beheer

getPalette = palette.colors(palette = "Okabe-Ito")[-c(1, 9)]

ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameterid','parameter','jaar','beheer')]
# Bereken n_obs en maak een aparte dataset voor de labels
n_obs_data <- ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter == 'SUBMSPTN' & n_obs > 5, 
                        .(n = unique(n_obs)), 
                        by = .(beheer, jaar)]

ggplot(data = ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter == 'SUBMSPTN' & n_obs > 5,]) +
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde), fill = welnietbeheer), outliers = FALSE) +
  
  # Gebruik de aparte n_obs dataset voor de labels
  geom_text(data = n_obs_data, 
            aes(x = beheer, y = 85, label = n), 
            size = 5) +
  
  scale_fill_discrete(palette = getPalette) +
  guides(fill = guide_legend(title = 'Aangepast beheer?', nrow =1)) +
  facet_wrap(jaar ~ ., ncol = 2) +
  theme(
    size = 14,
    strip.background = element_blank(),
    title = element_text(size = 14),
    axis.text.x = element_text(size = 14, angle = 90, hjust = 1, vjust = 0),
    axis.text.y = element_text(size = 14),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    legend.position = "bottom",
    strip.text = element_text(size = 14)
  ) +
  ggtitle("Bedekking submerse vegetatie per beheertype") +
  labs(x = "", y = "%") +
  ylim(0, 90)

ggsave(plot = last_plot(), filename = 'sjs_bedekking_emers_beheer.png', width = 50, height = 25, units = 'cm', dpi = 600)

# zonder beheer variatie jaren
# Bereken n_obs en maak een aparte dataset voor de labels

ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameterid','parameter','jaar')]
n_obs_data <- ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter == 'SUBMSPTN' , 
                        .(n = unique(n_obs)), 
                        by = .(jaar)]

ggplot(data = ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter == 'SUBMSPTN' ,]) +
  geom_boxplot(aes(x = as.character(jaar), y = as.numeric(meetwaarde), fill = welnietbeheer), outliers = FALSE) +
  # Gebruik de aparte n_obs dataset voor de labels
  geom_text(data = n_obs_data, 
            aes(x = as.character(jaar), y = 85, label = n), 
            size = 5) +
  scale_fill_discrete(palette = getPalette) +
  guides(fill = guide_legend(title = 'Beheerpakket?')) +
  # facet_wrap(jaar ~ ., ncol = 2) +
  theme(
    size = 14,
    strip.background = element_blank(),
    title = element_text(size = 14),
    axis.text.x = element_text(size = 14, angle = 90, hjust = 1, vjust = 0),
    axis.text.y = element_text(size = 14),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 14)
  ) +
  ggtitle("Bedekking submerse vegetatie") +
  labs(x = "", y = "%") +
  ylim(0, 90)

```

```{r submers bedekking by eag schonen}
#| label: submerse bedekking by eag schonen

ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], Code+jaar~schonen+baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietschonen := `NA_NA`]
ss_beheer_cast <- ss_beheer_cast[, schonen := `schonen_NA`]


ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietschonen , y = schonen, color = as.factor(jaar))) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1)
    )
  ) +
  xlim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 13, face = "bold", color = "gray30"),
    legend.text = element_text(size = 11, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submers - beheerpakket ecologisch slootschonen",
    subtitle = "Relatie tussen doorzicht/waterdiepte ratio en vegetatiebedekking per waterdiepte",
    x = "locaties zonder beheerpakket (%)",
    y = "locaties met beheerpakket schonen (%)"
  )

# obv data
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameter','baggeren','PERODSLSSNG_mnd' )]
ss_beheer[,PERODSLSSNG_mnd := as.numeric(PERODSLSSNG_mnd)]
ggplot(data = ss_beheer[parameter == 'SUBMSPTN' & !is.na(PERODSLSSNG_mnd),], 
       aes(x = PERODSLSSNG_mnd, y = as.numeric(meetwaarde))) +
  # Voeg een subtiele achtergrondkleur toe voor de datapunten
  geom_jitter(width = 0.3, height = 0, alpha = 0.6, size = 2.5, 
              color = "steelblue", stroke = 0) +
  # Voeg een smoothing lijn toe om de trend te laten zien
  geom_smooth(method = "loess", se = TRUE, color = "#E31A1C", 
              fill = "#E31A1C", alpha = 0.2, linewidth = 1.2, fullrange = TRUE) +
    # Verbeterde schaling van de x-as
  scale_x_continuous(
    breaks = seq(0, max(ss_beheer[parameter == 'SUBMSPTN' & !is.na(PERODSLSSNG_mnd), PERODSLSSNG_mnd], na.rm = TRUE), by = 12),
    labels = function(x) paste(x, "mnd"),
    limits = c(0, 84)
  ) +
  # Verbeterde schaling van de y-as
  scale_y_continuous(
    breaks = seq(0, 100, by = 20),
    labels = function(x) paste0(x, "%"),
    limits = c(0, 100)
  ) +
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde titel en labels
  labs(
    title = "Bedekking Submerse vegetatie na Slootschonen",
    subtitle = "Relatie tussen schonen en vegetatiebedekking",
    x = "Tijd sinds laatste keer schonen (maanden)",
    y = "Bedekking (%)",
    caption = "Rode lijn toont de trend"
  )


```


```{r bedekking submers wel niet schonen per EAG}
#| label: bedekking analysis by EAG - emers by schonen
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], Code+jaar~schonen+baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietschonen := `NA_NA`]
ss_beheer_cast <- ss_beheer_cast[, schonen := `schonen_NA`]


ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietschonen , y = schonen, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
     xlim(0, 40)+
    ylim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submerse vegetatie - beheerpakket schonen",
    x = "bedekking op locaties zonder beheerpakket (%)",
    y = "bedekking op locaties met beheerpakket (%)"
  )
   

```

```{r bedekking submers wel niet schonen2 per EAG}
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer[,PERODSLSSNG_mnd := as.numeric(PERODSLSSNG_mnd)]
ss_beheer[,recent_schonen := fifelse(PERODSLSSNG_mnd <=6, 'ja', 'nee')]
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], Code+jaar~recent_schonen, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee , y = ja, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
    xlim(0, 40)+
    ylim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submerse vegetatie - recent geschoond",
    x = "locaties waar langer dan een half jaar geleden is geschoond (%)",
    y = "locaties waar minder dan een half jaar geleden is geschoond (%)"
  )
```

```{r bedekking emers wel niet bagger per EAG}
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer[,PERODSLSSNG_mnd := as.numeric(PERODSLSSNG_mnd)]
ss_beheer[,recent_schonen := fifelse(PERODSLSSNG_mnd <=6, 'ja', 'nee')]
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], Code+jaar~recent_schonen, value.var = 'meetwaarde', fun.aggregate = mean)

ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee , y = ja, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
    xlim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submerse vegetatie - recent geschoond",
    x = "locaties waar langer dan een half jaar geleden is geschoond (%)",
    y = "locaties waar minder dan een half jaar geleden is geschoond (%)"
  )
```

```{r submers eag baggeren}
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], Code+jaar~baggeren, value.var = 'meetwaarde', fun.aggregate = mean)
ss_beheer_cast <- ss_beheer_cast[, nietbaggeren := `NA`]
# Bereken R²
complete_cases <- ss_beheer_cast[!is.na(nietbaggeren) & !is.na(baggeren)]
r_squared <- cor(complete_cases$nietbaggeren, complete_cases$baggeren, use = "complete.obs")^2


ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nietbaggeren , y = baggeren, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
    xlim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  # Voeg R² annotatie toe
  annotate("text", x = 5, y = 60, 
           label = paste0("R² = ", round(r_squared, 3)),
           size = 5, hjust = 0, fontface = "bold") +
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 13, face = "bold", color = "gray30"),
    legend.text = element_text(size = 11, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submers - beheerpakket baggeren",
    x = "locaties zonder beheerpakket (%)",
    y = "locaties met beheerpakket baggeren (%)"
  )
  
```

```{r submers vs baggeren boxplot}
#| label:  plot submers vs aantal jaar baggeren
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameter','baggeren','PERODSLSBGODHD_a' )]

ggplot(data = ss_beheer[parameter == 'SUBMSPTN' ,])+
  geom_boxplot(aes(x = as.factor(PERODSLSBGODHD_a),
                   y = as.numeric(meetwaarde))) +
  geom_text(aes(x = as.factor(PERODSLSBGODHD_a),
                y=110, label = n_obs), size = 4)+
  guides(fill=guide_legend(title='Aangepast beheer?'))+
  # facet_wrap(.~baggeren)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submers") +
    labs(x="",y="%")
```

```{r submers eag baggeren obv aantal jaar geleden gebaggerd}
#| label: bedekking analysis - emers by baggeren
# Your EAG analysis code herebedekking by eag
ss_beheer[,PERODSLSBGODHD_a := as.numeric(PERODSLSBGODHD_a)]
ss_beheer[,recent_bagger := fifelse(PERODSLSBGODHD_a <=1, 'ja', 'nee')]
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='SUBMSPTN',], Code+jaar~recent_bagger, value.var = 'meetwaarde', fun.aggregate = mean)
# Bereken R²
complete_cases <- ss_beheer_cast[!is.na(ja) & !is.na(nee)]
r_squared <- cor(complete_cases$ja, complete_cases$nee, use = "complete.obs")^2


ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee , y = ja, color = as.factor(jaar)), size = 5) +
  scale_color_manual(
    values = okabe_colors,
    name = "Meetjaar",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 5, alpha = 1),
      nrow = 1
    )
  ) +
    xlim(0, 40)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
# Voeg R² annotatie toe
  annotate("text", x = 5, y = 60, 
           label = paste0("R² = ", round(r_squared, 3)),
           size = 5, hjust = 0, fontface = "bold") +
  
# Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submers - recent gebaggerd",
    x = "locaties waar langer dan een jaar geleden is gebaggerd (%)",
    y = "locaties waar minder dan een jaar geleden is gebaggerd (%)"
  )
  
```

```{r submers vs doorzicht}
#| label: submers vs doorzicht
ss_cast <- dcast(ss_beheer, externereferentie+jaar+welnietbeheer~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde')
ss_cast[`PTN_BEDKG_%_SUBMSPTN_` > `PTN_BEDKG_%_DRAADALG_SUBMS`, `PTN_BEDKG_%_SUBMSPTN_`:= `PTN_BEDKG_%_SUBMSPTN_`-`PTN_BEDKG_%_DRAADALG_SUBMS`]
ss_cast[,zichtdte := ZICHT_m_ZICHT_/ WATDTE_m_WATDTE_]

palette <- palette.colors(palette = "Okabe-Ito", n = unique(ss_cast$jaar))
# plot submers vs doorzicht
ggplot(data = ss_cast[!is.na(`PTN_BEDKG_%_SUBMSPTN_`) & !is.na(ZICHT_m_ZICHT_) & zichtdte <= 1 ,])+
  geom_jitter(aes(x = zichtdte, y = `PTN_BEDKG_%_SUBMSPTN_`, color = (WATDTE_m_WATDTE_)), size = 5) +
  geom_smooth(aes(x = zichtdte, y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'lm', color = 'black')+
  # scale_color_manual(values = palette, name = 'Jaar')+
  # facet_wrap(welnietbeheer~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 14, angle = 45, hjust =1),
      axis.text.y = element_text(size= 14),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=14))+
    ggtitle( "Bedekking submers vs doorzicht") +
    labs(x="doorzicht/waterdiepte",y="bedekking submers (%)")

# Bereid data voor en maak waterdiepte categorieën
ss_cast_plot <- ss_cast[!is.na(`PTN_BEDKG_%_SUBMSPTN_`) & !is.na(ZICHT_m_ZICHT_) & zichtdte <= 1]

# Maak waterdiepte categorieën met nieuwe indeling
ss_cast_plot[, waterdiepte_cat := case_when(
  WATDTE_m_WATDTE_ <= 0.3 ~ "Zeer ondiep (≤ 0.3m)",
  WATDTE_m_WATDTE_ > 0.3 & WATDTE_m_WATDTE_ <= 0.4 ~ "Ondiep (0.3-0.4m)",
  WATDTE_m_WATDTE_ > 0.4 & WATDTE_m_WATDTE_ <= 0.5 ~ "Matig diep (0.4-0.5m)",
  WATDTE_m_WATDTE_ > 0.5 & WATDTE_m_WATDTE_ <= 1.0 ~ "Diep (0.5-1.0m)",
  TRUE ~ "Zeer diep (> 1.0m)"
)]

# Maak waterdiepte_cat een factor met juiste volgorde
ss_cast_plot[, waterdiepte_cat := factor(waterdiepte_cat, 
  levels = c("Zeer ondiep (≤ 0.3m)", "Ondiep (0.3-0.4m)", 
             "Matig diep (0.4-0.5m)", "Diep (0.5-1.0m)", "Zeer diep (> 1.0m)"))]

# Kleurenpalet voor betere onderscheiding
diepte_kleuren <- c(
  "Zeer ondiep (≤ 0.3m)" = "#d73027",      # Donkerrood
  "Ondiep (0.3-0.4m)" = "#fc8d59",         # Oranje  
  "Matig diep (0.4-0.5m)" = "#fee08b",     # Lichtgeel
  "Diep (0.5-1.0m)" = "#4575b4",           # Blauw
  "Zeer diep (> 1.0m)" = "#313695"         # Donkerblauw
)

# Maak de verbeterde plot
ggplot(data = ss_cast_plot) +
  geom_jitter(aes(x = zichtdte, y = `PTN_BEDKG_%_SUBMSPTN_`, 
                  color = waterdiepte_cat), 
              width = 0.02, alpha = 0.7, size = 5, stroke = 0) +
  
  # Alleen trendlijnen per waterdiepte categorie
  geom_smooth(aes(x = zichtdte, y = `PTN_BEDKG_%_SUBMSPTN_`), 
              method = 'loess', se = TRUE, linewidth = 1.2, alpha = 0.3) +
  
  # Kleurschaal
  scale_color_manual(
    values = diepte_kleuren,
    name = "Waterdiepte categorie",
    guide = guide_legend(
      title.position = "top",
      title.hjust = 0.5,
      override.aes = list(size = 4, alpha = 1)
    )
  ) +
  
  # Verbeterde schaling
  scale_x_continuous(
    breaks = seq(0, 1, by = 0.2),
    labels = function(x) paste0(x),
    limits = c(0, 1)
  ) +
  
  scale_y_continuous(
    breaks = seq(0, 100, by = 20),
    labels = function(x) paste0(x, "%"),
    limits = c(0, 100)
  ) +
  
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submerse vegetatie en lichtklimaat",
    x = "Doorzicht / Waterdiepte ratio (-)",
    y = "Bedekking submerse vegetatie (%)"
  )
```

Submerse vegetatie bedekking heeft geen duidelijke relatie met de frequentie van baggeren. Er worden lagere bedekkingen gemeten op locaties waar lange tijd (> 3 jaar) niet is gebaggerd. Wel is er een negatieve relatie met doorzicht (zie figuur hierboven). Dit betekent dat bij helder water de bedekking lager is. Dit is niet in lijn met de verwachting dat bij helder water de groeiomstandigheden beter zijn (meer lichtinval).

```{r submers vs waterdiepte}
#| label: submers vs waterdiepte
ss_cast <- dcast(ss_beheer, externereferentie+jaar+welnietbeheer~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde')
ss_cast[`PTN_BEDKG_%_SUBMSPTN_` > `PTN_BEDKG_%_DRAADALG_SUBMS`, `PTN_BEDKG_%_SUBMSPTN_`:= `PTN_BEDKG_%_SUBMSPTN_`-`PTN_BEDKG_%_DRAADALG_SUBMS`]
ss_cast[,zichtdte := ZICHT_m_ZICHT_/ WATDTE_m_WATDTE_]

palette <- palette.colors(palette = "Okabe-Ito", n = unique(ss_cast$jaar))
# plot submers vs doorzicht
ggplot(data = ss_cast[!is.na(`PTN_BEDKG_%_SUBMSPTN_`) & !is.na(ZICHT_m_ZICHT_) & WATDTE_m_WATDTE_ ,])+
  geom_jitter(aes(x = WATDTE_m_WATDTE_, y = `PTN_BEDKG_%_SUBMSPTN_`), 
              width = 0.02, alpha = 0.7, size = 4, stroke = 0) +
  geom_smooth(aes(x = WATDTE_m_WATDTE_, y = `PTN_BEDKG_%_SUBMSPTN_`), method = 'loess', color = 'black')+
  geom_smooth(aes(x = WATDTE_m_WATDTE_, y = `PTN_BEDKG_%_SUBMSPTN_`), 
              method = 'loess', se = TRUE, linewidth = 1.2, alpha = 0.3) +
  # Verbeterde schaling
  scale_x_continuous(
    breaks = seq(0, 1, by = 0.2),
    labels = function(x) paste0(x),
    limits = c(0, 1)
  ) +
  
  scale_y_continuous(
    breaks = seq(0, 100, by = 20),
    labels = function(x) paste0(x, "%"),
    limits = c(0, 100)
  ) +
  
  # Modern thema
  theme_minimal() +
  theme(
    # Plot titel en subtitel
    plot.title = element_text(size = 16, face = "bold", color = "gray20", 
                             margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, color = "gray50", 
                                margin = margin(b = 15)),
    
    # Assen
    axis.title.x = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(t = 10)),
    axis.title.y = element_text(size = 14, face = "bold", color = "gray30", 
                               margin = margin(r = 10)),
    axis.text.x = element_text(size = 14, color = "gray40"),
    axis.text.y = element_text(size = 14, color = "gray40"),
    
    # Legenda
    legend.position = "bottom",
    legend.title = element_text(size = 14, face = "bold", color = "gray30"),
    legend.text = element_text(size = 14, color = "gray40"),
    legend.key.size = unit(1, "cm"),
    legend.margin = margin(t = 15),
    
    # Grid lines
    panel.grid.major = element_line(color = "gray90", linewidth = 0.5),
    panel.grid.minor = element_line(color = "gray95", linewidth = 0.3),
    
    # Achtergrond
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "gray98", color = NA),
    
    # Marges
    plot.margin = margin(20, 20, 20, 20)
  ) +
  
  # Verbeterde labels
  labs(
    title = "Bedekking submerse vegetatie en waterdiepte",
    x = "Waterdiepte (m)",
    y = "Bedekking submerse vegetatie (%)"
  )

```

#### Kroos

```{r kroos vis}
#| label: kroos by beheer
## per pakket 
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameterid','parameter','jaar','beheer' )]


ggplot(data = ss_beheer[parameter == 'KROOS',])+
  geom_boxplot(aes(x = beheer, y = as.numeric(meetwaarde),
                   fill = welnietbeheer)) +
  geom_text(aes(x = beheer, y=110, label = n_obs), 
            size = 2)+
  guides(fill=guide_legend(title='Aangepast beheer?'))+
  # facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 90, 
                                 hjust = 1, vjust = 0),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking kroos") +
    labs(x="",y="%")
  # ylim(0,15)
```

```{r kroos by eag}
  # kroos bedekking by eag---------------
ss_beheer_cast <- dcast(ss_beheer[parameterid == 'PTN_BEDKG_%' & parameter =='KROOS',], Code+jaar~welnietbeheer, value.var = 'meetwaarde', fun.aggregate = mean)
ggplot(data = ss_beheer_cast)+
  geom_jitter(aes(x = nee, y = ja)) +
  facet_wrap(jaar~.)+
  geom_abline (slope=1, linetype= "dashed", color="Black", linewidth=0.5) +
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking kroos") +
    labs(x="geen beheerpakket (%)",y="beheerpakket baggeren en/of schonen (%)")
```

#### Frequentie baggeren

```{r}
#| label:  baggerfrequentie 
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameter','baggeren','PERODSLSBGODHD_a','BAGGEREN5JAAR' )]
ss_beheer[is.na(baggeren), baggeren_plot := 'geen']
ss_beheer[!is.na(baggeren), baggeren_plot := 'wel']
ss_beheer[,PERODSLSBGODHD_a := as.numeric(PERODSLSBGODHD_a)]

ggplot(data = ss_beheer)+
  geom_boxplot(aes(x = baggeren_plot, y = BAGGEREN5JAAR)) +
  # geom_text(aes(x = (PERODSLSBGODHD_a), y=0, label = n_obs))+
  facet_wrap(jaar~.)+
  theme_minimal()+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 14),
      axis.text.y = element_text(size= 14),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=14))+
    ggtitle( "Frequentie baggeren") +
    labs(x="Wel of geen beheerpakket baggeren met de baggerpomp",y="Hoe vaak was er baggeronderhoud in de afgelopen 5 jaar?")
# ylim(0,15)

ggplot(data = ss_beheer[parameterid == 'SLIBDTE_m',],
aes(x = (PERODSLSBGODHD_a), y = meetwaarde, col = as.factor(BAGGEREN5JAAR)))+
  geom_jitter(width = 0.3, height = 0, alpha = 0.6, size = 4, stroke = 0) +
  geom_smooth(method = "loess", se = TRUE, color = "#E31A1C", 
                fill = "#E31A1C", alpha = 0.2, linewidth = 1.2, fullrange = TRUE) +
  scale_x_continuous(
      breaks = seq(0, 5, by = 1),
      labels = function(x) paste(x, "jaar"),
      limits = c(0, 5)
    ) +
  scale_y_continuous(
      breaks = seq(0, ceiling(1 * 10) / 10, by = 0.1),
      labels = function(x) paste0(x, " m"),
      limits = c(0, 1)
    ) +
  scale_color_manual(values = okabe_colors, name = "Baggerfrequentie")+
  theme_minimal()+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 14),
      axis.text.x = element_text(size= 14),
      axis.text.y = element_text(size= 14),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=14))+
    ggtitle( "Relatie slibdikte, laatste leer baggeren en baggerfrequentie") +
    labs(x="Laatste keer baggeronderhoud (jaar)",y="Slibdikte (m)")

ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameter','baggeren','PERODSLSBGODHD_a','BAGGEREN5JAAR' )]
ss_beheer[is.na(baggeren), baggeren_plot := 'geen']
ss_beheer[!is.na(baggeren), baggeren_plot := 'wel']
ss_beheer[,PERODSLSBGODHD_a := as.numeric(PERODSLSBGODHD_a)]

ggplot(data = ss_beheer[parameterid == 'SLIBDTE_m',],
       aes(x = (PERODSLSBGODHD_a), y = meetwaarde, col = as.factor(BAGGEREN5JAAR)))+
  geom_jitter(width = 0.3, height = 0, alpha = 0.6, size = 4, stroke = 0) +
  geom_smooth(method = "loess", se = TRUE, color = "#E31A1C", 
              fill = "#E31A1C", alpha = 0.2, linewidth = 1.2, fullrange = TRUE) +
  scale_x_continuous(
    breaks = seq(0, 5, by = 1),
    labels = c("0 jaar", "1 jaar", "2 jaar", "3 jaar", "4 jaar", "5 of meer jaar"),
    limits = c(0, 5)
  ) +
  scale_y_continuous(
    breaks = seq(0, ceiling(1 * 10) / 10, by = 0.1),
    labels = function(x) paste0(x, " m"),
    limits = c(0, 1)
  ) +
  scale_color_manual(
    values = rev(okabe_colors),  # Omkeren van kleuren
    name = "Baggerfrequentie"
  ) +
  theme_minimal()+
  theme(
    strip.background = element_blank(),
    title = element_text(size= 14),
    axis.text.x = element_text(size= 14),
    axis.text.y = element_text(size= 14),
    axis.ticks =  element_line(colour = "black"),
    axis.line = element_line(colour='black'),
    plot.background = element_blank(),
    axis.title=element_text(size=14))+
  ggtitle("Relatie slibdikte, laatste keer baggeren en baggerfrequentie") +
  labs(x="Laatste keer baggeronderhoud (jaar)", y="Slibdikte (m)")
```

#### Laatste keer baggeren

```{r}
ss_beheer[,n_obs:=uniqueN(externereferentie),by =c('parameter','baggeren','PERODSLSBGODHD_a','BAGGEREN5JAAR' )]
ss_beheer[is.na(baggeren), baggeren_plot := 'geen']
ss_beheer[!is.na(baggeren), baggeren_plot := 'wel']
ss_beheer[,PERODSLSBGODHD_a := as.numeric(PERODSLSBGODHD_a)]

# Maak een aparte kleur voor NaN waarden
ss_beheer[, bagger_freq_label := as.character(BAGGEREN5JAAR)]
ss_beheer[is.na(BAGGEREN5JAAR), bagger_freq_label := "Onbekend"]

ggplot(data = ss_beheer[parameterid == 'SLIBDTE_m',],
       aes(x = (PERODSLSBGODHD_a), y = meetwaarde, col = bagger_freq_label))+
  geom_jitter(width = 0.3, height = 0, alpha = 0.6, size = 4, stroke = 0) +
  geom_smooth(method = "loess", se = TRUE, color = "#E31A1C", 
              fill = "#E31A1C", alpha = 0.2, linewidth = 1.2, fullrange = TRUE) +
  scale_x_continuous(
    breaks = seq(0, 5, by = 1),
    labels = c("0 jaar", "1 jaar", "2 jaar", "3 jaar", "4 jaar", "5 of meer jaar"),
    limits = c(0, 5)
  ) +
  scale_y_continuous(
    breaks = seq(0, ceiling(1 * 10) / 10, by = 0.1),
    labels = function(x) paste0(x, " m"),
    limits = c(0, 1)
  ) +
  scale_color_manual(
    values = c(
      "0" = okabe_colors[7],
      "1" = okabe_colors[2],
      "2" = okabe_colors[3],
      "3" = okabe_colors[4],
      "4" = okabe_colors[5],
      "5" = okabe_colors[6],
      "Onbekend" = "grey50"
    ),
    name = "Baggerfrequentie",
    guide = guide_legend(nrow = 1)
  ) +
  theme_minimal()+
  theme(
    strip.background = element_blank(),
    title = element_text(size= 14),
    axis.text.x = element_text(size= 14),
    axis.text.y = element_text(size= 14),
    axis.ticks =  element_line(colour = "black"),
    axis.line = element_line(colour='black'),
    plot.background = element_blank(),
    axis.title=element_text(size=14),
    legend.position = "bottom",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12)
  ) +
  ggtitle("Relatie slibdikte, laatste keer baggeren en baggerfrequentie") +
  labs(x="Laatste keer baggeronderhoud (jaar)", y="Slibdikte (m)")
  
```

```{r laatste keer bagger}
#| label: laatste keer bagger

# Maak een nieuwe variabele voor bagger categorieën
ss_beheer[, bagger_cat := fcase(
  is.na(PERODSLSBGODHD_a), "Onbekend",
  PERODSLSBGODHD_a >= 100, "Nooit gebaggerd",
  PERODSLSBGODHD_a >= 5, "≥5 jaar geleden",
  PERODSLSBGODHD_a >= 4, "4 jaar geleden",
  PERODSLSBGODHD_a >= 3, "3 jaar geleden",
  PERODSLSBGODHD_a >= 2, "2 jaar geleden",
  PERODSLSBGODHD_a >= 1, "1 jaar geleden",
  PERODSLSBGODHD_a >= 0.5, "½-1 jaar geleden",
  PERODSLSBGODHD_a < 0.5, "< ½ jaar geleden",
  default = "Onbekend"
)]

# Maak een factor met de juiste volgorde
ss_beheer[, bagger_cat := factor(bagger_cat, levels = c(
  "< ½ jaar geleden", "½-1 jaar geleden", 
  "1 jaar geleden", "2 jaar geleden", "3 jaar geleden",
  "4 jaar geleden", "≥5 jaar geleden", "Nooit gebaggerd", "Onbekend"
))]

# Maak wel/niet baggerpakket variabele
ss_beheer[is.na(baggeren) | baggeren == 0, baggeren_plot := 'Geen baggerpakket']
ss_beheer[!is.na(baggeren) & baggeren != 0, baggeren_plot := 'Wel baggerpakket']

# Maak een kruistabel - gebruik uniqueN(externereferentie) in plaats van .N
bagger_tabel <- ss_beheer[!is.na(baggeren_plot) & !is.na(bagger_cat), 
                          .(N = uniqueN(externereferentie)), 
                          by = .(baggeren_plot, bagger_cat)]

# Cast naar wide format voor mosaicplot
bagger_tabel_wide <- dcast(bagger_tabel, baggeren_plot ~ bagger_cat, value.var = "N", fill = 0)

# Zet om naar matrix voor mosaicplot (zonder eerste kolom met row names)
bagger_matrix <- as.matrix(bagger_tabel_wide[, -1])
rownames(bagger_matrix) <- bagger_tabel_wide$baggeren_plot

# Print de tabel voor overzicht
print(bagger_matrix)

# Mozaïekplot met grotere labels
par(mar = c(10, 12, 4, 2))
mosaicplot(bagger_matrix,
           main = "Relatie tussen baggerpakket en baggerfrequentie",
           xlab = "Wel of geen baggerpakket",
           ylab = "Wanneer voor het laatst gebaggerd",
           color = okabe_colors,
           las = 2,
           cex.axis = 1.5,
           border = "white",
           off = 3)

# Grouped barplot
ggplot(bagger_tabel, aes(x = bagger_cat, y = N, fill = baggeren_plot)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = N), 
            position = position_dodge(width = 0.9),
            vjust = -0.5,
            size = 5) +
  scale_fill_manual(values = okabe_colors[1:2]) +
  theme_minimal() +
  theme(
    title = element_text(size = 18),
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    legend.position = "top"
  ) +
  labs(
    title = "Relatie tussen baggerpakket en baggerfrequentie",
    x = "Wanneer voor het laatst gebaggerd",
    y = "Aantal unieke locaties",
    fill = ""
  )

# Bereken percentages
bagger_prop <- prop.table(bagger_matrix, margin = 1) * 100
print(round(bagger_prop, 1))
```

#### Laatste keer geschoond

```{r}
# Zorg dat PERODSLSSNG_mnd numeriek is
ss_beheer[, PERODSLSSNG_mnd := as.numeric(PERODSLSSNG_mnd)]

# Maak wel/niet schoonpakket variabele
ss_beheer[is.na(schonen) | schonen == 0, schonen_plot := 'Geen schoonpakket']
ss_beheer[!is.na(schonen) & schonen != 0, schonen_plot := 'Wel schoonpakket']

# Maak een nieuwe variabele voor schoon categorieën (in maanden)
ss_beheer[, schoon_cat := fcase(
  is.na(PERODSLSSNG_mnd), "Onbekend",
  PERODSLSSNG_mnd >= 100*12, "Nooit geschoond",  # > 100 jaar
  PERODSLSSNG_mnd >= 5*12, "≥5 jaar geleden",
  PERODSLSSNG_mnd >= 4*12, "4 jaar geleden",
  PERODSLSSNG_mnd >= 3*12, "3 jaar geleden",
  PERODSLSSNG_mnd >= 2*12, "2 jaar geleden",
  PERODSLSSNG_mnd >= 12, "1 jaar geleden",
  PERODSLSSNG_mnd >= 6, "½-1 jaar geleden",
  PERODSLSSNG_mnd < 6, "< ½ jaar geleden",
  default = "Onbekend"
)]

# Check de verdeling
ss_beheer[, .N, by = schoon_cat]

# Maak een factor met de juiste volgorde
ss_beheer[, schoon_cat := factor(schoon_cat, levels = c(
  "< ½ jaar geleden", "½-1 jaar geleden", 
  "1 jaar geleden", "2 jaar geleden", "3 jaar geleden",
  "4 jaar geleden", "≥5 jaar geleden", "Nooit geschoond", "Onbekend"
))]

# Maak een kruistabel - gebruik uniqueN(externereferentie) in plaats van .N
schoon_tabel <- ss_beheer[!is.na(schonen_plot) & !is.na(schoon_cat), 
                          .(N = uniqueN(externereferentie)), 
                          by = .(schonen_plot, schoon_cat)]

# Cast naar wide format voor mosaicplot
schoon_tabel_wide <- dcast(schoon_tabel, schonen_plot ~ schoon_cat, value.var = "N", fill = 0)

# Zet om naar matrix voor mosaicplot (zonder eerste kolom met row names)
schoon_matrix <- as.matrix(schoon_tabel_wide[, -1])
rownames(schoon_matrix) <- schoon_tabel_wide$schonen_plot

# Print de tabel voor overzicht
print(schoon_matrix)

# Mozaïekplot met grotere labels
par(mar = c(10, 12, 4, 2))
mosaicplot(schoon_matrix,
           main = "Relatie tussen schoonpakket en schoonfrequentie",
           xlab = "Wel of geen schoonpakket",
           ylab = "Wanneer voor het laatst geschoond",
           color = okabe_colors,
           las = 2,
           cex.axis = 1.5,
           border = "white",
           off = 3)

# Grouped barplot
ggplot(schoon_tabel, aes(x = schoon_cat, y = N, fill = schonen_plot)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = N), 
            position = position_dodge(width = 0.9),
            vjust = -0.5,
            size = 5) +
  scale_fill_manual(values = okabe_colors[1:2]) +
  theme_minimal() +
  theme(
    title = element_text(size = 18),
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16),
    legend.title = element_text(size = 16),
    legend.text = element_text(size = 14),
    legend.position = "top"
  ) +
  labs(
    title = "Relatie tussen schoonpakket en schoonfrequentie",
    x = "Wanneer voor het laatst geschoond",
    y = "Aantal unieke locaties",
    fill = ""
  )

# Bereken percentages
schoon_prop <- prop.table(schoon_matrix, margin = 1) * 100
print(round(schoon_prop, 1))
```

```{r schonen en slib en doorzicht}

# Maak een aparte kleur voor NaN waarden
ss_beheer[, schonen_freq_label := as.character(SCHONEN5JAAR)]
ss_beheer[is.na(SCHONEN5JAAR), schonen_freq_label := "Onbekend"]

ggplot(data = ss_beheer[parameterid == 'ZICHT_m',],
       aes(x = (schoon_cat), y = meetwaarde, col = schonen_freq_label))+
  geom_jitter(width = 0.3, height = 0, alpha = 0.6, size = 4, stroke = 0) +
  geom_smooth(method = "loess", se = TRUE, color = "#E31A1C", 
              fill = "#E31A1C", alpha = 0.2, linewidth = 1.2, fullrange = TRUE) +
  
  scale_y_continuous(
    breaks = seq(0, ceiling(1 * 10) / 10, by = 0.1),
    labels = function(x) paste0(x, " m"),
    limits = c(0, 1)
  ) +
  scale_color_manual(
    values = c(
      "0" = okabe_colors[7],
      "1" = okabe_colors[2],
      "2" = okabe_colors[3],
      "3" = okabe_colors[4],
      "4" = okabe_colors[5],
      "5" = okabe_colors[6],
      "Onbekend" = "grey50"
    ),
    name = "Frequentie schonen",
    guide = guide_legend(nrow = 1)
  ) +
  theme_minimal()+
  theme(
    strip.background = element_blank(),
    title = element_text(size= 14),
    axis.text.x = element_text(size= 14),
    axis.text.y = element_text(size= 14),
    axis.ticks =  element_line(colour = "black"),
    axis.line = element_line(colour='black'),
    plot.background = element_blank(),
    axis.title=element_text(size=14),
    legend.position = "bottom",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12)
  ) +
  ggtitle("Relatie doorzicht, laatste keer schonen en frequentie schonen") +
  labs(x="Laatste keer maaibeheer (jaar)", y="Doorzicht (m)")
  
```

#### Doorzicht en waterdiepte

```{r watdte vs doorzicht}
#| label: submers vs doorzicht
ss_cast <- dcast(ss_beheer, externereferentie+jaar+welnietbeheer~parameterid+parameter+parameterfractie, fun.aggregate = mean, value.var = 'meetwaarde')

ss_cast[`PTN_BEDKG_%_SUBMSPTN_` > `PTN_BEDKG_%_DRAADALG_SUBMS`, `PTN_BEDKG_%_SUBMSPTN_`:= `PTN_BEDKG_%_SUBMSPTN_`-`PTN_BEDKG_%_DRAADALG_SUBMS`]
ss_cast[,zichtdte := ZICHT_m_ZICHT_/ WATDTE_m_WATDTE_]

# plot submers vs doorzicht
ggplot(data = ss_cast[!is.na(zichtdte),])+
  geom_jitter(aes(x = WATDTE_m_WATDTE_, y = ZICHT_m_ZICHT_, color = as.factor(jaar))) +
  geom_smooth(aes(x = WATDTE_m_WATDTE_, y = ZICHT_m_ZICHT_), method = 'lm', color = 'black')+
  # facet_wrap(welnietbeheer~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Waterdiepte vs doorzicht") +
    labs(x="waterdiepte",y="doorzicht (m)")


```

De doorzicht/waterdiepte ratio is hoger in sloten met beheerpakket. 

```{r}
#| label: boxplots all parameters by beheer
ggplot()+
  geom_boxplot(data = ss_beheer[parameterid == "TALBVWTR_SOORT"  ], aes(x = beheer, y = meetwaarde))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Taludhoek") +
    labs(x="",y="taludhoek")

ggplot()+
  geom_boxplot(data = ss_beheer[parameterid == "WATDTE_m" ,], aes(x = beheer, y = meetwaarde))+ ylim(0,1)+
  theme(
    size = 14,
    strip.background = element_blank(),
    title = element_text(size = 14),
    axis.text.x = element_text(size = 14, angle = 90, hjust = 1, vjust = 0),
    axis.text.y = element_text(size = 14),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    legend.position = "bottom",
    strip.text = element_text(size = 14)
  ) +
  ggtitle("Gemeten waterdiepte per beheertype") +
  labs(x = "", y = "m") 

ggplot()+
  geom_boxplot(data = ss_beheer[parameterid == "ZICHT_m" ,], aes(x = beheer, y = meetwaarde))+ 
  theme(
    size = 14,
    strip.background = element_blank(),
    title = element_text(size = 14),
    axis.text.x = element_text(size = 14, angle = 90, hjust = 1, vjust = 0),
    axis.text.y = element_text(size = 14),
    axis.ticks = element_line(colour = "black"),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.title = element_text(size = 14),
    legend.text = element_text(size = 14),
    legend.position = "bottom",
    strip.text = element_text(size = 14)
  ) +
  ggtitle("Gemeten reciproke doorzicht per beheertype") +
  labs(x = "", y = "m") +
  ylim(0, 1)
    


```

## XG-boost analyse

```{r xgboost setup }
#| label: xgboost

anlbhybi_cast <- anlbhybi_bod
anlbhybi_cast[,pvskp := P_tot/Pkrit1] #3417 rows

# Prepare data for xgboost using data.table syntax
model_data_xgb <- anlbhybi_cast[
  # Filter out rows with missing target variable
  !is.na(`PTN_BEDKG_%_SUBMSPTN_`) 
][
  # Select relevant columns
  , .(
    # Target variable
    submers_bedekking = `PTN_BEDKG_%_SUBMSPTN_`,
    emers_bedekking = `PTN_BEDKG_%_EMSPTN_`,
    submers_soorten = n_soort_sub,
    emers_soorten = n_soort_ems,
    
    # Management features
    anlb,
    njaaranlb,
    # beheer,
    baggeren,
    slootschonen,
    water,
    bufferzone,
    pakket_n_anlb,
    
    # Environmental features
    # watertype,
    WATDTE_m_WATDTE_,
    WATERBTE_m_WATERBTE_,
    SLIBDTE_m_SLIBDTE_,
    zichtdte,
    TALBVWTR_graad_TALBVWTR_,
    # rel_water,
    A_P_AL,
    A_SOM_LOI,
    # Ptot_mgP_l_nf_PW,
    # NH4_mgN_l_nf_PW,
    P_tot,
    `mm/d`,
    pvskp,

    # Other coverage variables
    `PTN_BEDKG_%_FLAB_`,
    `PTN_BEDKG_%_KROOS_`,
    
    # Location identifier
    EAGIDENT,
    locatie,
    compartiment,
    jaar
  )
] # 2938 rows

# Remove rows with any missing values in a separate step
# model_data_xgb[complete.cases(model_data_xgb), complete := 1]
# setDT(hybiloc)
# model_data_loc_check <- merge(model_data_xgb, hybiloc, by = "locatie", all.x = TRUE)
# model_data_loc_check_hybi <- st_as_sf(model_data_loc_check)
# st_write(model_data_loc_check, "model_data_loc_check.gpkg", delete_dsn = TRUE)
model_data_xgb <- model_data_xgb[complete.cases(model_data_xgb),] 
# 2900 = alles, 2774 = met watbal, 2499 = met bodemschat, 2382 = met bodemschat en watbal, 1435 inclusief waterbodem, belasting en bodschat

# Convert factors to numeric for xgboost
factor_cols <- names(model_data_xgb)[sapply(model_data_xgb, is.character)]
model_data_xgb[, (factor_cols) := lapply(.SD, as.factor), .SDcols = factor_cols]
model_data_xgb[, (factor_cols) := lapply(.SD, as.numeric), .SDcols = factor_cols]

```


```{r correlatie check}
#| label: xgboost parameters check

# Check correlation between features
feature_cols <- setdiff(names(model_data_xgb), c("submers_bedekking", "emers_bedekking", "compartiment","submers_soorten", "emers_soorten",
                                                  "PTN_BEDKG_%_FLAB_", "locatie", "EAGIDENT", "anlb"))
cor_matrix <- model_data_xgb[, ..feature_cols]
# Remove rows with NA values
cor_matrix <- na.omit(cor_matrix)
# Calculate correlation matrix
cor_matrix <- cor(cor_matrix, use = "pairwise.complete.obs")

# Create correlation plot
corrplot(cor_matrix, 
         method = "color",       # Color squares
         type = "upper",         # Only show upper triangle
         order = "hclust",       # Order by hierarchical clustering
         tl.col = "black",       # Label color
         tl.srt = 45,            # Label rotation
         tl.cex = 0.7,           # Label size
         addCoef.col = "black",  # Add correlation coefficients
         number.cex = 0.6,       # Coefficient text size
         col = colorRampPalette(c("#6D9EC1", "white", "#E46726"))(200)) # Blue-white-orange color scheme

# Or alternatively, use ggcorrplot for a ggplot-based solution
if (!require(ggcorrplot)) install.packages("ggcorrplot") 
library(ggcorrplot)

ggcorrplot(cor_matrix, 
           hc.order = TRUE,      # Hierarchical clustering
           type = "upper",       # Show only upper triangle
           lab = TRUE,           # Add correlation coefficients
           lab_size = 3,         # Size of text labels
           tl.cex = 8,           # Text label size
           title = "Correlation Plot of Environmental and Vegetation Variables",
           ggtheme = ggplot2::theme_minimal())


```


```{r xgboost target loop}

# Optie 1: Train afzonderlijke modellen voor elke doelvariabele
target_variables <- c("submers_bedekking", "emers_bedekking", "submers_soorten", "emers_soorten")

models <- list()
predictions_all <- list()
rsme_all <- list()

for(target_var in target_variables) {
  cat("Training model for:", target_var, "\n")
  
  # Selecteer target
  target <- model_data_xgb[[target_var]]
  
  # Verwijder alle target variabelen uit features
  features <- model_data_xgb[, !c("submers_bedekking", "emers_bedekking", 
                                  "emers_soorten", "submers_soorten",
                                  "PTN_BEDKG_%_FLAB_", "locatie", "EAGIDENT", "anlb")]
  
  # Train/test split (gebruik dezelfde split voor vergelijkbaarheid)
  set.seed(123)
  train_idx <- sample(nrow(features), 0.8 * nrow(features))
  
  train_x <- as.matrix(features[train_idx])
  train_y <- target[train_idx]
  test_x <- as.matrix(features[-train_idx])
  test_y <- target[-train_idx]
  
  # Train model
  dtrain <- xgb.DMatrix(data = train_x, label = train_y)
  dtest <- xgb.DMatrix(data = test_x, label = test_y)
  
  xgb_model <- xgb.train(
    params = params,
    data = dtrain,
    nrounds = 1000,
    watchlist = list(train = dtrain, test = dtest),
    early_stopping_rounds = 50,
    verbose = 0
  )
  
  # Bewaar model en predictions
  models[[target_var]] <- xgb_model
  predictions <- predict(xgb_model, dtest)
  predictions_all[[target_var]] <- predictions
  
  # Calculate RMSE
  rmse <- sqrt(mean((test_y - predictions)^2))
  rsme_all[[target_var]] <- rmse
  cat("RMSE voor", target_var, ":", round(rmse, 3), "\n\n")
  
  # Variable importance
  print(paste("Variable importance voor", target_var))
  print(vip(xgb_model, num_features = 10))
}

```


```{r vip plots}
#| label: Complete VIP Plot Creation for All Target Variables

# Bereken de variatie/schaal van elke target variabele om RMSE als percentage uit te drukken
calculate_rmse_percentage <- function(models, target_variables, data) {
  rmse_percentages <- list()
  
  for (target_var in target_variables) {
    # Haal de target waarden op
    target_values <- data[[target_var]]
    
    # Bereken statistieken
    target_range <- max(target_values, na.rm = TRUE) - min(target_values, na.rm = TRUE)
    target_mean <- mean(target_values, na.rm = TRUE)
    target_sd <- sd(target_values, na.rm = TRUE)
    
    # RMSE
    rmse <- rsme_all[[target_var]]
    
    # Bereken percentages
    rmse_pct_range <- (rmse / target_range) * 100  # Percentage van bereik
    rmse_pct_mean <- (rmse / target_mean) * 100    # Percentage van gemiddelde
    rmse_pct_sd <- (rmse / target_sd) * 100        # Percentage van standaarddeviatie
    
    # Sla resultaten op
    rmse_percentages[[target_var]] <- list(
      rmse = rmse,
      range = target_range,
      mean = target_mean,
      sd = target_sd,
      rmse_pct_range = rmse_pct_range,
      rmse_pct_mean = rmse_pct_mean,
      rmse_pct_sd = rmse_pct_sd
    )
    
    # Print samenvatting
    cat("Target:", target_var, "\n")
    cat("  Range:", round(target_range, 2), "\n")
    cat("  Mean:", round(target_mean, 2), "\n")
    cat("  RMSE:", round(rmse, 3), "\n")
    cat("  RMSE as % of range:", round(rmse_pct_range, 1), "%\n")
    cat("  RMSE as % of mean:", round(rmse_pct_mean, 1), "%\n\n")
  }
  
  return(rmse_percentages)
}

# Bereken RMSE percentages
rmse_stats <- calculate_rmse_percentage(models, target_variables, model_data_xgb)

# Aangepaste VIP functie met RMSE percentage
create_multiple_vip_grids_with_pct <- function(models, target_variables, rmse_stats, num_features = 10) {
  
  # Target variable mapping for readable names
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Variable mapping for readable names
  var_mapping <- list(
    "njaaranlb" = "Aantal jaren ANLB",
    "beheer" = "Beheertype",
    "baggeren" = "Baggeren",
    "slootschonen" = "Slootschonen", 
    "water" = "Water pakket",
    "bufferzone" = "Bufferzone",
    "pakket_n_anlb" = "Aantal ANLB pakketten",
    "watertype" = "Watertype",
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)",
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "rel_water" = "Fractie open water (%)",
    "A_P_AL" = "P-AL (mg/kg)",
    "A_SOM_LOI" = "Organische stof (%)",
    "Ptot_mgP_l_nf_PW" = "P-totaal poriewater (mg/l)",
    "NH4_mgN_l_nf_PW" = "NH4 poriewater (mg/l)",
    "P_tot" = "P-belasting (mg/m2/dag)",
    "mm/d" = "Verblijftijd (mm/dag)",
    "PTN_BEDKG_%_FLAB_" = "Flabbedekking (%)",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "compartiment" = "Compartiment",
    "jaar" = "Jaar"
  )
  
  # Store all VIP plots
  vip_plots <- list()
  
  # Create VIP plot for each target variable
  for (target_var in target_variables) {
    cat("Creating VIP plot for target:", target_var, "\n")
    
    model <- models[[target_var]]
    stats <- rmse_stats[[target_var]]
    
    # Get variable importance DATA
    importance_data <- vip::vi(model)
    
    # Map variable names to readable names
    importance_data$Variable_readable <- sapply(importance_data$Variable, function(x) {
      if (x %in% names(var_mapping)) {
        return(var_mapping[[x]])
      } else {
        return(x)
      }
    })
    
    # Create subtitle with RMSE and percentage
    subtitle_text <- paste0(
      "RMSE: ", round(stats$rmse, 3),
      " (", round(stats$rmse_pct_range, 1), "% van bereik, ",
      round(stats$rmse_pct_mean, 1), "% van gemiddelde)"
    )
    
    # Create VIP plot with enhanced RMSE information
    p <- ggplot(importance_data, aes(x = reorder(Variable_readable, Importance), 
                                   y = Importance)) +
      geom_col(fill = "steelblue", alpha = 0.8) +
      coord_flip() +
      labs(
        title = paste("Variable Importance:", target_mapping[[target_var]]),
        subtitle = subtitle_text,
        x = "Variabelen",
        y = "Importance (Gain)"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 10, color = "darkred"),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 10),
        axis.text.y = element_text(size = 9),
        panel.grid.minor = element_blank()
      )
    
    vip_plots[[target_var]] <- p
    print(p)
  }
  
  # Create combined grid plot
  if (length(vip_plots) > 0) {
    cat("Creating combined VIP grid...\n")
    
    combined_vip_grid <- gridExtra::grid.arrange(
      grobs = vip_plots,
      ncol = 2,
      top = "Variable Importance Comparison - All Target Variables (RMSE with Context)"
    )
    
    print(combined_vip_grid)
  }
  
  return(vip_plots)
}

# Main execution
# ==============
vip_results_with_pct <- create_multiple_vip_grids_with_pct(
  models = models,
  target_variables = target_variables,
  rmse_stats = rmse_stats,
  num_features = 12
)


# Print summary
cat("\n=== VIP ANALYSIS SAMENVATTING ===\n")
cat("Aantal VIP plots gemaakt:", length(vip_results), "\n")
cat("Target variabelen geanalyseerd:", paste(names(vip_results), collapse = ", "), "\n")
cat("Grid layouts gemaakt: Overall, Bedekking, Soorten\n")


```


De waterbreedte is de belangrijkste voorspeller voor emerse bedekking. Daarnaast zijn de variabelen die het water beïnvloeden (doorzicht, waterdiepte, taludhoek) ook belangrijk. Beheer gerelateerde variabelen zoals aantal jaren anlb en baggeren zijn minder belangrijk.
Ook bij sumberse vegetatie is de waterbreedte een belangrijke voorspeller. Daarnaast zijn de variabelen die het water beïnvloeden (doorzicht, waterdiepte, taludhoek) ook belangrijk. Beheer gerelateerde variabelen zoals aantal jaren anlb en baggeren zijn minder belangrijk.

Waterdiepte en zichtdiepte zijn belangrijker bij het voorspellen van sumberse dan emerse bedekking.

```{r ale plots}
#| label: Complete ALE Plot Creation for All Target Variables
# ===================================================

# Define function to create ALE plots manually
create_ale_plot <- function(model, data, feature, num_intervals = 40) {
  # Sort the data by the feature
  data_sorted <- data[order(data[, feature]), ]
  x_sorted <- data_sorted[, feature]
  
  # Create intervals
  n <- length(x_sorted)
  interval_size <- max(1, floor(n / num_intervals))
  intervals <- seq(1, n, by = interval_size)
  if (intervals[length(intervals)] < n) intervals <- c(intervals, n)
  
  # Initialize results
  ale_values <- numeric(length(intervals) - 1)
  x_values <- numeric(length(intervals) - 1)
  
  # Calculate ALE for each interval
  for (i in 1:(length(intervals) - 1)) {
    start_idx <- intervals[i]
    end_idx <- intervals[i+1]
    
    # Get data in this interval
    x_interval <- x_sorted[start_idx:end_idx]
    data_interval <- data_sorted[start_idx:end_idx, , drop = FALSE]
    
    # Calculate mean feature value for this interval
    x_values[i] <- mean(x_interval)
    
    # Create two datasets: one with min value and one with max value
    data_min <- data_interval
    data_max <- data_interval
    data_min[, feature] <- min(x_interval)
    data_max[, feature] <- max(x_interval)
    
    # Predict with both datasets
    pred_min <- predict(model, as.matrix(data_min))
    pred_max <- predict(model, as.matrix(data_max))
    
    # Calculate average difference
    ale_values[i] <- mean(pred_max - pred_min)
  }
  
  # Cumulative sum to get ALE
  ale_cumsum <- cumsum(ale_values)
  
  # Center ALE to have mean of 0
  ale_cumsum <- ale_cumsum - mean(ale_cumsum)
  
  # Return results
  return(data.frame(x = x_values, ale = ale_cumsum))
}

# Function to create ALE plots for all target variables
create_ale_plots_all_targets <- function(models, train_data, target_variables) {
  
  # Define continuous variables for ALE plots
  continuous_vars <- c(
    "WATDTE_m_WATDTE_", "WATERBTE_m_WATERBTE_", "SLIBDTE_m_SLIBDTE_",
    "zichtdte","A_P_AL","A_SOM_LOI","NH4_mgN_l_nf_PW","Ptot_mgP_l_nf_PW","P_tot","mm/d","TALBVWTR_graad_TALBVWTR_", "PTN_BEDKG_%_KROOS_", "jaar","pvskp" 
  )
  
  # Variable mapping for readable names
  var_mapping <- list(
    "njaaranlb" = "Aantal jaren ANLB",
    "beheer" = "Beheertype",
    "baggeren" = "Baggeren",
    "slootschonen" = "Slootschonen", 
    "water" = "Water pakket",
    "bufferzone" = "Bufferzone",
    "pakket_n_anlb" = "Aantal ANLB pakketten",
    "watertype" = "Watertype",
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)",
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "rel_water" = "Fractie open water (%)",
    "A_P_AL" = "P-AL (mg/kg)",
    "A_SOM_LOI" = "Organische stof (%)",
    "Ptot_mgP_l_nf_PW" = "P-totaal poriewater (mg/l)",
    "NH4_mgN_l_nf_PW" = "NH4 poriewater (mg/l)",
    "P_tot" = "P-belasting (mg/m2/dag)",
    "mm/d" = "Verblijftijd (mm/dag)",
    "PTN_BEDKG_%_FLAB_" = "Flabbedekking (%)",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "compartiment" = "Compartiment",
    "jaar" = "Jaar",
    "pvskp" = "P belasting / Kritische P belasting"
  )
  
  # Target variable mapping for readable names
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Verify which variables exist in training data
  valid_vars <- intersect(continuous_vars, colnames(train_data))
  
  # Store all ALE plots
  all_ale_plots <- list()
  
  # Loop through each target variable
  for (target_var in target_variables) {
    cat("Creating ALE plots for target:", target_var, "\n")
    
    model <- models[[target_var]]
    target_plots <- list()
    
    # Create ALE plots for each continuous variable
    for (var in valid_vars) {
      cat("  Creating ALE plot for:", var, "\n")
      
      # Calculate ALE values
      ale_data <- create_ale_plot(model, train_data, var)
      
      # Add annotations for effect values
      max_effect <- max(abs(ale_data$ale))
      effect_points <- seq(1, nrow(ale_data), length.out = 5)
      effect_points <- round(effect_points)
      effect_points <- unique(effect_points)
      
      # Create plot with target-specific labeling
      p <- ggplot(ale_data, aes(x = x, y = ale)) +
        geom_line(linewidth = 1.2, color = "steelblue") +
        geom_rug(sides = "b", alpha = 0.2) +
        geom_point(data = ale_data[effect_points,], aes(x = x, y = ale), 
                   color = "red", size = 2) +
        geom_text(data = ale_data[effect_points,], 
                  aes(x = x, y = ale, 
                      label = sprintf("%.1f", ale)),
                  vjust = -1.5, size = 3) +
        labs(
          title = paste("Effect van", var_mapping[[var]], "op", target_mapping[[target_var]]),
          x = var_mapping[[var]],
          y = paste("Effect op", target_mapping[[target_var]])
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, face = "bold"),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.minor = element_blank()
        )
      
      target_plots[[var]] <- p
      print(p)
    }
    
    # Store plots for this target
    all_ale_plots[[target_var]] <- target_plots
    
    # Create combined plot grid for this target
    if (length(target_plots) > 0) {
      if (requireNamespace("gridExtra", quietly = TRUE)) {
        grid_plot <- gridExtra::grid.arrange(
          grobs = target_plots, 
          ncol = 2,
          top = paste("ALE Plots voor", target_mapping[[target_var]])
        )
        print(grid_plot)
      }
    }
    
    cat("\n")
  }
  
  return(all_ale_plots)
}

# Function to create comparison plots across targets
create_comparison_ale_plots <- function(all_ale_plots, var_to_compare) {
  comparison_plots <- list()
  
  for (target in names(all_ale_plots)) {
    if (var_to_compare %in% names(all_ale_plots[[target]])) {
      plot <- all_ale_plots[[target]][[var_to_compare]] +
        labs(title = paste(target, "-", var_to_compare)) +
        theme(plot.title = element_text(size = 12))
      
      comparison_plots[[target]] <- plot
    }
  }
  
  if (length(comparison_plots) > 0) {
    grid_plot <- gridExtra::grid.arrange(
      grobs = comparison_plots,
      ncol = 2,
      top = paste("Vergelijking ALE plots voor", var_to_compare)
    )
    print(grid_plot)
  }
  
  return(comparison_plots)
}

# Function to summarize ALE effects
summarize_ale_effects <- function(all_ale_plots) {
  cat("=== ALE PLOT SAMENVATTING ===\n\n")
  
  for (target in names(all_ale_plots)) {
    cat("Target variabele:", target, "\n")
    cat("Aantal ALE plots gemaakt:", length(all_ale_plots[[target]]), "\n")
    cat("Variabelen geanalyseerd:", paste(names(all_ale_plots[[target]]), collapse = ", "), "\n")
    cat("\n")
  }
}

# Main execution
# ==============

# Define target variables
target_variables <- c("submers_bedekking", "emers_bedekking", "submers_soorten", "emers_soorten")

# Create ALE plots for all targets (assuming models and train_x are already available)
all_ale_plots <- create_ale_plots_all_targets(
  models = models,
  train_data = as.data.frame(train_x),
  target_variables = target_variables
)

# Create comparison plots for specific variables across all targets
cat("Creating comparison plots...\n")

# Example: Compare waterbreedte effects across all targets
waterbreedte_comparison <- create_comparison_ale_plots(all_ale_plots, "WATERBTE_m_WATERBTE_")
# Example: Compare waterdiepte effects across all targets  
waterdiepte_comparison <- create_comparison_ale_plots(all_ale_plots, "WATDTE_m_WATDTE_")
# Example: Compare kroos effects across all targets
kroos_comparison <- create_comparison_ale_plots(all_ale_plots, "PTN_BEDKG_%_KROOS_")
# Example: Compare P-AL effects across all targets
p_al_comparison <- create_comparison_ale_plots(all_ale_plots, "A_P_AL")
# Example: Compare P-totaal effects across all targets
ptotaal_comparison <- create_comparison_ale_plots(all_ale_plots, "P_tot")
# Example: Compare Taludhelling effects across all targets
talud_comparison <- create_comparison_ale_plots(all_ale_plots, "TALBVWTR_graad_TALBVWTR_")
# Example: Compare zichtdte effects across all targets
zichtdte_comparison <- create_comparison_ale_plots(all_ale_plots, "zichtdte")
# Example: Compare mm/d effects across all targets
mm_d_comparison <- create_comparison_ale_plots(all_ale_plots, "mm/d")
# Example: Compare NH4 effects across all targets
nh4_comparison <- create_comparison_ale_plots(all_ale_plots, "NH4_mgN_l_nf_PW")
#Example: Compare P-totaal poriewater effects across all targets
ptotaal_pw_comparison <- create_comparison_ale_plots(all_ale_plots, "Ptot_mgP_l_nf_PW")
# Example: Compare fractie water effects across all targets
rel_water_comparison <- create_comparison_ale_plots(all_ale_plots, "rel_water")
# Example: Compare organisch stof effects across all targets
org_stof_comparison <- create_comparison_ale_plots(all_ale_plots, "A_SOM_LOI")
# Example: Compare pvskp effects across all targets
pvskp_comparison <- create_comparison_ale_plots(all_ale_plots, "pvskp")

# Show summary of all ALE plots created
summarize_ale_effects(all_ale_plots)

cat("ALE plots creation completed for all target variables!\n")
```

```{r ale plots versie 2}

create_ale_plots_top10_variables <- function(models, train_data, target_variables) {
  
  # Functie om top 10 variabelen te bepalen voor elk model
  get_top10_variables <- function(model) {
    # Bereken variabele-belangrijkheid
    importance <- xgboost::xgb.importance(model = model)
    
    # Sorteer op belangrijkheid en neem top 10
    top10 <- head(importance$Feature, 10)
    return(top10)
  }
  
  # Variabele mapping voor leesbare namen
  var_mapping <- list(
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)", 
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "jaar" = "Jaar",
    "pvskp" = "P belasting / Kritische P belasting",
    "A_P_AL" = "P-AL bodem",
    "P_tot" = "P-belasting (mg/m2/dag)",
    "mm/d" = "Hydraulisch debiet (mm/dag)",	
    "rel_water" = "Percentage open water",
    "P_PO4" = "Fosfaat (PO4)",
    "Ntot" = "Totaal stikstof",
    "NH4" = "Ammonium",
    "A_SOM_LOI" = "Organische stof (%)",
    "njaaranlb" = "Aantal jaren ANLb",
    "baggeren" = "Baggeren",
    "slootschonen" = "Slootschonen",
    "water" = "Water beheer",
    "bufferzone" = "Bufferzone",
    "pakket_n_anlb" = "Aantal ANLb pakketten"
  )
  
  # Target variabele mapping voor leesbare namen
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Sla alle ALE plots op
  all_ale_plots <- list()
  
  # Loop door elke doelvariabele
  for (target_var in target_variables) {
    cat("ALE plots maken voor:", target_var, "\n")
    
    model <- models[[target_var]]
    target_plots <- list()
    
    # Bepaal top 10 belangrijkste variabelen voor dit model
    top10_vars <- get_top10_variables(model)
    cat("Top 10 belangrijkste variabelen voor", target_var, ":", paste(top10_vars, collapse=", "), "\n")
    
    # Maak ALE plots voor elke top-10 variabele
    for (var in top10_vars) {
      cat("  ALE plot maken voor:", var, "\n")
      
      # Controleer of de variabele bestaat in de trainingsdata
      if(!(var %in% colnames(train_data))) {
        cat("  Waarschuwing: variabele", var, "niet gevonden in trainingsdata, wordt overgeslagen\n")
        next
      }
      
      # Bereken ALE waarden
      ale_data <- create_ale_plot(model, train_data, var)
      
      # Selecteer punten voor labels (gelijkmatig verdeeld)
      num_points <- min(5, nrow(ale_data))  # Maximum 5 punten voor labels
      point_indices <- round(seq(1, nrow(ale_data), length.out = num_points))
      label_data <- ale_data[point_indices, ]
      
      # Bepaal de leesbare naam voor de variabele
      var_label <- if(var %in% names(var_mapping)) var_mapping[[var]] else var
      
      # Maak plot met doelvariabele-specifieke labels
      p <- ggplot(ale_data, aes(x = x, y = ale)) +
        # Voeg een lijn toe
        geom_line(linewidth = 1.2, color = "steelblue", alpha = 0.8) +
        # Voeg de rug (rode datapunten) onderaan toe
        geom_rug(sides = "b", alpha = 0.7, color = "red", size = 1) +
        # Voeg effect-waarde stippen toe
        geom_point(data = label_data, aes(x = x, y = ale), 
                  color = "red", size = 3) +
        # Voeg labels toe voor de effect-waarden
        geom_text(data = label_data, 
                 aes(x = x, y = ale, label = sprintf("%.1f", ale)),
                 vjust = -0.8, hjust = 0.5, size = 3.5) +
        labs(
          title = paste("Effect van", var_label),
          x = var_label,
          y = NULL
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 12, face = "bold"),
          axis.title.x = element_text(size = 10),
          axis.title.y = element_blank(),
          axis.text = element_text(size = 9),
          panel.grid.minor = element_blank()
        )
      
      target_plots[[var]] <- p
    }
    
    # Sla plots op voor deze doelvariabele
    all_ale_plots[[target_var]] <- target_plots
    
    # Maak een gecombineerde plot grid voor deze doelvariabele
    if (length(target_plots) > 0) {
      # Voeg één gemeenschappelijke titel toe voor de hele groep plots
      grid_title <- paste("ALE Plots voor", target_mapping[[target_var]])
      
      # Voeg een gemeenschappelijke y-as label toe (één keer voor alle plots)
      grid_plot <- gridExtra::grid.arrange(
        gridExtra::arrangeGrob(
          grobs = target_plots,
          ncol = 2,
          left = grid::textGrob("Effect op afhankelijke variabele", rot = 90, gp = grid::gpar(fontsize = 12))
        ),
        top = grid::textGrob(grid_title, gp = grid::gpar(fontsize = 14, fontface = "bold"))
      )
      print(grid_plot)
    }
  }
  
  return(all_ale_plots)
}

# Gebruik de nieuwe functie om ALE plots te maken voor de top 10 variabelen
top10_ale_plots <- create_ale_plots_top10_variables(
  models = models,
  train_data = as.data.frame(train_x),
  target_variables = target_variables
)
```


```{r pdp plots}
#| label: Complete PDP Plot Creation for All Target Variables
# Function to create PDP plots for all target variables with variable mapping
create_pdp_plots_all_targets <- function(models, train_data, target_variables) {
  
  # Define continuous variables for plots
  continuous_vars <- c(
    "WATDTE_m_WATDTE_", "WATERBTE_m_WATERBTE_", "SLIBDTE_m_SLIBDTE_",
    "zichtdte", "TALBVWTR_graad_TALBVWTR_", "PTN_BEDKG_%_KROOS_", "jaar"
  )
  
  # Variable mapping for readable names
  var_mapping <- list(
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)", 
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "jaar" = "Jaar"
  )
  
  # Target variable mapping for readable names
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Verify which variables exist in training data
  valid_vars <- intersect(continuous_vars, colnames(train_data))
  
  # Store all PDP plots
  all_pdp_plots <- list()
  
  # Loop through each target variable
  for (target_var in target_variables) {
    cat("Creating PDP plots for target:", target_var, "\n")
    
    model <- models[[target_var]]
    target_plots <- list()
    
    # Create PDP plots for each continuous variable
    for (var in valid_vars) {
      cat("  Creating PDP plot for:", var, "\n")
      
      # Create partial dependence plot
      pd <- partial(model, pred.var = var, train = as.data.frame(train_data))
      
      # Create plot with target-specific labeling
      p <- autoplot(pd) +
        labs(
          title = paste("Effect van", var_mapping[[var]], "op", target_mapping[[target_var]]),
          subtitle = "Partial Dependence Plot",
          x = var_mapping[[var]],
          y = paste("Effect op", target_mapping[[target_var]])
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, face = "bold"),
          plot.subtitle = element_text(size = 12, color = "darkred"),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.minor = element_blank()
        )
      
      target_plots[[var]] <- p
      print(p)
    }
    
    # Store plots for this target
    all_pdp_plots[[target_var]] <- target_plots
    
    # Create combined plot grid for this target
    if (length(target_plots) > 0) {
      if (requireNamespace("gridExtra", quietly = TRUE)) {
        grid_plot <- gridExtra::grid.arrange(
          grobs = target_plots, 
          ncol = 2,
          top = paste("PDP Plots voor", target_mapping[[target_var]])
        )
        print(grid_plot)
      }
    }
    
    cat("\n")
  }
  
  return(all_pdp_plots)
}

# Function to create comparison plots of PDPs across targets
create_comparison_pdp_plots <- function(all_pdp_plots, var_to_compare) {
  comparison_plots <- list()
  
  for (target in names(all_pdp_plots)) {
    if (var_to_compare %in% names(all_pdp_plots[[target]])) {
      plot <- all_pdp_plots[[target]][[var_to_compare]] +
        labs(title = paste(target, "-", var_to_compare)) +
        theme(plot.title = element_text(size = 12))
      
      comparison_plots[[target]] <- plot
    }
  }
  
  if (length(comparison_plots) > 0) {
    grid_plot <- gridExtra::grid.arrange(
      grobs = comparison_plots,
      ncol = 2,
      top = paste("Vergelijking PDP plots voor", var_to_compare)
    )
    print(grid_plot)
  }
  
  return(comparison_plots)
}

# Function to create side-by-side comparison of ALE vs PDP plots
create_ale_pdp_comparison <- function(all_ale_plots, all_pdp_plots, target_var, var_to_compare) {
  if (!target_var %in% names(all_ale_plots) || !target_var %in% names(all_pdp_plots)) {
    cat("Target variable not found in plots\n")
    return(NULL)
  }
  
  if (!var_to_compare %in% names(all_ale_plots[[target_var]]) || 
      !var_to_compare %in% names(all_pdp_plots[[target_var]])) {
    cat("Variable not found in plots\n")
    return(NULL)
  }
  
  # Get plots
  ale_plot <- all_ale_plots[[target_var]][[var_to_compare]]
  pdp_plot <- all_pdp_plots[[target_var]][[var_to_compare]]
  
  # Modify titles for comparison
  ale_plot <- ale_plot + 
    labs(subtitle = "ALE Plot") +
    theme(plot.title = element_text(size = 14))
  
  pdp_plot <- pdp_plot + 
    labs(subtitle = "PDP Plot") +
    theme(plot.title = element_text(size = 14))
  
  # Arrange side by side
  comparison <- gridExtra::grid.arrange(
    ale_plot, pdp_plot, 
    ncol = 2,
    top = paste("ALE vs PDP:", var_to_compare, "voor", target_var)
  )
  
  return(comparison)
}

# Main execution
# Create PDP plots for all targets
all_pdp_plots <- create_pdp_plots_all_targets(
  models = models,
  train_data = as.data.frame(train_x),
  target_variables = target_variables
)

# Create comparison plots for specific variables across all targets
cat("Creating PDP comparison plots...\n")

# Example: Compare waterbreedte effects across all targets
waterbreedte_pdp_comparison <- create_comparison_pdp_plots(all_pdp_plots, "WATERBTE_m_WATERBTE_")

# Example: Compare waterdiepte effects across all targets  
waterdiepte_pdp_comparison <- create_comparison_pdp_plots(all_pdp_plots, "WATDTE_m_WATDTE_")

# Example: Compare kroos effects across all targets
kroos_pdp_comparison <- create_comparison_pdp_plots(all_pdp_plots, "PTN_BEDKG_%_KROOS_")

# Create direct ALE vs PDP comparisons for important variables
cat("Creating ALE vs PDP comparison plots...\n")

# Compare ALE vs PDP for waterdiepte effect on submerse vegetation
create_ale_pdp_comparison(all_ale_plots, all_pdp_plots, "submers_bedekking", "WATDTE_m_WATDTE_")

# Compare ALE vs PDP for zichtdiepte effect on submerse vegetation
create_ale_pdp_comparison(all_ale_plots, all_pdp_plots, "submers_bedekking", "zichtdte")

# Compare ALE vs PDP for waterbreedte effect on emerse vegetation
create_ale_pdp_comparison(all_ale_plots, all_pdp_plots, "emers_bedekking", "WATERBTE_m_WATERBTE_")

# Compare ALE vs PDP for kroosbedekking effect on submerse vegetation
create_ale_pdp_comparison(all_ale_plots, all_pdp_plots, "submers_bedekking", "PTN_BEDKG_%_KROOS_")

cat("PDP plots creation completed for all target variables!\n")
```

# Alle variabelen in de huidige sessie opslaan

```{r}
# save.image("anlb_project.RData")
```





# NOT USED (old/ backup)

```{r aleplot oud}
#| label: ale plots

# Create ALE plots for all target variables
create_ale_plots_all_targets <- function(models, train_data, target_variables) {
  
  # Define continuous variables for ALE plots
  continuous_vars <- c(
    "WATDTE_m_WATDTE_", "WATERBTE_m_WATERBTE_", "SLIBDTE_m_SLIBDTE_",
    "zichtdte", "TALBVWTR_graad_TALBVWTR_", "PTN_BEDKG_%_KROOS_", "jaar"
  )
  
  # Variable mapping for readable names
  var_mapping <- list(
    "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
    "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)", 
    "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
    "zichtdte" = "Zichtdiepte/Waterdiepte",
    "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
    "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
    "jaar" = "Jaar"
  )
  
  # Target variable mapping for readable names
  target_mapping <- list(
    "submers_bedekking" = "Submerse Bedekking (%)",
    "emers_bedekking" = "Emerse Bedekking (%)",
    "submers_soorten" = "Submerse Soorten (aantal)",
    "emers_soorten" = "Emerse Soorten (aantal)"
  )
  
  # Verify which variables exist in training data
  valid_vars <- intersect(continuous_vars, colnames(train_data))
  
  # Store all ALE plots
  all_ale_plots <- list()
  
  # Loop through each target variable
  for (target_var in target_variables) {
    cat("Creating ALE plots for target:", target_var, "\n")
    
    model <- models[[target_var]]
    target_plots <- list()
    
    # Create ALE plots for each continuous variable
    for (var in valid_vars) {
      cat("  Creating ALE plot for:", var, "\n")
      
      # Calculate ALE values
      ale_data <- create_ale_plot(model, train_data, var)
      
      # Create plot with target-specific labeling
      p <- ggplot(ale_data, aes(x = x, y = ale)) +
        geom_line(linewidth = 1.2, color = "steelblue") +
        geom_rug(sides = "b", alpha = 0.2) +
        labs(
          title = paste("ALE:", var_mapping[[var]]),
          subtitle = paste("Effect op", target_mapping[[target_var]]),
          x = var_mapping[[var]],
          y = paste("Effect op", target_mapping[[target_var]])
        ) +
        theme_minimal() +
        theme(
          plot.title = element_text(size = 14, face = "bold"),
          plot.subtitle = element_text(size = 12),
          axis.title = element_text(size = 12),
          axis.text = element_text(size = 10),
          panel.grid.minor = element_blank()
        )
      
      target_plots[[var]] <- p
      print(p)
    }
    
    # Store plots for this target
    all_ale_plots[[target_var]] <- target_plots
    
    # Create combined plot grid for this target
    if (length(target_plots) > 0) {
      if (requireNamespace("gridExtra", quietly = TRUE)) {
        grid_plot <- gridExtra::grid.arrange(
          grobs = target_plots, 
          ncol = 2,
          top = paste("ALE Plots voor", target_mapping[[target_var]])
        )
        print(grid_plot)
      }
    }
    
    cat("\n")
  }
  
  return(all_ale_plots)
}

# Create ALE plots for all targets
all_ale_plots <- create_ale_plots_all_targets(
  models = models,
  train_data = as.data.frame(train_x),
  target_variables = target_variables
)

# Optional: Create comparison plots for specific variables across all targets
create_comparison_ale_plots <- function(all_ale_plots, var_to_compare) {
  comparison_plots <- list()
  
  for (target in names(all_ale_plots)) {
    if (var_to_compare %in% names(all_ale_plots[[target]])) {
      plot <- all_ale_plots[[target]][[var_to_compare]] +
        labs(title = paste(target, "-", var_to_compare)) +
        theme(plot.title = element_text(size = 12))
      
      comparison_plots[[target]] <- plot
    }
  }
  
  if (length(comparison_plots) > 0) {
    grid_plot <- gridExtra::grid.arrange(
      grobs = comparison_plots,
      ncol = 2,
      top = paste("Vergelijking ALE plots voor", var_to_compare)
    )
    print(grid_plot)
  }
  
  return(comparison_plots)
}

# .Example: Compare waterbreedte effects across all targets
waterbreedte_comparison <- create_comparison_ale_plots(all_ale_plots, "WATERBTE_m_WATERBTE_")

# Example: Compare waterdiepte effects across all targets  
waterdiepte_comparison <- create_comparison_ale_plots(all_ale_plots, "WATDTE_m_WATDTE_")

# Summary function to show key insights
summarize_ale_effects <- function(all_ale_plots) {
  cat("=== ALE PLOT SAMENVATTING ===\n\n")
  
  for (target in names(all_ale_plots)) {
    cat("Target variabele:", target, "\n")
    cat("Aantal ALE plots gemaakt:", length(all_ale_plots[[target]]), "\n")
    cat("Variabelen geanalyseerd:", paste(names(all_ale_plots[[target]]), collapse = ", "), "\n")
    cat("\n")
  }
}

# Show summary
summarize_ale_effects(all_ale_plots)

# Create ALE plots for each continuous feature
continuous_vars <- c(
  "WATDTE_m_WATDTE_", "WATERBTE_m_WATERBTE_", "SLIBDTE_m_SLIBDTE_",
  "zichtdte", "TALBVWTR_graad_TALBVWTR_", "PTN_BEDKG_%_KROOS_", "jaar"
)

# Verify these variables exist in your training data
valid_vars <- intersect(continuous_vars, colnames(train_x))
cat("Creating ALE plots for these variables:", paste(valid_vars, collapse=", "), "\n")

var_mapping <- list(
  "WATDTE_m_WATDTE_" = "Waterdiepte (m)",
  "WATERBTE_m_WATERBTE_" = "Waterbreedte (m)",
  "SLIBDTE_m_SLIBDTE_" = "Slibdikte (m)",
  "zichtdte" = "Zichtdiepte/Waterdiepte",
  "TALBVWTR_graad_TALBVWTR_" = "Taludhelling (graden)",
  "PTN_BEDKG_%_KROOS_" = "Kroosbedekking (%)",
  "jaar" = "Jaar"
)

# Create ALE plots
ale_plots <- list()
for (var in valid_vars) {
  cat("Creating ALE plot for:", var, "\n")
  
  # Calculate ALE values
  ale_data <- create_ale_plot(xgb_model, as.data.frame(train_x), var)
  
  # Create plot
  p <- ggplot(ale_data, aes(x = x, y = ale)) +
    geom_line(linewidth = 1.2, color = "steelblue") +
    geom_rug(sides = "b", alpha = 0.2) +
    labs(
      title = paste("ALE Plot:", var_mapping[[var]]),
      x = var,
      y = paste("Effect op", target_var)
    ) +
     theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      panel.grid.minor = element_blank()
    )
  
  ale_plots[[var]] <- p
  print(p)
}

# Display all plots together
if (length(ale_plots) > 0) {
  if (requireNamespace("gridExtra", quietly = TRUE)) {
    grid_plot <- gridExtra::grid.arrange(grobs = ale_plots, ncol = 2)
    print(grid_plot)
  }
}
```

## Import data not used

-   geodatabase not complete

```{r data geodatabase}
# Load sken je sloot------------
layer_list <- st_layers(paste0(workspace,'./Sken je sloot.gdb'))
layer_list <- unique(layer_list$name)
ss_2017 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[1])
ss_2018 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[3])
ss_2019 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[5])
ss_2020 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[7])
ss_2021 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[9])
ss_2022 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[11])
ss_2023 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[13])
ss_2024 <- st_read(paste0(workspace,'./Sken je sloot.gdb'), layer = layer_list[15])

# combine---------------------
ss <- list(ss_2017,ss_2018,ss_2019,ss_2020,ss_2021,ss_2022,ss_2023,ss_2024)
ss <- rbindlist(ss, fill = T, use.names = T)
setDT(ss)
ss[,datum := as.Date(datum)]
ss[,jaar := year(datum)]
ss[globalid %in% ss_2017$globalid, jaar := 2017]
ss[globalid %in% ss_2019$globalid, jaar := 2019]

# reformat------------------------
ss2<- melt(ss, id.vars = c('globalid','datum','tijd','jaar','Shape'))
ss2 <- ss2[!is.na(value),]
ov_ss2 <- dcast(ss2, variable~jaar, value.var = 'value', fun.aggregate = length)
fwrite(ov_ss2, file= paste0('skenjesloot_pars.csv'), sep = ';', dec ='.', )

# filter set for unique locations (sloten), unique not possible with sf data -----------------------------
ssloc <- ss2[variable == 'blnDoorzicht',]
ssloc <- st_as_sf(ssloc, crs = 4326) %>% st_transform(28992)
ssloc <- st_join(ssloc, st_buffer(brpagv[!(brpagv$category == 'Landschapselement'),], dist = 5), left = TRUE, largest = TRUE)
check<- unique(ssloc[is.na(ssloc$ref_id),c('globalid','Shape','jaar.x')])
setDT(ssloc)
ssloc[,jaar_sjs := jaar.x] 
ssloc[,jaar.x:=NULL];ssloc[,jaar.y:=NULL]

# combine locations
ssloc[,brp_nr := rep(seq_len(.N), each = 1, length.out = .N), by = c('ref_id')]
# ssloc <- st_as_sf(ssloc)
ssloc[,dist := st_distance(Shape[brp_nr == 1], Shape), by ='ref_id'] 
ssloc[,id := globalid]
ssloc[,dist := as.numeric(dist)]
sslocmatch <- ssloc[brp_nr == 1,]
ssloc <- merge(ssloc, sslocmatch[,c('globalid','ref_id', 'jaar_sjs')], by = 'ref_id', suffixes = c('','_match'), all.x = TRUE, all.y = FALSE)
# combine locs within 100 meter on same brp gewasperceel in verschillende jaren (soms zijn het wel andere sloten)
ssloc[dist < 100 & !(jaar_sjs == jaar_sjs_match), id := globalid_match]
ssloc <- st_as_sf(ssloc)
st_write(ssloc, 'ssloc.gpkg')
```

-   fews format not complete

```{r import skenjesloot fews format}
skenjesloot <- list.files(path= paste0(workspace,'./skenjesloot_fewsformat/'), pattern=".csv", full.names =  T)
skenjesloot <- lapply(skenjesloot, fread, sep=';')
skenjesloot <- rbindlist(skenjesloot, fill =T, use.names = T)
# unique(skenjesloot$datum)
skenjesloot[,datum := as.Date(datum, format = "%d-%m-%Y")]
skenjesloot[,jaar := year(datum)]
skenjesloot[,maand := month(datum)]
skenjesloot[,meetwaarde := as.numeric(meetwaarde)]
skenjesloot[,c('xcoormonster','ycoormonster')  := list(as.integer(xcoormonster),as.integer(ycoormonster))]
parameter <- data.table::fread('../WaterEcoInzicht/input/20250603/parameterid.csv', fill = TRUE)
skenjesloot <- merge(skenjesloot, parameter[,c("code","naam", 'grootheid',"categorie","H_min", "H_max")], by.x = 'parameterid', by.y = 'code', suffixes = c('','_parameter'), all.x = TRUE)

```

-   selection agrarisch not by area but only data in same EAG's as anlb are used for analysis

```{r agrarische EAG sel}
# bereken agrarisch oppervlak per EAG
brpagv$agropp <- as.numeric(st_area(brpagv))
brpagv <- brpagv %>% as.data.table()
brpagv <- brpagv[,agropptot := sum(as.numeric(agropp)), by = c('Code','category')]
brpagv_agg <- unique(brpagv[,c('Code','category','agropptot')])
brpagv_agg <- dcast(brpagv_agg,Code~category, value.var = 'agropptot', fill = 0)

EAG <- merge(EAG, brpagv_agg, by = 'Code', all.x = TRUE)
setDT(EAG)
EAG[,OppLand:= as.numeric(Land_m2)]
EAG[,Relagr := (Bouwland+Grasland)/ OppLand]
EAG[Relagr > 0.5, gebiedstype := 'agrarisch']
EAG[is.na(gebiedstype), gebiedstype := 'overig']
st_write(EAG,'eag_gebiedstypeagrarisch.gpkg', append =FALSE)

```

## data verwerking not used
```{r anlb 2024 overzicht}
# overzicht 2024 ------------
anlb2024 <- merge(anlb2024[,-c('pakket2','pakket3')], anlb_cat, by = 'pakket', all.x = TRUE)
anlb2024 <- anlb2024[pakket2 == 'water',]
anlb2024 <- st_as_sf(anlb2024)
anlb2024 <- st_join(anlb2024, EAG, left = TRUE, largest = TRUE)
setDT(anlb2024)
write.table(anlb2024[,-'geom'],file ='anlb2024.csv',sep =';',dec='.', row.names = FALSE)
wat_agv_24 <- anlb2024[!is.na(Code) & pakket2 == 'water', sum(as.numeric(opp)), by = c('collectief')]
```

## visualisatie not used
```{r data exploration sjs}


# create table with beheer---------------
sjs_beheer <- ss2[grepl('^BEHPK', variable),]
ss2_beheer <- merge(ss2, sjs_beheer, by =c('globalid','jaar'),allow.cartesian = T, suffixes = c('','_beheer'))
ss2_beheer[value_beheer == 0, variable_beheer := "regulier beheer"]
id_beheer <- ss2_beheer[value_beheer == 1, globalid]
ss2_beheer <- ss2_beheer[!(variable_beheer == "regulier beheer" & globalid %in% id_beheer), ]

# add N obs
ss2_beheer[,n_obs:=uniqueN(globalid),by =c('variable','variable_beheer','jaar')]

# figuur metingen per pakket per jaar (geodb) --------------
ggplot(data = ss2[grepl('^BEHPK', variable),])+
  geom_bar(aes(x = variable, fill = as.factor(value)), 
           position = 'stack') +
  coord_flip()+
  facet_wrap(~jaar)+
  scale_fill_discrete(labels = c('onbekend','afwezig','aanwezig'))+
  guides(fill=guide_legend(title=''))+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 8, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Beheerpakketten in (s)Ken je sloot") +
    labs(x="",y="aantal opnamen")

## bedekking emers-------------
ggplot(data = ss2_beheer[variable == 'EMSPTN',])+
  geom_boxplot(aes(x = variable_beheer, y = as.numeric(value))) +
  geom_text(aes(x = variable_beheer, y=0, label = n_obs))+
  facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking emers") +
    labs(x="",y="%")
  # ylim(0,15)

## submers-------------
ggplot(data = ss2_beheer[variable == 'SUBMSPTN',])+
  geom_boxplot(aes(x = variable_beheer, y = as.numeric(value))) +
  geom_text(aes(x = variable_beheer, y=0, label = n_obs))+
  facet_wrap(jaar~.)+
  theme(
      strip.background = element_blank(),
      title = element_text(size= 10),
      axis.text.x = element_text(size= 10, angle = 45, hjust =1),
      axis.text.y = element_text(size= 10),
      axis.ticks =  element_line(colour = "black"),
      axis.line = element_line(colour='black'),
      plot.background = element_blank(),
      axis.title=element_text(size=10))+
    ggtitle( "Bedekking submers") +
    labs(x="",y="%")
  # ylim(0,15)

```